<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>表情训练教练 - 专业版</title>
    
    <!--
    本地运行说明：
    1. 摄像头需要 HTTPS 或 localhost 环境
    2. 使用 Python 启动本地服务：
       python -m http.server 8000
       然后访问 http://localhost:8000
    3. 或使用 Python 3:
       python3 -m http.server 8000
    4. 所有处理在本地完成，不上传任何图像或视频数据
    -->
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .app-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar main tips"
                "results results results";
            grid-template-rows: auto 1fr auto;
            grid-template-columns: 300px 1fr 350px;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }
        
        /* Header - Progress and Badges */
        .header {
            grid-area: header;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .progress-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .total-score {
            font-size: 24px;
            font-weight: bold;
            color: #4ecdc4;
            min-width: 80px;
        }
        
        .progress-bar {
            flex: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #45b7d1);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .badges {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .badge {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .badge.excellent { border-color: #4ecdc4; background: rgba(78, 205, 196, 0.2); }
        .badge.good { border-color: #45b7d1; background: rgba(69, 183, 209, 0.2); }
        .badge.needs-work { border-color: #ff6b6b; background: rgba(255, 107, 107, 0.2); }
        
        .badge-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .badge-name {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .badge-score {
            font-size: 18px;
            font-weight: bold;
        }
        
        .tech-indicators {
            display: flex;
            justify-content: space-around;
            font-size: 11px;
            opacity: 0.7;
        }
        
        .tech-item {
            text-align: center;
        }
        
        /* Sidebar - Controls */
        .sidebar {
            grid-area: sidebar;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #4ecdc4;
        }
        
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .mode-option {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 12px;
        }
        
        .mode-option.active {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.2);
        }
        
        select, button {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:focus, button:hover {
            border-color: #4ecdc4;
            outline: none;
        }
        
        button {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            margin-bottom: 10px;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }
        
        /* Main Video Area */
        .main-area {
            grid-area: main;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
        }
        
        .video-status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
        }
        
        .training-info {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .current-command {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 5px;
        }
        
        .countdown {
            font-size: 36px;
            font-weight: bold;
            color: #ff6b6b;
            margin: 10px 0;
        }
        
        /* Tips Panel */
        .tips-panel {
            grid-area: tips;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .tips-title {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tip-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.4;
            border-left: 4px solid #4ecdc4;
        }
        
        /* Results Section */
        .results {
            grid-area: results;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }
        
        .results.visible {
            display: block;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .results-title {
            font-size: 20px;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .amplitude-label {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .amplitude-subtle { color: #45b7d1; }
        .amplitude-medium { color: #4ecdc4; }
        .amplitude-exaggerated { color: #ff6b6b; }
        
        .charts-container {
            display: flex;
            gap: 20px;
        }
        
        .chart-section {
            flex: 1;
        }
        
        .chart-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        canvas.chart {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .app-container {
                grid-template-areas: 
                    "header"
                    "sidebar"
                    "main"
                    "tips"
                    "results";
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <div class="progress-section">
                <div class="total-score" id="totalScore">0</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="badges">
                <div class="badge" id="clarityBadge">
                    <div class="badge-icon">🎯</div>
                    <div class="badge-name">Clarity</div>
                    <div class="badge-score" id="clarityScore">0</div>
                </div>
                <div class="badge" id="consistencyBadge">
                    <div class="badge-icon">⚖️</div>
                    <div class="badge-name">Consistency</div>
                    <div class="badge-score" id="consistencyScore">0</div>
                </div>
                <div class="badge" id="intensityBadge">
                    <div class="badge-icon">⚡</div>
                    <div class="badge-name">Intensity</div>
                    <div class="badge-score" id="intensityScore">0</div>
                </div>
                <div class="badge" id="truthBadge">
                    <div class="badge-icon">💫</div>
                    <div class="badge-name">Truth</div>
                    <div class="badge-score" id="truthScore">0</div>
                </div>
            </div>
            
            <div class="tech-indicators">
                <div class="tech-item">
                    <div>Match</div>
                    <div id="matchScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Symmetry</div>
                    <div id="symmetryScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Stability</div>
                    <div id="stabilityScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Aesthetics</div>
                    <div id="aestheticsScore">0</div>
                </div>
            </div>
        </div>
        
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="control-group">
                <label class="control-label">表演模式</label>
                <div class="mode-selector">
                    <div class="mode-option active" data-mode="film">
                        <div>🎬</div>
                        <div>影视镜头</div>
                    </div>
                    <div class="mode-option" data-mode="stage">
                        <div>🎭</div>
                        <div>舞台表演</div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label" for="commandSelect">训练口令</label>
                <select id="commandSelect">
                    <option value="smile_natural">自然微笑（2秒）</option>
                    <option value="smile_duchenne">带眼笑/Duchenne（2秒）</option>
                    <option value="neutral">中性脸（2秒）</option>
                    <option value="focus">专注（2秒）</option>
                    <option value="surprised">惊讶（1.5秒）</option>
                    <option value="sad">悲伤（2秒）</option>
                    <option value="disgust">厌恶（2秒）</option>
                    <option value="angry">愤怒（2秒）</option>
                </select>
            </div>
            
            <div class="control-group">
                <button class="btn-primary" id="startBtn">Start Training</button>
                <button class="btn-secondary" id="nextBtn">Next Expression</button>
                <button class="btn-secondary" id="calibrateBtn">Quick Calibrate</button>
            </div>
        </div>
        
        <!-- Main Video Area -->
        <div class="main-area">
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="overlayCanvas"></canvas>
                <div class="video-status" id="videoStatus">等待摄像头...</div>
            </div>
            
            <div class="training-info">
                <div class="current-command" id="currentCommand">选择训练口令并点击开始</div>
                <div class="countdown" id="countdown"></div>
            </div>
        </div>
        
        <!-- Tips Panel -->
        <div class="tips-panel">
            <div class="tips-title">
                <span>💡</span>
                <span>表演建议</span>
            </div>
            <div id="tipsContainer">
                <div class="tip-item">准备开始训练，选择表演模式和目标表情</div>
            </div>
        </div>
        
        <!-- Results Section -->
        <div class="results" id="resultsSection">
            <div class="results-header">
                <div class="results-title" id="resultsTitle">训练结果</div>
                <div class="amplitude-label" id="amplitudeLabel">Medium</div>
            </div>
            
            <div class="charts-container">
                <div class="chart-section">
                    <div class="chart-title">四维评分</div>
                    <canvas id="radarChart" class="chart" width="300" height="200"></canvas>
                </div>
                <div class="chart-section">
                    <div class="chart-title">技术指标</div>
                    <canvas id="barChart" class="chart" width="300" height="200"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 训练口令配置
        const TRAINING_COMMANDS = {
            smile_natural: {
                id: "smile_natural",
                text: "请做自然微笑并保持两秒",
                tts: true,
                duration: 2000,
                target: "smile",
                duchenne: false,
                difficulty: "E"
            },
            smile_duchenne: {
                id: "smile_duchenne", 
                text: "请做带眼笑（眼角轻微眯起）并保持两秒",
                tts: true,
                duration: 2000,
                target: "smile",
                duchenne: true,
                difficulty: "M"
            },
            neutral: {
                id: "neutral",
                text: "请保持中性脸部表情两秒",
                tts: true,
                duration: 2000,
                target: "neutral",
                duchenne: false,
                difficulty: "E"
            },
            focus: {
                id: "focus",
                text: "请做专注表情并保持两秒",
                tts: true,
                duration: 2000,
                target: "focus",
                duchenne: false,
                difficulty: "M"
            },
            surprised: {
                id: "surprised",
                text: "请做惊讶表情并保持一秒半",
                tts: true,
                duration: 1500,
                target: "surprised",
                duchenne: false,
                difficulty: "M"
            },
            sad: {
                id: "sad",
                text: "请做悲伤表情并保持两秒",
                tts: true,
                duration: 2000,
                target: "sad",
                duchenne: false,
                difficulty: "H"
            },
            disgust: {
                id: "disgust",
                text: "请做厌恶表情并保持两秒",
                tts: true,
                duration: 2000,
                target: "disgust",
                duchenne: false,
                difficulty: "H"
            },
            angry: {
                id: "angry",
                text: "请做愤怒表情并保持两秒",
                tts: true,
                duration: 2000,
                target: "angry",
                duchenne: false,
                difficulty: "H"
            }
        };

        // MediaPipe landmarks 索引 (基于468点模型)
        const LANDMARKS = {
            // 嘴部关键点
            MOUTH: {
                LEFT_CORNER: 61,    // 左嘴角
                RIGHT_CORNER: 291,  // 右嘴角
                TOP: 13,           // 上唇中心
                BOTTOM: 14,        // 下唇中心
                UPPER_LIP: [12, 15, 16, 17, 18, 200], // 上唇轮廓
                LOWER_LIP: [146, 91, 181, 84, 17, 314, 405, 320, 307, 375] // 下唇轮廓
            },
            // 左眼关键点
            LEFT_EYE: {
                TOP: 159,
                BOTTOM: 145,
                LEFT: 33,
                RIGHT: 133,
                OUTLINE: [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246]
            },
            // 右眼关键点
            RIGHT_EYE: {
                TOP: 386,
                BOTTOM: 374,
                LEFT: 362,
                RIGHT: 263,
                OUTLINE: [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398]
            },
            // 眉毛关键点
            LEFT_EYEBROW: {
                INNER: 55,   // 左眉内侧
                OUTER: 46,   // 左眉外侧
                CENTER: 70   // 左眉中心
            },
            RIGHT_EYEBROW: {
                INNER: 285,  // 右眉内侧
                OUTER: 276,  // 右眉外侧
                CENTER: 300  // 右眉中心
            },
            NOSE_TIP: 1,     // 鼻尖
            FACE_OUTLINE: [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109]
        };

        // 全局变量
        let faceMesh;
        let camera;
        let currentMode = 'film';  // 'film' or 'stage'
        let isTraining = false;
        let isCalibrating = false;
        let baseline = null; // 个人基线
        let currentSession = null;
        let metricsBuffer = [];
        let lastFrameTime = 0;
        let frameCount = 0;

        // 初始化应用
        document.addEventListener('DOMContentLoaded', async () => {
            await initializeCamera();
            setupEventListeners();
            updateUI();
        });

        // 设置事件监听器
        function setupEventListeners() {
            // 模式切换
            document.querySelectorAll('.mode-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.mode-option').forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    currentMode = option.dataset.mode;
                    updateUI();
                });
            });

            // 按钮事件
            document.getElementById('startBtn').addEventListener('click', startTraining);
            document.getElementById('nextBtn').addEventListener('click', nextExpression);
            document.getElementById('calibrateBtn').addEventListener('click', quickCalibrate);

            // 口令选择
            document.getElementById('commandSelect').addEventListener('change', updateUI);
        }

        // 初始化摄像头和MediaPipe
        async function initializeCamera() {
            try {
                // 获取摄像头
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const videoElement = document.getElementById('videoElement');
                videoElement.srcObject = stream;
                
                videoElement.onloadedmetadata = () => {
                    const canvas = document.getElementById('overlayCanvas');
                    canvas.width = videoElement.videoWidth;
                    canvas.height = videoElement.videoHeight;
                };

                await initializeFaceMesh();
                document.getElementById('videoStatus').textContent = '摄像头就绪';
                
            } catch (error) {
                console.error('摄像头初始化失败:', error);
                document.getElementById('videoStatus').textContent = '摄像头访问失败';
            }
        }

        async function initializeFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onResults);

            camera = new Camera(document.getElementById('videoElement'), {
                onFrame: async () => {
                    await faceMesh.send({image: document.getElementById('videoElement')});
                },
                width: 640,
                height: 480
            });

            camera.start();
        }

        // MediaPipe结果处理
        function onResults(results) {
            const now = performance.now();
            
            // 计算FPS
            frameCount++;
            if (now - lastFrameTime >= 1000) {
                lastFrameTime = now;
                frameCount = 0;
            }

            const canvas = document.getElementById('overlayCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // 绘制轮廓
                drawOverlay(ctx, landmarks);
                
                // 提取特征
                const metrics = extractMetrics(landmarks);
                
                // 收集训练数据
                if ((isTraining || isCalibrating) && metrics) {
                    metricsBuffer.push({
                        timestamp: now,
                        metrics: metrics
                    });
                }
                
                document.getElementById('videoStatus').textContent = '面部检测正常';
            } else {
                document.getElementById('videoStatus').textContent = '未检测到面部';
            }
        }

        // 绘制面部轮廓 - 简化版本，主要显示嘴部和眼部
        function drawOverlay(ctx, landmarks) {
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;

            // 绘制嘴部轮廓
            drawLandmarkContour(ctx, LANDMARKS.MOUTH.UPPER_LIP, landmarks, '#4ecdc4');
            drawLandmarkContour(ctx, LANDMARKS.MOUTH.LOWER_LIP, landmarks, '#4ecdc4');

            // 绘制眼部轮廓
            drawLandmarkContour(ctx, LANDMARKS.LEFT_EYE.OUTLINE, landmarks, '#45b7d1');
            drawLandmarkContour(ctx, LANDMARKS.RIGHT_EYE.OUTLINE, landmarks, '#45b7d1');
        }

        function drawLandmarkContour(ctx, indices, landmarks, color) {
            if (!indices || !landmarks) return;
            
            ctx.strokeStyle = color;
            ctx.beginPath();
            
            let started = false;
            indices.forEach(idx => {
                if (landmarks[idx]) {
                    const point = landmarks[idx];
                    const x = point.x * ctx.canvas.width;
                    const y = point.y * ctx.canvas.height;
                    
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            });
            
            ctx.closePath();
            ctx.stroke();
        }

        /**
         * 特征提取函数
         * 基于MediaPipe 468点模型提取关键表情特征
         */
        function extractMetrics(landmarks) {
            if (!landmarks || landmarks.length < 468) return null;

            try {
                // 嘴部特征点
                const mouth = {
                    leftCorner: landmarks[LANDMARKS.MOUTH.LEFT_CORNER],
                    rightCorner: landmarks[LANDMARKS.MOUTH.RIGHT_CORNER], 
                    top: landmarks[LANDMARKS.MOUTH.TOP],
                    bottom: landmarks[LANDMARKS.MOUTH.BOTTOM]
                };

                // 眼部特征点
                const eyes = {
                    leftTop: landmarks[LANDMARKS.LEFT_EYE.TOP],
                    leftBottom: landmarks[LANDMARKS.LEFT_EYE.BOTTOM],
                    leftLeft: landmarks[LANDMARKS.LEFT_EYE.LEFT],
                    leftRight: landmarks[LANDMARKS.LEFT_EYE.RIGHT],
                    rightTop: landmarks[LANDMARKS.RIGHT_EYE.TOP],
                    rightBottom: landmarks[LANDMARKS.RIGHT_EYE.BOTTOM],
                    rightLeft: landmarks[LANDMARKS.RIGHT_EYE.LEFT],
                    rightRight: landmarks[LANDMARKS.RIGHT_EYE.RIGHT]
                };

                // 眉毛特征点
                const brows = {
                    leftInner: landmarks[LANDMARKS.LEFT_EYEBROW.INNER],
                    leftOuter: landmarks[LANDMARKS.LEFT_EYEBROW.OUTER],
                    leftCenter: landmarks[LANDMARKS.LEFT_EYEBROW.CENTER],
                    rightInner: landmarks[LANDMARKS.RIGHT_EYEBROW.INNER],
                    rightOuter: landmarks[LANDMARKS.RIGHT_EYEBROW.OUTER],
                    rightCenter: landmarks[LANDMARKS.RIGHT_EYEBROW.CENTER]
                };

                const distance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                // 1. mouthRatio = mouthWidth / mouthHeight (微笑时增大)
                const mouthWidth = distance(mouth.leftCorner, mouth.rightCorner);
                const mouthHeight = distance(mouth.top, mouth.bottom);
                const mouthRatio = mouthWidth / (mouthHeight + 0.001);

                // 2. mouthOpen = mouthHeight / mouthWidth (惊讶/张口时增大)
                const mouthOpen = mouthHeight / (mouthWidth + 0.001);

                // 3. eyeEAR = Eye Aspect Ratio 平均值 (Duchenne笑时减小)
                const leftEAR = distance(eyes.leftTop, eyes.leftBottom) / distance(eyes.leftLeft, eyes.leftRight);
                const rightEAR = distance(eyes.rightTop, eyes.rightBottom) / distance(eyes.rightLeft, eyes.rightRight);
                const eyeEAR = (leftEAR + rightEAR) / 2;

                // 4. browActivity - 眉毛活动度 (基于眉心/眉尾垂直位移)
                const leftBrowHeight = Math.abs(brows.leftCenter.y - eyes.leftTop.y);
                const rightBrowHeight = Math.abs(brows.rightCenter.y - eyes.rightTop.y);
                const browActivity = (leftBrowHeight + rightBrowHeight) / 2;

                // 5. symMouth - 嘴部对称性 (0-1, 基于左右嘴角y坐标差)
                const symMouth = 1 - Math.min(1, Math.abs(mouth.leftCorner.y - mouth.rightCorner.y) * 1000);

                // 6. poseYawProxy - 简化偏航代理 (基于鼻尖相对面部中心的水平偏移)
                const noseTip = landmarks[LANDMARKS.NOSE_TIP];
                const poseYawProxy = 1 - Math.min(1, Math.abs(noseTip.x - 0.5) * 2);

                // 7. illumScore - 亮度均匀度粗评 (简化版本，基于面部区域)
                const illumScore = 0.8; // 简化实现，实际应基于像素亮度分析

                return {
                    mouthRatio,
                    mouthOpen,
                    eyeEAR,
                    browActivity,
                    symMouth,
                    poseYawProxy,
                    illumScore,
                    // 额外的辅助数据
                    mouthWidth,
                    mouthHeight,
                    leftEAR,
                    rightEAR
                };

            } catch (error) {
                console.error('特征提取失败:', error);
                return null;
            }
        }

        /**
         * 技术层评分函数
         * 输入: 特征数据, 模式, 目标表情, 个人基线
         * 输出: Match/Symmetry/Stability/Aesthetics 四个技术指标 (0-100)
         */
        function scoreFromMetrics(metrics, mode, target, baseline) {
            if (!metrics) return { match: 0, symmetry: 0, stability: 0, aesthetics: 0 };

            // 1. Match 匹配度 - 基于目标表情的特征匹配
            let match = calculateMatchScore(metrics, target, baseline);

            // 2. Symmetry 对称性 - 直接映射symMouth
            const symmetry = Math.round(metrics.symMouth * 100);

            // 3. Stability 稳定性 - 基于2秒窗口内的方差 (简化实现)
            const stability = calculateStability();

            // 4. Aesthetics 美观度 - 基于姿态和光照
            const aesthetics = Math.round((metrics.poseYawProxy * 0.6 + metrics.illumScore * 0.4) * 100);

            // 最终技术分合成
            const finalTechScore = Math.round(
                0.5 * match + 
                0.2 * symmetry + 
                0.2 * stability + 
                0.1 * aesthetics
            );

            return {
                match: Math.max(0, Math.min(100, match)),
                symmetry: Math.max(0, Math.min(100, symmetry)),
                stability: Math.max(0, Math.min(100, stability)),
                aesthetics: Math.max(0, Math.min(100, aesthetics)),
                final: Math.max(0, Math.min(100, finalTechScore))
            };
        }

        // 计算匹配度分数
        function calculateMatchScore(metrics, target, baseline) {
            let score = 50; // 基础分

            if (!baseline) {
                // 无基线时的绝对评分
                switch (target) {
                    case 'smile':
                        // 微笑: 嘴角上扬 (mouthRatio增大)
                        score = Math.min(100, (metrics.mouthRatio - 2.0) * 40 + 60);
                        break;
                    case 'surprised':
                        // 惊讶: 张口 + 眼裂增大
                        score = Math.min(100, metrics.mouthOpen * 80 + 30);
                        break;
                    case 'sad':
                        // 悲伤: 眉内收 + 嘴角下垂
                        score = Math.max(30, 70 - metrics.mouthRatio * 10);
                        break;
                    case 'angry':
                        // 愤怒: 眉压低 + 目光集中
                        score = 60 + (1 - metrics.browActivity) * 30;
                        break;
                    case 'disgust':
                        // 厌恶: 上唇抬起
                        score = 50 + metrics.mouthOpen * 30;
                        break;
                    case 'neutral':
                        // 中性: 各指标接近平均值
                        score = 80 - Math.abs(metrics.mouthRatio - 2.5) * 20;
                        break;
                    case 'focus':
                        // 专注: 轻微眯眼
                        score = 70 + (0.3 - metrics.eyeEAR) * 100;
                        break;
                }
            } else {
                // 基于个人基线的相对评分
                const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
                const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR; // 注意方向
                const dMouthOpen = metrics.mouthOpen - baseline.mouthOpen;
                const dBrowActivity = metrics.browActivity - baseline.browActivity;

                switch (target) {
                    case 'smile':
                        score = 60 + dMouthRatio * 50;
                        // Duchenne笑检测
                        if (TRAINING_COMMANDS[getCurrentCommandId()].duchenne && dEyeEAR > 0.02) {
                            score += 20; // 眼部参与的加分
                        }
                        break;
                    case 'surprised':
                        score = 60 + dMouthOpen * 100 + dEyeEAR * 50;
                        break;
                    case 'sad':
                        score = 60 + dBrowActivity * 40 - dMouthRatio * 30;
                        break;
                    case 'angry':
                        score = 60 - dBrowActivity * 50 + Math.min(0, -dEyeEAR * 30);
                        break;
                    case 'disgust':
                        score = 60 + dMouthOpen * 80;
                        break;
                    case 'neutral':
                        // 中性脸：各项变化都应该很小
                        const totalChange = Math.abs(dMouthRatio) + Math.abs(dEyeEAR) + Math.abs(dMouthOpen);
                        score = 80 - totalChange * 200;
                        break;
                    case 'focus':
                        score = 60 + dEyeEAR * 100; // 轻微眯眼
                        break;
                }
            }

            return Math.max(10, Math.min(100, Math.round(score)));
        }

        // 计算稳定性 (简化实现)
        function calculateStability() {
            if (metricsBuffer.length < 10) return 70; // 默认值
            
            // 计算最近10帧的嘴部特征方差
            const recent = metricsBuffer.slice(-10).map(item => item.metrics.mouthRatio);
            const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
            const variance = recent.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / recent.length;
            
            // 方差越小，稳定性越高
            return Math.max(0, Math.min(100, Math.round(100 - variance * 1000)));
        }

        /**
         * 表演学科四维映射
         * 将技术指标映射为表演专业的四个维度
         */
        function mapToActingDimensions(techScores, metrics, mode) {
            const isFilm = mode === 'film';
            const isStage = mode === 'stage';

            // 1. Clarity 清晰度 - 表情是否清晰可读
            let clarity = techScores.match * 0.7 + techScores.aesthetics * 0.3;
            
            // 舞台模式需要更大的幅度才能获得高清晰度分
            if (isStage) {
                const amplitude = calculateAmplitude(metrics);
                if (amplitude < 0.3) clarity *= 0.7; // 幅度不足扣分
            }

            // 2. Consistency 一致性 - 面部各部分是否协调
            let consistency = techScores.stability * 0.8;
            
            // 眼嘴协调性检测 (简化版)
            const eyeMouthConsistency = calculateEyeMouthConsistency(metrics);
            consistency += eyeMouthConsistency * 0.2;

            // 3. Intensity 强度 - 表情幅度是否适合模式
            const amplitude = calculateAmplitude(metrics);
            let intensity = amplitude * 100;
            
            // 根据模式调整强度评分
            if (isStage) {
                // 舞台模式偏好更高强度
                intensity *= 1.2;
            } else if (isFilm) {
                // 影视模式对过度强度扣分
                if (amplitude > 0.8) intensity *= 0.7;
            }

            // 4. Truth 真实性 - 检测假表情
            let truth = calculateTruthScore(metrics, getCurrentTarget());

            return {
                clarity: Math.max(0, Math.min(100, Math.round(clarity))),
                consistency: Math.max(0, Math.min(100, Math.round(consistency))),
                intensity: Math.max(0, Math.min(100, Math.round(intensity))),
                truth: Math.max(0, Math.min(100, Math.round(truth)))
            };
        }

        // 计算表情幅度
        function calculateAmplitude(metrics) {
            if (!baseline) return 0.5; // 无基线时返回中等幅度
            
            const dMouthRatio = Math.abs(metrics.mouthRatio - baseline.mouthRatio);
            const dEyeEAR = Math.abs(metrics.eyeEAR - baseline.eyeEAR);
            const dMouthOpen = Math.abs(metrics.mouthOpen - baseline.mouthOpen);
            
            // 综合各项特征的变化幅度
            return Math.min(1, (dMouthRatio + dEyeEAR * 2 + dMouthOpen) / 3);
        }

        // 计算眼嘴协调性
        function calculateEyeMouthConsistency(metrics) {
            if (!baseline) return 50;
            
            const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
            const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR; // 注意方向
            
            // 微笑时，嘴角上扬应该伴随眼部变化
            if (dMouthRatio > 0.1) { // 明显的嘴角上扬
                return dEyeEAR > 0.01 ? 80 : 40; // 有眼部参与得高分
            }
            
            return 60; // 默认中等协调性
        }

        // 计算真实性分数
        function calculateTruthScore(metrics, target) {
            if (!baseline) return 70; // 无基线时的默认值
            
            const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
            const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR;
            
            let truth = 75; // 基础真实性分数
            
            switch (target) {
                case 'smile':
                    // 检测假笑: 嘴角上扬但眼部无变化
                    if (dMouthRatio > 0.1 && dEyeEAR < 0.005) {
                        truth -= 30; // 严重假笑
                    } else if (dMouthRatio > 0.05 && dEyeEAR < 0.01) {
                        truth -= 15; // 轻微假笑
                    }
                    break;
                    
                case 'sad':
                    // 悲伤时眉眼嘴的方向应该一致
                    const browDown = metrics.browActivity < baseline.browActivity;
                    const mouthDown = dMouthRatio < -0.02;
                    if (browDown !== mouthDown) {
                        truth -= 20; // 表情不一致
                    }
                    break;
                    
                case 'surprised':
                    // 惊讶时眉毛上扬和张嘴应该同时发生
                    const browUp = metrics.browActivity > baseline.browActivity;
                    const mouthOpen = metrics.mouthOpen > baseline.mouthOpen + 0.05;
                    if (browUp !== mouthOpen) {
                        truth -= 15;
                    }
                    break;
            }
            
            return Math.max(30, Math.min(100, truth));
        }

        /**
         * 表演语言反馈生成
         * 基于评分结果生成自然的中文表演建议
         */
        function generateActingTips(dimScores, metrics, target, mode) {
            const tips = [];
            const isFilm = mode === 'film';
            const isStage = mode === 'stage';
            const amplitude = calculateAmplitude(metrics);
            
            // Clarity 清晰度反馈
            if (dimScores.clarity < 60) {
                if (isStage) {
                    tips.push("幅度不足，观众席第十排看不清。加大嘴角外展或眉部动作15%。");
                } else {
                    tips.push("表情不够清晰，试着让面部动作更加明确，但保持自然。");
                }
            }
            
            // Intensity 强度反馈
            if (dimScores.intensity > 85 && isFilm) {
                tips.push("幅度偏夸张，靠近镜头会显得用力。收20%保持真实感。");
            } else if (dimScores.intensity < 50 && isStage) {
                tips.push("舞台表演需要更大幅度，观众需要从远处看清你的表情。");
            }
            
            // Truth 真实性反馈
            if (dimScores.truth < 60) {
                switch (target) {
                    case 'smile':
                        tips.push("笑停在嘴角，眼神没有到位。轻眯眼10%，把注意力放在'想笑的理由'上。");
                        break;
                    case 'sad':
                        tips.push("悲伤表情需要眉眼嘴的统一。先从内心感受开始，让表情自然流露。");
                        break;
                    case 'angry':
                        tips.push("愤怒不只是眉毛，眼神的专注和嘴部的紧绷同样重要。");
                        break;
                }
            }
            
            // Consistency 一致性反馈
            if (dimScores.consistency < 60) {
                tips.push("上半脸与下半脸不统一。先定住眼神，再缓慢带动嘴角，避免冲突。");
            }
            
            // 光照和姿态反馈
            if (metrics.illumScore < 0.6) {
                tips.push("光源不在正前上方，表情阴影影响可读性，调整到30-45°角度。");
            }
            
            if (metrics.poseYawProxy < 0.7) {
                tips.push("保持正面朝向摄像头，避免侧脸影响表情识别。");
            }
            
            // 特定表情的专项建议
            addSpecificTips(tips, target, metrics, dimScores);
            
            // 如果没有问题，给予鼓励
            if (tips.length === 0) {
                const avgScore = (dimScores.clarity + dimScores.consistency + dimScores.intensity + dimScores.truth) / 4;
                if (avgScore > 80) {
                    tips.push("出色的表现！表情自然真实，符合" + (isFilm ? "影视镜头" : "舞台表演") + "的要求。");
                } else {
                    tips.push("整体不错，继续保持这种状态，多练习会更加自然。");
                }
            }
            
            return tips.slice(0, 4); // 限制为最多4条建议
        }

        // 添加特定表情的专项建议
        function addSpecificTips(tips, target, metrics, dimScores) {
            switch (target) {
                case 'smile':
                    if (TRAINING_COMMANDS[getCurrentCommandId()].duchenne) {
                        if (dimScores.truth < 70) {
                            tips.push("Duchenne笑需要眼部参与，想象真正开心的事情，让眼角自然弯曲。");
                        }
                    }
                    break;
                    
                case 'surprised':
                    if (metrics.mouthOpen < (baseline ? baseline.mouthOpen + 0.05 : 0.1)) {
                        tips.push("惊讶表情需要放下颌，拉开上下唇距离，就像真的被什么震惊了。");
                    }
                    break;
                    
                case 'sad':
                    if (dimScores.intensity < 50) {
                        tips.push("悲伤不只是嘴角下垂，眉心轻皱、眼神失焦会更有说服力。");
                    }
                    break;
                    
                case 'angry':
                    if (dimScores.clarity < 60) {
                        tips.push("愤怒表情的核心在眼神，压低眉毛的同时保持目光集中。");
                    }
                    break;
            }
        }

        // 开始训练
        async function startTraining() {
            if (isTraining) return;
            
            const commandId = document.getElementById('commandSelect').value;
            const command = TRAINING_COMMANDS[commandId];
            
            if (!command) return;
            
            isTraining = true;
            metricsBuffer = [];
            
            // 更新UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('currentCommand').textContent = command.text;
            
            // TTS播报
            if (command.tts && 'speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(command.text);
                utterance.lang = 'zh-CN';
                speechSynthesis.speak(utterance);
            }
            
            // 倒计时
            await countdown(3);
            
            // 开始记录
            currentSession = {
                mode: currentMode,
                command: command,
                startTime: performance.now()
            };
            
            // 训练计时
            setTimeout(() => {
                finishTraining();
            }, command.duration);
            
            // 显示倒计时
            showTrainingCountdown(command.duration);
        }

        // 倒计时显示
        async function countdown(seconds) {
            const countdownEl = document.getElementById('countdown');
            
            for (let i = seconds; i > 0; i--) {
                countdownEl.textContent = i;
                countdownEl.style.color = '#ff6b6b';
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            countdownEl.textContent = '开始！';
            countdownEl.style.color = '#4ecdc4';
            await new Promise(resolve => setTimeout(resolve, 500));
            countdownEl.textContent = '';
        }

        // 显示训练倒计时
        function showTrainingCountdown(duration) {
            const countdownEl = document.getElementById('countdown');
            const startTime = Date.now();
            
            const updateCountdown = () => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, duration - elapsed);
                const seconds = (remaining / 1000).toFixed(1);
                
                countdownEl.textContent = `${seconds}s`;
                countdownEl.style.color = '#4ecdc4';
                
                if (remaining > 0) {
                    requestAnimationFrame(updateCountdown);
                } else {
                    countdownEl.textContent = '';
                }
            };
            
            requestAnimationFrame(updateCountdown);
        }

        // 完成训练
        function finishTraining() {
            isTraining = false;
            currentSession.endTime = performance.now();
            
            // 分析结果
            if (metricsBuffer.length > 0) {
                analyzeSession();
            }
            
            document.getElementById('startBtn').disabled = false;
        }

        // 分析训练会话
        function analyzeSession() {
            // 计算平均特征
            const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
            if (validMetrics.length === 0) return;
            
            const avgMetrics = calculateAverageMetrics(validMetrics);
            
            // 技术层评分
            const techScores = scoreFromMetrics(avgMetrics, currentMode, getCurrentTarget(), baseline);
            
            // 表演维度映射
            const dimScores = mapToActingDimensions(techScores, avgMetrics, currentMode);
            
            // 生成反馈
            const tips = generateActingTips(dimScores, avgMetrics, getCurrentTarget(), currentMode);
            
            // 更新UI
            updateScoreDisplay(techScores, dimScores);
            updateTips(tips);
            showResults(dimScores, avgMetrics);
        }

        // 计算平均特征
        function calculateAverageMetrics(metrics) {
            const avg = {};
            const keys = Object.keys(metrics[0]);
            
            keys.forEach(key => {
                avg[key] = metrics.reduce((sum, m) => sum + m[key], 0) / metrics.length;
            });
            
            return avg;
        }

        // 更新分数显示
        function updateScoreDisplay(techScores, dimScores) {
            // 更新徽章
            updateBadge('clarityBadge', 'clarityScore', dimScores.clarity);
            updateBadge('consistencyBadge', 'consistencyScore', dimScores.consistency);
            updateBadge('intensityBadge', 'intensityScore', dimScores.intensity);
            updateBadge('truthBadge', 'truthScore', dimScores.truth);
            
            // 更新技术指标
            document.getElementById('matchScore').textContent = techScores.match;
            document.getElementById('symmetryScore').textContent = techScores.symmetry;
            document.getElementById('stabilityScore').textContent = techScores.stability;
            document.getElementById('aestheticsScore').textContent = techScores.aesthetics;
            
            // 更新总分和进度条
            const totalScore = Math.round((dimScores.clarity + dimScores.consistency + dimScores.intensity + dimScores.truth) / 4);
            document.getElementById('totalScore').textContent = totalScore;
            document.getElementById('progressFill').style.width = `${totalScore}%`;
        }

        // 更新单个徽章
        function updateBadge(badgeId, scoreId, score) {
            const badge = document.getElementById(badgeId);
            const scoreEl = document.getElementById(scoreId);
            
            scoreEl.textContent = score;
            
            // 移除所有样式类
            badge.classList.remove('excellent', 'good', 'needs-work');
            
            // 根据分数添加样式
            if (score >= 80) {
                badge.classList.add('excellent');
            } else if (score >= 60) {
                badge.classList.add('good');
            } else {
                badge.classList.add('needs-work');
            }
        }

        // 更新建议面板
        function updateTips(tips) {
            const container = document.getElementById('tipsContainer');
            container.innerHTML = '';
            
            tips.forEach(tip => {
                const tipEl = document.createElement('div');
                tipEl.className = 'tip-item';
                tipEl.textContent = tip;
                container.appendChild(tipEl);
            });
        }

        // 显示结果区域
        function showResults(dimScores, metrics) {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.classList.add('visible');
            
            // 更新标题
            const commandText = TRAINING_COMMANDS[getCurrentCommandId()].text;
            document.getElementById('resultsTitle').textContent = `${currentMode === 'film' ? '影视镜头' : '舞台表演'}模式 - ${commandText}`;
            
            // 更新幅度标签
            const amplitude = calculateAmplitude(metrics);
            const amplitudeLabel = document.getElementById('amplitudeLabel');
            
            if (amplitude < 0.3) {
                amplitudeLabel.textContent = 'Subtle';
                amplitudeLabel.className = 'amplitude-label amplitude-subtle';
            } else if (amplitude < 0.7) {
                amplitudeLabel.textContent = 'Medium';
                amplitudeLabel.className = 'amplitude-label amplitude-medium';
            } else {
                amplitudeLabel.textContent = 'Exaggerated';
                amplitudeLabel.className = 'amplitude-label amplitude-exaggerated';
            }
            
            // 绘制图表
            drawRadarChart(dimScores);
            drawBarChart(dimScores);
        }

        // 绘制雷达图
        function drawRadarChart(scores) {
            const canvas = document.getElementById('radarChart');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 40;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            
            for (let i = 1; i <= 5; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * i / 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // 绘制坐标轴和标签
            const labels = ['Clarity', 'Consistency', 'Intensity', 'Truth'];
            const values = [scores.clarity, scores.consistency, scores.intensity, scores.truth];
            
            ctx.font = '12px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 - Math.PI / 2;
                const x1 = centerX;
                const y1 = centerY;
                const x2 = centerX + Math.cos(angle) * radius;
                const y2 = centerY + Math.sin(angle) * radius;
                
                // 绘制轴线
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // 绘制标签
                const labelX = centerX + Math.cos(angle) * (radius + 20);
                const labelY = centerY + Math.sin(angle) * (radius + 20);
                ctx.fillText(labels[i], labelX, labelY);
            }
            
            // 绘制数据多边形
            ctx.strokeStyle = '#4ecdc4';
            ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 - Math.PI / 2;
                const value = values[i] / 100;
                const x = centerX + Math.cos(angle) * radius * value;
                const y = centerY + Math.sin(angle) * radius * value;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                // 绘制数据点
                ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.closePath();
            ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#4ecdc4';
            ctx.stroke();
        }

        // 绘制柱状图
        function drawBarChart(scores) {
            const canvas = document.getElementById('barChart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            const barWidth = (width - padding * 2) / 4 - 10;
            
            ctx.clearRect(0, 0, width, height);
            
            const labels = ['Clarity', 'Consistency', 'Intensity', 'Truth'];
            const values = [scores.clarity, scores.consistency, scores.intensity, scores.truth];
            const colors = ['#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            
            // 绘制柱状图
            for (let i = 0; i < 4; i++) {
                const x = padding + i * (barWidth + 10);
                const barHeight = (values[i] / 100) * (height - padding * 2);
                const y = height - padding - barHeight;
                
                // 绘制柱子
                ctx.fillStyle = colors[i];
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // 绘制数值
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(values[i], x + barWidth / 2, y - 5);
                
                // 绘制标签
                ctx.font = '10px Arial';
                ctx.fillText(labels[i], x + barWidth / 2, height - padding + 15);
            }
        }

        // Quick Calibrate - 快速校准
        async function quickCalibrate() {
            if (isCalibrating) return;
            
            isCalibrating = true;
            metricsBuffer = [];
            
            document.getElementById('calibrateBtn').disabled = true;
            document.getElementById('currentCommand').textContent = '保持中性表情进行校准...';
            
            // TTS提示
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance('请保持中性表情一秒钟进行个人校准');
                utterance.lang = 'zh-CN';
                speechSynthesis.speak(utterance);
            }
            
            // 1秒校准时间
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // 计算基线
            if (metricsBuffer.length > 0) {
                const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
                if (validMetrics.length > 0) {
                    baseline = calculateAverageMetrics(validMetrics);
                    document.getElementById('currentCommand').textContent = '✅ 个人校准完成！现在可以开始训练';
                    
                    // 更新建议
                    updateTips(['个人校准已完成，表情评分将基于你的面部基线进行，结果会更准确。']);
                } else {
                    document.getElementById('currentCommand').textContent = '❌ 校准失败，未检测到面部';
                }
            } else {
                document.getElementById('currentCommand').textContent = '❌ 校准失败，请确保面部清晰可见';
            }
            
            isCalibrating = false;
            document.getElementById('calibrateBtn').disabled = false;
        }

        // 下一个表情
        function nextExpression() {
            const select = document.getElementById('commandSelect');
            const options = Array.from(select.options);
            const currentIndex = options.findIndex(opt => opt.selected);
            const nextIndex = (currentIndex + 1) % options.length;
            
            select.selectedIndex = nextIndex;
            updateUI();
            
            // 隐藏结果区域
            document.getElementById('resultsSection').classList.remove('visible');
        }

        // 更新UI状态
        function updateUI() {
            const commandId = document.getElementById('commandSelect').value;
            const command = TRAINING_COMMANDS[commandId];
            
            if (command) {
                document.getElementById('currentCommand').textContent = `准备：${command.text}`;
            }
            
            // 更新模式显示
            const modeText = currentMode === 'film' ? '影视镜头模式' : '舞台表演模式';
            document.title = `表情训练教练 - ${modeText}`;
        }

        // 辅助函数
        function getCurrentCommandId() {
            return document.getElementById('commandSelect').value;
        }

        function getCurrentTarget() {
            const commandId = getCurrentCommandId();
            return TRAINING_COMMANDS[commandId] ? TRAINING_COMMANDS[commandId].target : 'neutral';
        }
    </script>
</body>
</html>