<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¡¨æƒ…è®­ç»ƒæ•™ç»ƒ - ä¸“ä¸šç‰ˆ</title>
    
    <!--
    æœ¬åœ°è¿è¡Œè¯´æ˜ï¼š
    1. æ‘„åƒå¤´éœ€è¦ HTTPS æˆ– localhost ç¯å¢ƒ
    2. ä½¿ç”¨ Python å¯åŠ¨æœ¬åœ°æœåŠ¡ï¼š
       python -m http.server 8000
       ç„¶åè®¿é—® http://localhost:8000
    3. æˆ–ä½¿ç”¨ Python 3:
       python3 -m http.server 8000
    4. æ‰€æœ‰å¤„ç†åœ¨æœ¬åœ°å®Œæˆï¼Œä¸ä¸Šä¼ ä»»ä½•å›¾åƒæˆ–è§†é¢‘æ•°æ®
    -->
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .app-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar main tips"
                "results results results";
            grid-template-rows: auto 1fr auto;
            grid-template-columns: 300px 1fr 350px;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }
        
        /* Header - Progress and Badges */
        .header {
            grid-area: header;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .progress-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .total-score {
            font-size: 24px;
            font-weight: bold;
            color: #4ecdc4;
            min-width: 80px;
        }
        
        .progress-bar {
            flex: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #45b7d1);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .badges {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .badge {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .badge.excellent { border-color: #4ecdc4; background: rgba(78, 205, 196, 0.2); }
        .badge.good { border-color: #45b7d1; background: rgba(69, 183, 209, 0.2); }
        .badge.needs-work { border-color: #ff6b6b; background: rgba(255, 107, 107, 0.2); }
        
        .badge-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .badge-name {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .badge-score {
            font-size: 18px;
            font-weight: bold;
        }
        
        .tech-indicators {
            display: flex;
            justify-content: space-around;
            font-size: 11px;
            opacity: 0.7;
        }
        
        .tech-item {
            text-align: center;
        }
        
        /* Sidebar - Controls */
        .sidebar {
            grid-area: sidebar;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #4ecdc4;
        }
        
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .mode-option {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 12px;
        }
        
        .mode-option.active {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.2);
        }
        
        select, button {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:focus, button:hover {
            border-color: #4ecdc4;
            outline: none;
        }
        
        button {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            margin-bottom: 10px;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }
        
        /* Main Video Area */
        .main-area {
            grid-area: main;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
        }
        
        .video-status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
        }
        
        .training-info {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .current-command {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 5px;
        }
        
        .countdown {
            font-size: 36px;
            font-weight: bold;
            color: #ff6b6b;
            margin: 10px 0;
        }
        
        /* Tips Panel */
        .tips-panel {
            grid-area: tips;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .tips-title {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tip-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.4;
            border-left: 4px solid #4ecdc4;
        }
        
        /* Results Section */
        .results {
            grid-area: results;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }
        
        .results.visible {
            display: block;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .results-title {
            font-size: 20px;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .amplitude-label {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .amplitude-subtle { color: #45b7d1; }
        .amplitude-medium { color: #4ecdc4; }
        .amplitude-exaggerated { color: #ff6b6b; }
        
        .charts-container {
            display: flex;
            gap: 20px;
        }
        
        .chart-section {
            flex: 1;
        }
        
        .chart-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        canvas.chart {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .app-container {
                grid-template-areas: 
                    "header"
                    "sidebar"
                    "main"
                    "tips"
                    "results";
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <div class="progress-section">
                <div class="total-score" id="totalScore">0</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="badges">
                <div class="badge" id="clarityBadge">
                    <div class="badge-icon">ğŸ¯</div>
                    <div class="badge-name">Clarity</div>
                    <div class="badge-score" id="clarityScore">0</div>
                </div>
                <div class="badge" id="consistencyBadge">
                    <div class="badge-icon">âš–ï¸</div>
                    <div class="badge-name">Consistency</div>
                    <div class="badge-score" id="consistencyScore">0</div>
                </div>
                <div class="badge" id="intensityBadge">
                    <div class="badge-icon">âš¡</div>
                    <div class="badge-name">Intensity</div>
                    <div class="badge-score" id="intensityScore">0</div>
                </div>
                <div class="badge" id="truthBadge">
                    <div class="badge-icon">ğŸ’«</div>
                    <div class="badge-name">Truth</div>
                    <div class="badge-score" id="truthScore">0</div>
                </div>
            </div>
            
            <div class="tech-indicators">
                <div class="tech-item">
                    <div>Match</div>
                    <div id="matchScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Symmetry</div>
                    <div id="symmetryScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Stability</div>
                    <div id="stabilityScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Aesthetics</div>
                    <div id="aestheticsScore">0</div>
                </div>
            </div>
        </div>
        
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="control-group">
                <label class="control-label">è¡¨æ¼”æ¨¡å¼</label>
                <div class="mode-selector">
                    <div class="mode-option active" data-mode="film">
                        <div>ğŸ¬</div>
                        <div>å½±è§†é•œå¤´</div>
                    </div>
                    <div class="mode-option" data-mode="stage">
                        <div>ğŸ­</div>
                        <div>èˆå°è¡¨æ¼”</div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label" for="commandSelect">è®­ç»ƒå£ä»¤</label>
                <select id="commandSelect">
                    <option value="smile_natural">è‡ªç„¶å¾®ç¬‘ï¼ˆ2ç§’ï¼‰</option>
                    <option value="smile_duchenne">å¸¦çœ¼ç¬‘/Duchenneï¼ˆ2ç§’ï¼‰</option>
                    <option value="neutral">ä¸­æ€§è„¸ï¼ˆ2ç§’ï¼‰</option>
                    <option value="focus">ä¸“æ³¨ï¼ˆ2ç§’ï¼‰</option>
                    <option value="surprised">æƒŠè®¶ï¼ˆ1.5ç§’ï¼‰</option>
                    <option value="sad">æ‚²ä¼¤ï¼ˆ2ç§’ï¼‰</option>
                    <option value="disgust">åŒæ¶ï¼ˆ2ç§’ï¼‰</option>
                    <option value="angry">æ„¤æ€’ï¼ˆ2ç§’ï¼‰</option>
                </select>
            </div>
            
            <div class="control-group">
                <button class="btn-primary" id="startBtn">Start Training</button>
                <button class="btn-secondary" id="nextBtn">Next Expression</button>
                <button class="btn-secondary" id="calibrateBtn">Quick Calibrate</button>
            </div>
        </div>
        
        <!-- Main Video Area -->
        <div class="main-area">
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="overlayCanvas"></canvas>
                <div class="video-status" id="videoStatus">ç­‰å¾…æ‘„åƒå¤´...</div>
            </div>
            
            <div class="training-info">
                <div class="current-command" id="currentCommand">é€‰æ‹©è®­ç»ƒå£ä»¤å¹¶ç‚¹å‡»å¼€å§‹</div>
                <div class="countdown" id="countdown"></div>
            </div>
        </div>
        
        <!-- Tips Panel -->
        <div class="tips-panel">
            <div class="tips-title">
                <span>ğŸ’¡</span>
                <span>è¡¨æ¼”å»ºè®®</span>
            </div>
            <div id="tipsContainer">
                <div class="tip-item">å‡†å¤‡å¼€å§‹è®­ç»ƒï¼Œé€‰æ‹©è¡¨æ¼”æ¨¡å¼å’Œç›®æ ‡è¡¨æƒ…</div>
            </div>
        </div>
        
        <!-- Results Section -->
        <div class="results" id="resultsSection">
            <div class="results-header">
                <div class="results-title" id="resultsTitle">è®­ç»ƒç»“æœ</div>
                <div class="amplitude-label" id="amplitudeLabel">Medium</div>
            </div>
            
            <div class="charts-container">
                <div class="chart-section">
                    <div class="chart-title">å››ç»´è¯„åˆ†</div>
                    <canvas id="radarChart" class="chart" width="300" height="200"></canvas>
                </div>
                <div class="chart-section">
                    <div class="chart-title">æŠ€æœ¯æŒ‡æ ‡</div>
                    <canvas id="barChart" class="chart" width="300" height="200"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // è®­ç»ƒå£ä»¤é…ç½®
        const TRAINING_COMMANDS = {
            smile_natural: {
                id: "smile_natural",
                text: "è¯·åšè‡ªç„¶å¾®ç¬‘å¹¶ä¿æŒä¸¤ç§’",
                tts: true,
                duration: 2000,
                target: "smile",
                duchenne: false,
                difficulty: "E"
            },
            smile_duchenne: {
                id: "smile_duchenne", 
                text: "è¯·åšå¸¦çœ¼ç¬‘ï¼ˆçœ¼è§’è½»å¾®çœ¯èµ·ï¼‰å¹¶ä¿æŒä¸¤ç§’",
                tts: true,
                duration: 2000,
                target: "smile",
                duchenne: true,
                difficulty: "M"
            },
            neutral: {
                id: "neutral",
                text: "è¯·ä¿æŒä¸­æ€§è„¸éƒ¨è¡¨æƒ…ä¸¤ç§’",
                tts: true,
                duration: 2000,
                target: "neutral",
                duchenne: false,
                difficulty: "E"
            },
            focus: {
                id: "focus",
                text: "è¯·åšä¸“æ³¨è¡¨æƒ…å¹¶ä¿æŒä¸¤ç§’",
                tts: true,
                duration: 2000,
                target: "focus",
                duchenne: false,
                difficulty: "M"
            },
            surprised: {
                id: "surprised",
                text: "è¯·åšæƒŠè®¶è¡¨æƒ…å¹¶ä¿æŒä¸€ç§’åŠ",
                tts: true,
                duration: 1500,
                target: "surprised",
                duchenne: false,
                difficulty: "M"
            },
            sad: {
                id: "sad",
                text: "è¯·åšæ‚²ä¼¤è¡¨æƒ…å¹¶ä¿æŒä¸¤ç§’",
                tts: true,
                duration: 2000,
                target: "sad",
                duchenne: false,
                difficulty: "H"
            },
            disgust: {
                id: "disgust",
                text: "è¯·åšåŒæ¶è¡¨æƒ…å¹¶ä¿æŒä¸¤ç§’",
                tts: true,
                duration: 2000,
                target: "disgust",
                duchenne: false,
                difficulty: "H"
            },
            angry: {
                id: "angry",
                text: "è¯·åšæ„¤æ€’è¡¨æƒ…å¹¶ä¿æŒä¸¤ç§’",
                tts: true,
                duration: 2000,
                target: "angry",
                duchenne: false,
                difficulty: "H"
            }
        };

        // MediaPipe landmarks ç´¢å¼• (åŸºäº468ç‚¹æ¨¡å‹)
        const LANDMARKS = {
            // å˜´éƒ¨å…³é”®ç‚¹
            MOUTH: {
                LEFT_CORNER: 61,    // å·¦å˜´è§’
                RIGHT_CORNER: 291,  // å³å˜´è§’
                TOP: 13,           // ä¸Šå”‡ä¸­å¿ƒ
                BOTTOM: 14,        // ä¸‹å”‡ä¸­å¿ƒ
                UPPER_LIP: [12, 15, 16, 17, 18, 200], // ä¸Šå”‡è½®å»“
                LOWER_LIP: [146, 91, 181, 84, 17, 314, 405, 320, 307, 375] // ä¸‹å”‡è½®å»“
            },
            // å·¦çœ¼å…³é”®ç‚¹
            LEFT_EYE: {
                TOP: 159,
                BOTTOM: 145,
                LEFT: 33,
                RIGHT: 133,
                OUTLINE: [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246]
            },
            // å³çœ¼å…³é”®ç‚¹
            RIGHT_EYE: {
                TOP: 386,
                BOTTOM: 374,
                LEFT: 362,
                RIGHT: 263,
                OUTLINE: [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398]
            },
            // çœ‰æ¯›å…³é”®ç‚¹
            LEFT_EYEBROW: {
                INNER: 55,   // å·¦çœ‰å†…ä¾§
                OUTER: 46,   // å·¦çœ‰å¤–ä¾§
                CENTER: 70   // å·¦çœ‰ä¸­å¿ƒ
            },
            RIGHT_EYEBROW: {
                INNER: 285,  // å³çœ‰å†…ä¾§
                OUTER: 276,  // å³çœ‰å¤–ä¾§
                CENTER: 300  // å³çœ‰ä¸­å¿ƒ
            },
            NOSE_TIP: 1,     // é¼»å°–
            FACE_OUTLINE: [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109]
        };

        // å…¨å±€å˜é‡
        let faceMesh;
        let camera;
        let currentMode = 'film';  // 'film' or 'stage'
        let isTraining = false;
        let isCalibrating = false;
        let baseline = null; // ä¸ªäººåŸºçº¿
        let currentSession = null;
        let metricsBuffer = [];
        let lastFrameTime = 0;
        let frameCount = 0;

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', async () => {
            await initializeCamera();
            setupEventListeners();
            updateUI();
        });

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // æ¨¡å¼åˆ‡æ¢
            document.querySelectorAll('.mode-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.mode-option').forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    currentMode = option.dataset.mode;
                    updateUI();
                });
            });

            // æŒ‰é’®äº‹ä»¶
            document.getElementById('startBtn').addEventListener('click', startTraining);
            document.getElementById('nextBtn').addEventListener('click', nextExpression);
            document.getElementById('calibrateBtn').addEventListener('click', quickCalibrate);

            // å£ä»¤é€‰æ‹©
            document.getElementById('commandSelect').addEventListener('change', updateUI);
        }

        // åˆå§‹åŒ–æ‘„åƒå¤´å’ŒMediaPipe
        async function initializeCamera() {
            try {
                // è·å–æ‘„åƒå¤´
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const videoElement = document.getElementById('videoElement');
                videoElement.srcObject = stream;
                
                videoElement.onloadedmetadata = () => {
                    const canvas = document.getElementById('overlayCanvas');
                    canvas.width = videoElement.videoWidth;
                    canvas.height = videoElement.videoHeight;
                };

                await initializeFaceMesh();
                document.getElementById('videoStatus').textContent = 'æ‘„åƒå¤´å°±ç»ª';
                
            } catch (error) {
                console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
                document.getElementById('videoStatus').textContent = 'æ‘„åƒå¤´è®¿é—®å¤±è´¥';
            }
        }

        async function initializeFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onResults);

            camera = new Camera(document.getElementById('videoElement'), {
                onFrame: async () => {
                    await faceMesh.send({image: document.getElementById('videoElement')});
                },
                width: 640,
                height: 480
            });

            camera.start();
        }

        // MediaPipeç»“æœå¤„ç†
        function onResults(results) {
            const now = performance.now();
            
            // è®¡ç®—FPS
            frameCount++;
            if (now - lastFrameTime >= 1000) {
                lastFrameTime = now;
                frameCount = 0;
            }

            const canvas = document.getElementById('overlayCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // ç»˜åˆ¶è½®å»“
                drawOverlay(ctx, landmarks);
                
                // æå–ç‰¹å¾
                const metrics = extractMetrics(landmarks);
                
                // æ”¶é›†è®­ç»ƒæ•°æ®
                if ((isTraining || isCalibrating) && metrics) {
                    metricsBuffer.push({
                        timestamp: now,
                        metrics: metrics
                    });
                }
                
                document.getElementById('videoStatus').textContent = 'é¢éƒ¨æ£€æµ‹æ­£å¸¸';
            } else {
                document.getElementById('videoStatus').textContent = 'æœªæ£€æµ‹åˆ°é¢éƒ¨';
            }
        }

        // ç»˜åˆ¶é¢éƒ¨è½®å»“ - ç®€åŒ–ç‰ˆæœ¬ï¼Œä¸»è¦æ˜¾ç¤ºå˜´éƒ¨å’Œçœ¼éƒ¨
        function drawOverlay(ctx, landmarks) {
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;

            // ç»˜åˆ¶å˜´éƒ¨è½®å»“
            drawLandmarkContour(ctx, LANDMARKS.MOUTH.UPPER_LIP, landmarks, '#4ecdc4');
            drawLandmarkContour(ctx, LANDMARKS.MOUTH.LOWER_LIP, landmarks, '#4ecdc4');

            // ç»˜åˆ¶çœ¼éƒ¨è½®å»“
            drawLandmarkContour(ctx, LANDMARKS.LEFT_EYE.OUTLINE, landmarks, '#45b7d1');
            drawLandmarkContour(ctx, LANDMARKS.RIGHT_EYE.OUTLINE, landmarks, '#45b7d1');
        }

        function drawLandmarkContour(ctx, indices, landmarks, color) {
            if (!indices || !landmarks) return;
            
            ctx.strokeStyle = color;
            ctx.beginPath();
            
            let started = false;
            indices.forEach(idx => {
                if (landmarks[idx]) {
                    const point = landmarks[idx];
                    const x = point.x * ctx.canvas.width;
                    const y = point.y * ctx.canvas.height;
                    
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            });
            
            ctx.closePath();
            ctx.stroke();
        }

        /**
         * ç‰¹å¾æå–å‡½æ•°
         * åŸºäºMediaPipe 468ç‚¹æ¨¡å‹æå–å…³é”®è¡¨æƒ…ç‰¹å¾
         */
        function extractMetrics(landmarks) {
            if (!landmarks || landmarks.length < 468) return null;

            try {
                // å˜´éƒ¨ç‰¹å¾ç‚¹
                const mouth = {
                    leftCorner: landmarks[LANDMARKS.MOUTH.LEFT_CORNER],
                    rightCorner: landmarks[LANDMARKS.MOUTH.RIGHT_CORNER], 
                    top: landmarks[LANDMARKS.MOUTH.TOP],
                    bottom: landmarks[LANDMARKS.MOUTH.BOTTOM]
                };

                // çœ¼éƒ¨ç‰¹å¾ç‚¹
                const eyes = {
                    leftTop: landmarks[LANDMARKS.LEFT_EYE.TOP],
                    leftBottom: landmarks[LANDMARKS.LEFT_EYE.BOTTOM],
                    leftLeft: landmarks[LANDMARKS.LEFT_EYE.LEFT],
                    leftRight: landmarks[LANDMARKS.LEFT_EYE.RIGHT],
                    rightTop: landmarks[LANDMARKS.RIGHT_EYE.TOP],
                    rightBottom: landmarks[LANDMARKS.RIGHT_EYE.BOTTOM],
                    rightLeft: landmarks[LANDMARKS.RIGHT_EYE.LEFT],
                    rightRight: landmarks[LANDMARKS.RIGHT_EYE.RIGHT]
                };

                // çœ‰æ¯›ç‰¹å¾ç‚¹
                const brows = {
                    leftInner: landmarks[LANDMARKS.LEFT_EYEBROW.INNER],
                    leftOuter: landmarks[LANDMARKS.LEFT_EYEBROW.OUTER],
                    leftCenter: landmarks[LANDMARKS.LEFT_EYEBROW.CENTER],
                    rightInner: landmarks[LANDMARKS.RIGHT_EYEBROW.INNER],
                    rightOuter: landmarks[LANDMARKS.RIGHT_EYEBROW.OUTER],
                    rightCenter: landmarks[LANDMARKS.RIGHT_EYEBROW.CENTER]
                };

                const distance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                // 1. mouthRatio = mouthWidth / mouthHeight (å¾®ç¬‘æ—¶å¢å¤§)
                const mouthWidth = distance(mouth.leftCorner, mouth.rightCorner);
                const mouthHeight = distance(mouth.top, mouth.bottom);
                const mouthRatio = mouthWidth / (mouthHeight + 0.001);

                // 2. mouthOpen = mouthHeight / mouthWidth (æƒŠè®¶/å¼ å£æ—¶å¢å¤§)
                const mouthOpen = mouthHeight / (mouthWidth + 0.001);

                // 3. eyeEAR = Eye Aspect Ratio å¹³å‡å€¼ (Duchenneç¬‘æ—¶å‡å°)
                const leftEAR = distance(eyes.leftTop, eyes.leftBottom) / distance(eyes.leftLeft, eyes.leftRight);
                const rightEAR = distance(eyes.rightTop, eyes.rightBottom) / distance(eyes.rightLeft, eyes.rightRight);
                const eyeEAR = (leftEAR + rightEAR) / 2;

                // 4. browActivity - çœ‰æ¯›æ´»åŠ¨åº¦ (åŸºäºçœ‰å¿ƒ/çœ‰å°¾å‚ç›´ä½ç§»)
                const leftBrowHeight = Math.abs(brows.leftCenter.y - eyes.leftTop.y);
                const rightBrowHeight = Math.abs(brows.rightCenter.y - eyes.rightTop.y);
                const browActivity = (leftBrowHeight + rightBrowHeight) / 2;

                // 5. symMouth - å˜´éƒ¨å¯¹ç§°æ€§ (0-1, åŸºäºå·¦å³å˜´è§’yåæ ‡å·®)
                const symMouth = 1 - Math.min(1, Math.abs(mouth.leftCorner.y - mouth.rightCorner.y) * 1000);

                // 6. poseYawProxy - ç®€åŒ–åèˆªä»£ç† (åŸºäºé¼»å°–ç›¸å¯¹é¢éƒ¨ä¸­å¿ƒçš„æ°´å¹³åç§»)
                const noseTip = landmarks[LANDMARKS.NOSE_TIP];
                const poseYawProxy = 1 - Math.min(1, Math.abs(noseTip.x - 0.5) * 2);

                // 7. illumScore - äº®åº¦å‡åŒ€åº¦ç²—è¯„ (ç®€åŒ–ç‰ˆæœ¬ï¼ŒåŸºäºé¢éƒ¨åŒºåŸŸ)
                const illumScore = 0.8; // ç®€åŒ–å®ç°ï¼Œå®é™…åº”åŸºäºåƒç´ äº®åº¦åˆ†æ

                return {
                    mouthRatio,
                    mouthOpen,
                    eyeEAR,
                    browActivity,
                    symMouth,
                    poseYawProxy,
                    illumScore,
                    // é¢å¤–çš„è¾…åŠ©æ•°æ®
                    mouthWidth,
                    mouthHeight,
                    leftEAR,
                    rightEAR
                };

            } catch (error) {
                console.error('ç‰¹å¾æå–å¤±è´¥:', error);
                return null;
            }
        }

        /**
         * æŠ€æœ¯å±‚è¯„åˆ†å‡½æ•°
         * è¾“å…¥: ç‰¹å¾æ•°æ®, æ¨¡å¼, ç›®æ ‡è¡¨æƒ…, ä¸ªäººåŸºçº¿
         * è¾“å‡º: Match/Symmetry/Stability/Aesthetics å››ä¸ªæŠ€æœ¯æŒ‡æ ‡ (0-100)
         */
        function scoreFromMetrics(metrics, mode, target, baseline) {
            if (!metrics) return { match: 0, symmetry: 0, stability: 0, aesthetics: 0 };

            // 1. Match åŒ¹é…åº¦ - åŸºäºç›®æ ‡è¡¨æƒ…çš„ç‰¹å¾åŒ¹é…
            let match = calculateMatchScore(metrics, target, baseline);

            // 2. Symmetry å¯¹ç§°æ€§ - ç›´æ¥æ˜ å°„symMouth
            const symmetry = Math.round(metrics.symMouth * 100);

            // 3. Stability ç¨³å®šæ€§ - åŸºäº2ç§’çª—å£å†…çš„æ–¹å·® (ç®€åŒ–å®ç°)
            const stability = calculateStability();

            // 4. Aesthetics ç¾è§‚åº¦ - åŸºäºå§¿æ€å’Œå…‰ç…§
            const aesthetics = Math.round((metrics.poseYawProxy * 0.6 + metrics.illumScore * 0.4) * 100);

            // æœ€ç»ˆæŠ€æœ¯åˆ†åˆæˆ
            const finalTechScore = Math.round(
                0.5 * match + 
                0.2 * symmetry + 
                0.2 * stability + 
                0.1 * aesthetics
            );

            return {
                match: Math.max(0, Math.min(100, match)),
                symmetry: Math.max(0, Math.min(100, symmetry)),
                stability: Math.max(0, Math.min(100, stability)),
                aesthetics: Math.max(0, Math.min(100, aesthetics)),
                final: Math.max(0, Math.min(100, finalTechScore))
            };
        }

        // è®¡ç®—åŒ¹é…åº¦åˆ†æ•°
        function calculateMatchScore(metrics, target, baseline) {
            let score = 50; // åŸºç¡€åˆ†

            if (!baseline) {
                // æ— åŸºçº¿æ—¶çš„ç»å¯¹è¯„åˆ†
                switch (target) {
                    case 'smile':
                        // å¾®ç¬‘: å˜´è§’ä¸Šæ‰¬ (mouthRatioå¢å¤§)
                        score = Math.min(100, (metrics.mouthRatio - 2.0) * 40 + 60);
                        break;
                    case 'surprised':
                        // æƒŠè®¶: å¼ å£ + çœ¼è£‚å¢å¤§
                        score = Math.min(100, metrics.mouthOpen * 80 + 30);
                        break;
                    case 'sad':
                        // æ‚²ä¼¤: çœ‰å†…æ”¶ + å˜´è§’ä¸‹å‚
                        score = Math.max(30, 70 - metrics.mouthRatio * 10);
                        break;
                    case 'angry':
                        // æ„¤æ€’: çœ‰å‹ä½ + ç›®å…‰é›†ä¸­
                        score = 60 + (1 - metrics.browActivity) * 30;
                        break;
                    case 'disgust':
                        // åŒæ¶: ä¸Šå”‡æŠ¬èµ·
                        score = 50 + metrics.mouthOpen * 30;
                        break;
                    case 'neutral':
                        // ä¸­æ€§: å„æŒ‡æ ‡æ¥è¿‘å¹³å‡å€¼
                        score = 80 - Math.abs(metrics.mouthRatio - 2.5) * 20;
                        break;
                    case 'focus':
                        // ä¸“æ³¨: è½»å¾®çœ¯çœ¼
                        score = 70 + (0.3 - metrics.eyeEAR) * 100;
                        break;
                }
            } else {
                // åŸºäºä¸ªäººåŸºçº¿çš„ç›¸å¯¹è¯„åˆ†
                const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
                const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR; // æ³¨æ„æ–¹å‘
                const dMouthOpen = metrics.mouthOpen - baseline.mouthOpen;
                const dBrowActivity = metrics.browActivity - baseline.browActivity;

                switch (target) {
                    case 'smile':
                        score = 60 + dMouthRatio * 50;
                        // Duchenneç¬‘æ£€æµ‹
                        if (TRAINING_COMMANDS[getCurrentCommandId()].duchenne && dEyeEAR > 0.02) {
                            score += 20; // çœ¼éƒ¨å‚ä¸çš„åŠ åˆ†
                        }
                        break;
                    case 'surprised':
                        score = 60 + dMouthOpen * 100 + dEyeEAR * 50;
                        break;
                    case 'sad':
                        score = 60 + dBrowActivity * 40 - dMouthRatio * 30;
                        break;
                    case 'angry':
                        score = 60 - dBrowActivity * 50 + Math.min(0, -dEyeEAR * 30);
                        break;
                    case 'disgust':
                        score = 60 + dMouthOpen * 80;
                        break;
                    case 'neutral':
                        // ä¸­æ€§è„¸ï¼šå„é¡¹å˜åŒ–éƒ½åº”è¯¥å¾ˆå°
                        const totalChange = Math.abs(dMouthRatio) + Math.abs(dEyeEAR) + Math.abs(dMouthOpen);
                        score = 80 - totalChange * 200;
                        break;
                    case 'focus':
                        score = 60 + dEyeEAR * 100; // è½»å¾®çœ¯çœ¼
                        break;
                }
            }

            return Math.max(10, Math.min(100, Math.round(score)));
        }

        // è®¡ç®—ç¨³å®šæ€§ (ç®€åŒ–å®ç°)
        function calculateStability() {
            if (metricsBuffer.length < 10) return 70; // é»˜è®¤å€¼
            
            // è®¡ç®—æœ€è¿‘10å¸§çš„å˜´éƒ¨ç‰¹å¾æ–¹å·®
            const recent = metricsBuffer.slice(-10).map(item => item.metrics.mouthRatio);
            const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
            const variance = recent.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / recent.length;
            
            // æ–¹å·®è¶Šå°ï¼Œç¨³å®šæ€§è¶Šé«˜
            return Math.max(0, Math.min(100, Math.round(100 - variance * 1000)));
        }

        /**
         * è¡¨æ¼”å­¦ç§‘å››ç»´æ˜ å°„
         * å°†æŠ€æœ¯æŒ‡æ ‡æ˜ å°„ä¸ºè¡¨æ¼”ä¸“ä¸šçš„å››ä¸ªç»´åº¦
         */
        function mapToActingDimensions(techScores, metrics, mode) {
            const isFilm = mode === 'film';
            const isStage = mode === 'stage';

            // 1. Clarity æ¸…æ™°åº¦ - è¡¨æƒ…æ˜¯å¦æ¸…æ™°å¯è¯»
            let clarity = techScores.match * 0.7 + techScores.aesthetics * 0.3;
            
            // èˆå°æ¨¡å¼éœ€è¦æ›´å¤§çš„å¹…åº¦æ‰èƒ½è·å¾—é«˜æ¸…æ™°åº¦åˆ†
            if (isStage) {
                const amplitude = calculateAmplitude(metrics);
                if (amplitude < 0.3) clarity *= 0.7; // å¹…åº¦ä¸è¶³æ‰£åˆ†
            }

            // 2. Consistency ä¸€è‡´æ€§ - é¢éƒ¨å„éƒ¨åˆ†æ˜¯å¦åè°ƒ
            let consistency = techScores.stability * 0.8;
            
            // çœ¼å˜´åè°ƒæ€§æ£€æµ‹ (ç®€åŒ–ç‰ˆ)
            const eyeMouthConsistency = calculateEyeMouthConsistency(metrics);
            consistency += eyeMouthConsistency * 0.2;

            // 3. Intensity å¼ºåº¦ - è¡¨æƒ…å¹…åº¦æ˜¯å¦é€‚åˆæ¨¡å¼
            const amplitude = calculateAmplitude(metrics);
            let intensity = amplitude * 100;
            
            // æ ¹æ®æ¨¡å¼è°ƒæ•´å¼ºåº¦è¯„åˆ†
            if (isStage) {
                // èˆå°æ¨¡å¼åå¥½æ›´é«˜å¼ºåº¦
                intensity *= 1.2;
            } else if (isFilm) {
                // å½±è§†æ¨¡å¼å¯¹è¿‡åº¦å¼ºåº¦æ‰£åˆ†
                if (amplitude > 0.8) intensity *= 0.7;
            }

            // 4. Truth çœŸå®æ€§ - æ£€æµ‹å‡è¡¨æƒ…
            let truth = calculateTruthScore(metrics, getCurrentTarget());

            return {
                clarity: Math.max(0, Math.min(100, Math.round(clarity))),
                consistency: Math.max(0, Math.min(100, Math.round(consistency))),
                intensity: Math.max(0, Math.min(100, Math.round(intensity))),
                truth: Math.max(0, Math.min(100, Math.round(truth)))
            };
        }

        // è®¡ç®—è¡¨æƒ…å¹…åº¦
        function calculateAmplitude(metrics) {
            if (!baseline) return 0.5; // æ— åŸºçº¿æ—¶è¿”å›ä¸­ç­‰å¹…åº¦
            
            const dMouthRatio = Math.abs(metrics.mouthRatio - baseline.mouthRatio);
            const dEyeEAR = Math.abs(metrics.eyeEAR - baseline.eyeEAR);
            const dMouthOpen = Math.abs(metrics.mouthOpen - baseline.mouthOpen);
            
            // ç»¼åˆå„é¡¹ç‰¹å¾çš„å˜åŒ–å¹…åº¦
            return Math.min(1, (dMouthRatio + dEyeEAR * 2 + dMouthOpen) / 3);
        }

        // è®¡ç®—çœ¼å˜´åè°ƒæ€§
        function calculateEyeMouthConsistency(metrics) {
            if (!baseline) return 50;
            
            const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
            const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR; // æ³¨æ„æ–¹å‘
            
            // å¾®ç¬‘æ—¶ï¼Œå˜´è§’ä¸Šæ‰¬åº”è¯¥ä¼´éšçœ¼éƒ¨å˜åŒ–
            if (dMouthRatio > 0.1) { // æ˜æ˜¾çš„å˜´è§’ä¸Šæ‰¬
                return dEyeEAR > 0.01 ? 80 : 40; // æœ‰çœ¼éƒ¨å‚ä¸å¾—é«˜åˆ†
            }
            
            return 60; // é»˜è®¤ä¸­ç­‰åè°ƒæ€§
        }

        // è®¡ç®—çœŸå®æ€§åˆ†æ•°
        function calculateTruthScore(metrics, target) {
            if (!baseline) return 70; // æ— åŸºçº¿æ—¶çš„é»˜è®¤å€¼
            
            const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
            const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR;
            
            let truth = 75; // åŸºç¡€çœŸå®æ€§åˆ†æ•°
            
            switch (target) {
                case 'smile':
                    // æ£€æµ‹å‡ç¬‘: å˜´è§’ä¸Šæ‰¬ä½†çœ¼éƒ¨æ— å˜åŒ–
                    if (dMouthRatio > 0.1 && dEyeEAR < 0.005) {
                        truth -= 30; // ä¸¥é‡å‡ç¬‘
                    } else if (dMouthRatio > 0.05 && dEyeEAR < 0.01) {
                        truth -= 15; // è½»å¾®å‡ç¬‘
                    }
                    break;
                    
                case 'sad':
                    // æ‚²ä¼¤æ—¶çœ‰çœ¼å˜´çš„æ–¹å‘åº”è¯¥ä¸€è‡´
                    const browDown = metrics.browActivity < baseline.browActivity;
                    const mouthDown = dMouthRatio < -0.02;
                    if (browDown !== mouthDown) {
                        truth -= 20; // è¡¨æƒ…ä¸ä¸€è‡´
                    }
                    break;
                    
                case 'surprised':
                    // æƒŠè®¶æ—¶çœ‰æ¯›ä¸Šæ‰¬å’Œå¼ å˜´åº”è¯¥åŒæ—¶å‘ç”Ÿ
                    const browUp = metrics.browActivity > baseline.browActivity;
                    const mouthOpen = metrics.mouthOpen > baseline.mouthOpen + 0.05;
                    if (browUp !== mouthOpen) {
                        truth -= 15;
                    }
                    break;
            }
            
            return Math.max(30, Math.min(100, truth));
        }

        /**
         * è¡¨æ¼”è¯­è¨€åé¦ˆç”Ÿæˆ
         * åŸºäºè¯„åˆ†ç»“æœç”Ÿæˆè‡ªç„¶çš„ä¸­æ–‡è¡¨æ¼”å»ºè®®
         */
        function generateActingTips(dimScores, metrics, target, mode) {
            const tips = [];
            const isFilm = mode === 'film';
            const isStage = mode === 'stage';
            const amplitude = calculateAmplitude(metrics);
            
            // Clarity æ¸…æ™°åº¦åé¦ˆ
            if (dimScores.clarity < 60) {
                if (isStage) {
                    tips.push("å¹…åº¦ä¸è¶³ï¼Œè§‚ä¼—å¸­ç¬¬åæ’çœ‹ä¸æ¸…ã€‚åŠ å¤§å˜´è§’å¤–å±•æˆ–çœ‰éƒ¨åŠ¨ä½œ15%ã€‚");
                } else {
                    tips.push("è¡¨æƒ…ä¸å¤Ÿæ¸…æ™°ï¼Œè¯•ç€è®©é¢éƒ¨åŠ¨ä½œæ›´åŠ æ˜ç¡®ï¼Œä½†ä¿æŒè‡ªç„¶ã€‚");
                }
            }
            
            // Intensity å¼ºåº¦åé¦ˆ
            if (dimScores.intensity > 85 && isFilm) {
                tips.push("å¹…åº¦åå¤¸å¼ ï¼Œé è¿‘é•œå¤´ä¼šæ˜¾å¾—ç”¨åŠ›ã€‚æ”¶20%ä¿æŒçœŸå®æ„Ÿã€‚");
            } else if (dimScores.intensity < 50 && isStage) {
                tips.push("èˆå°è¡¨æ¼”éœ€è¦æ›´å¤§å¹…åº¦ï¼Œè§‚ä¼—éœ€è¦ä»è¿œå¤„çœ‹æ¸…ä½ çš„è¡¨æƒ…ã€‚");
            }
            
            // Truth çœŸå®æ€§åé¦ˆ
            if (dimScores.truth < 60) {
                switch (target) {
                    case 'smile':
                        tips.push("ç¬‘åœåœ¨å˜´è§’ï¼Œçœ¼ç¥æ²¡æœ‰åˆ°ä½ã€‚è½»çœ¯çœ¼10%ï¼ŒæŠŠæ³¨æ„åŠ›æ”¾åœ¨'æƒ³ç¬‘çš„ç†ç”±'ä¸Šã€‚");
                        break;
                    case 'sad':
                        tips.push("æ‚²ä¼¤è¡¨æƒ…éœ€è¦çœ‰çœ¼å˜´çš„ç»Ÿä¸€ã€‚å…ˆä»å†…å¿ƒæ„Ÿå—å¼€å§‹ï¼Œè®©è¡¨æƒ…è‡ªç„¶æµéœ²ã€‚");
                        break;
                    case 'angry':
                        tips.push("æ„¤æ€’ä¸åªæ˜¯çœ‰æ¯›ï¼Œçœ¼ç¥çš„ä¸“æ³¨å’Œå˜´éƒ¨çš„ç´§ç»·åŒæ ·é‡è¦ã€‚");
                        break;
                }
            }
            
            // Consistency ä¸€è‡´æ€§åé¦ˆ
            if (dimScores.consistency < 60) {
                tips.push("ä¸ŠåŠè„¸ä¸ä¸‹åŠè„¸ä¸ç»Ÿä¸€ã€‚å…ˆå®šä½çœ¼ç¥ï¼Œå†ç¼“æ…¢å¸¦åŠ¨å˜´è§’ï¼Œé¿å…å†²çªã€‚");
            }
            
            // å…‰ç…§å’Œå§¿æ€åé¦ˆ
            if (metrics.illumScore < 0.6) {
                tips.push("å…‰æºä¸åœ¨æ­£å‰ä¸Šæ–¹ï¼Œè¡¨æƒ…é˜´å½±å½±å“å¯è¯»æ€§ï¼Œè°ƒæ•´åˆ°30-45Â°è§’åº¦ã€‚");
            }
            
            if (metrics.poseYawProxy < 0.7) {
                tips.push("ä¿æŒæ­£é¢æœå‘æ‘„åƒå¤´ï¼Œé¿å…ä¾§è„¸å½±å“è¡¨æƒ…è¯†åˆ«ã€‚");
            }
            
            // ç‰¹å®šè¡¨æƒ…çš„ä¸“é¡¹å»ºè®®
            addSpecificTips(tips, target, metrics, dimScores);
            
            // å¦‚æœæ²¡æœ‰é—®é¢˜ï¼Œç»™äºˆé¼“åŠ±
            if (tips.length === 0) {
                const avgScore = (dimScores.clarity + dimScores.consistency + dimScores.intensity + dimScores.truth) / 4;
                if (avgScore > 80) {
                    tips.push("å‡ºè‰²çš„è¡¨ç°ï¼è¡¨æƒ…è‡ªç„¶çœŸå®ï¼Œç¬¦åˆ" + (isFilm ? "å½±è§†é•œå¤´" : "èˆå°è¡¨æ¼”") + "çš„è¦æ±‚ã€‚");
                } else {
                    tips.push("æ•´ä½“ä¸é”™ï¼Œç»§ç»­ä¿æŒè¿™ç§çŠ¶æ€ï¼Œå¤šç»ƒä¹ ä¼šæ›´åŠ è‡ªç„¶ã€‚");
                }
            }
            
            return tips.slice(0, 4); // é™åˆ¶ä¸ºæœ€å¤š4æ¡å»ºè®®
        }

        // æ·»åŠ ç‰¹å®šè¡¨æƒ…çš„ä¸“é¡¹å»ºè®®
        function addSpecificTips(tips, target, metrics, dimScores) {
            switch (target) {
                case 'smile':
                    if (TRAINING_COMMANDS[getCurrentCommandId()].duchenne) {
                        if (dimScores.truth < 70) {
                            tips.push("Duchenneç¬‘éœ€è¦çœ¼éƒ¨å‚ä¸ï¼Œæƒ³è±¡çœŸæ­£å¼€å¿ƒçš„äº‹æƒ…ï¼Œè®©çœ¼è§’è‡ªç„¶å¼¯æ›²ã€‚");
                        }
                    }
                    break;
                    
                case 'surprised':
                    if (metrics.mouthOpen < (baseline ? baseline.mouthOpen + 0.05 : 0.1)) {
                        tips.push("æƒŠè®¶è¡¨æƒ…éœ€è¦æ”¾ä¸‹é¢Œï¼Œæ‹‰å¼€ä¸Šä¸‹å”‡è·ç¦»ï¼Œå°±åƒçœŸçš„è¢«ä»€ä¹ˆéœ‡æƒŠäº†ã€‚");
                    }
                    break;
                    
                case 'sad':
                    if (dimScores.intensity < 50) {
                        tips.push("æ‚²ä¼¤ä¸åªæ˜¯å˜´è§’ä¸‹å‚ï¼Œçœ‰å¿ƒè½»çš±ã€çœ¼ç¥å¤±ç„¦ä¼šæ›´æœ‰è¯´æœåŠ›ã€‚");
                    }
                    break;
                    
                case 'angry':
                    if (dimScores.clarity < 60) {
                        tips.push("æ„¤æ€’è¡¨æƒ…çš„æ ¸å¿ƒåœ¨çœ¼ç¥ï¼Œå‹ä½çœ‰æ¯›çš„åŒæ—¶ä¿æŒç›®å…‰é›†ä¸­ã€‚");
                    }
                    break;
            }
        }

        // å¼€å§‹è®­ç»ƒ
        async function startTraining() {
            if (isTraining) return;
            
            const commandId = document.getElementById('commandSelect').value;
            const command = TRAINING_COMMANDS[commandId];
            
            if (!command) return;
            
            isTraining = true;
            metricsBuffer = [];
            
            // æ›´æ–°UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('currentCommand').textContent = command.text;
            
            // TTSæ’­æŠ¥
            if (command.tts && 'speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(command.text);
                utterance.lang = 'zh-CN';
                speechSynthesis.speak(utterance);
            }
            
            // å€’è®¡æ—¶
            await countdown(3);
            
            // å¼€å§‹è®°å½•
            currentSession = {
                mode: currentMode,
                command: command,
                startTime: performance.now()
            };
            
            // è®­ç»ƒè®¡æ—¶
            setTimeout(() => {
                finishTraining();
            }, command.duration);
            
            // æ˜¾ç¤ºå€’è®¡æ—¶
            showTrainingCountdown(command.duration);
        }

        // å€’è®¡æ—¶æ˜¾ç¤º
        async function countdown(seconds) {
            const countdownEl = document.getElementById('countdown');
            
            for (let i = seconds; i > 0; i--) {
                countdownEl.textContent = i;
                countdownEl.style.color = '#ff6b6b';
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            countdownEl.textContent = 'å¼€å§‹ï¼';
            countdownEl.style.color = '#4ecdc4';
            await new Promise(resolve => setTimeout(resolve, 500));
            countdownEl.textContent = '';
        }

        // æ˜¾ç¤ºè®­ç»ƒå€’è®¡æ—¶
        function showTrainingCountdown(duration) {
            const countdownEl = document.getElementById('countdown');
            const startTime = Date.now();
            
            const updateCountdown = () => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, duration - elapsed);
                const seconds = (remaining / 1000).toFixed(1);
                
                countdownEl.textContent = `${seconds}s`;
                countdownEl.style.color = '#4ecdc4';
                
                if (remaining > 0) {
                    requestAnimationFrame(updateCountdown);
                } else {
                    countdownEl.textContent = '';
                }
            };
            
            requestAnimationFrame(updateCountdown);
        }

        // å®Œæˆè®­ç»ƒ
        function finishTraining() {
            isTraining = false;
            currentSession.endTime = performance.now();
            
            // åˆ†æç»“æœ
            if (metricsBuffer.length > 0) {
                analyzeSession();
            }
            
            document.getElementById('startBtn').disabled = false;
        }

        // åˆ†æè®­ç»ƒä¼šè¯
        function analyzeSession() {
            // è®¡ç®—å¹³å‡ç‰¹å¾
            const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
            if (validMetrics.length === 0) return;
            
            const avgMetrics = calculateAverageMetrics(validMetrics);
            
            // æŠ€æœ¯å±‚è¯„åˆ†
            const techScores = scoreFromMetrics(avgMetrics, currentMode, getCurrentTarget(), baseline);
            
            // è¡¨æ¼”ç»´åº¦æ˜ å°„
            const dimScores = mapToActingDimensions(techScores, avgMetrics, currentMode);
            
            // ç”Ÿæˆåé¦ˆ
            const tips = generateActingTips(dimScores, avgMetrics, getCurrentTarget(), currentMode);
            
            // æ›´æ–°UI
            updateScoreDisplay(techScores, dimScores);
            updateTips(tips);
            showResults(dimScores, avgMetrics);
        }

        // è®¡ç®—å¹³å‡ç‰¹å¾
        function calculateAverageMetrics(metrics) {
            const avg = {};
            const keys = Object.keys(metrics[0]);
            
            keys.forEach(key => {
                avg[key] = metrics.reduce((sum, m) => sum + m[key], 0) / metrics.length;
            });
            
            return avg;
        }

        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        function updateScoreDisplay(techScores, dimScores) {
            // æ›´æ–°å¾½ç« 
            updateBadge('clarityBadge', 'clarityScore', dimScores.clarity);
            updateBadge('consistencyBadge', 'consistencyScore', dimScores.consistency);
            updateBadge('intensityBadge', 'intensityScore', dimScores.intensity);
            updateBadge('truthBadge', 'truthScore', dimScores.truth);
            
            // æ›´æ–°æŠ€æœ¯æŒ‡æ ‡
            document.getElementById('matchScore').textContent = techScores.match;
            document.getElementById('symmetryScore').textContent = techScores.symmetry;
            document.getElementById('stabilityScore').textContent = techScores.stability;
            document.getElementById('aestheticsScore').textContent = techScores.aesthetics;
            
            // æ›´æ–°æ€»åˆ†å’Œè¿›åº¦æ¡
            const totalScore = Math.round((dimScores.clarity + dimScores.consistency + dimScores.intensity + dimScores.truth) / 4);
            document.getElementById('totalScore').textContent = totalScore;
            document.getElementById('progressFill').style.width = `${totalScore}%`;
        }

        // æ›´æ–°å•ä¸ªå¾½ç« 
        function updateBadge(badgeId, scoreId, score) {
            const badge = document.getElementById(badgeId);
            const scoreEl = document.getElementById(scoreId);
            
            scoreEl.textContent = score;
            
            // ç§»é™¤æ‰€æœ‰æ ·å¼ç±»
            badge.classList.remove('excellent', 'good', 'needs-work');
            
            // æ ¹æ®åˆ†æ•°æ·»åŠ æ ·å¼
            if (score >= 80) {
                badge.classList.add('excellent');
            } else if (score >= 60) {
                badge.classList.add('good');
            } else {
                badge.classList.add('needs-work');
            }
        }

        // æ›´æ–°å»ºè®®é¢æ¿
        function updateTips(tips) {
            const container = document.getElementById('tipsContainer');
            container.innerHTML = '';
            
            tips.forEach(tip => {
                const tipEl = document.createElement('div');
                tipEl.className = 'tip-item';
                tipEl.textContent = tip;
                container.appendChild(tipEl);
            });
        }

        // æ˜¾ç¤ºç»“æœåŒºåŸŸ
        function showResults(dimScores, metrics) {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.classList.add('visible');
            
            // æ›´æ–°æ ‡é¢˜
            const commandText = TRAINING_COMMANDS[getCurrentCommandId()].text;
            document.getElementById('resultsTitle').textContent = `${currentMode === 'film' ? 'å½±è§†é•œå¤´' : 'èˆå°è¡¨æ¼”'}æ¨¡å¼ - ${commandText}`;
            
            // æ›´æ–°å¹…åº¦æ ‡ç­¾
            const amplitude = calculateAmplitude(metrics);
            const amplitudeLabel = document.getElementById('amplitudeLabel');
            
            if (amplitude < 0.3) {
                amplitudeLabel.textContent = 'Subtle';
                amplitudeLabel.className = 'amplitude-label amplitude-subtle';
            } else if (amplitude < 0.7) {
                amplitudeLabel.textContent = 'Medium';
                amplitudeLabel.className = 'amplitude-label amplitude-medium';
            } else {
                amplitudeLabel.textContent = 'Exaggerated';
                amplitudeLabel.className = 'amplitude-label amplitude-exaggerated';
            }
            
            // ç»˜åˆ¶å›¾è¡¨
            drawRadarChart(dimScores);
            drawBarChart(dimScores);
        }

        // ç»˜åˆ¶é›·è¾¾å›¾
        function drawRadarChart(scores) {
            const canvas = document.getElementById('radarChart');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 40;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            
            for (let i = 1; i <= 5; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * i / 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶åæ ‡è½´å’Œæ ‡ç­¾
            const labels = ['Clarity', 'Consistency', 'Intensity', 'Truth'];
            const values = [scores.clarity, scores.consistency, scores.intensity, scores.truth];
            
            ctx.font = '12px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 - Math.PI / 2;
                const x1 = centerX;
                const y1 = centerY;
                const x2 = centerX + Math.cos(angle) * radius;
                const y2 = centerY + Math.sin(angle) * radius;
                
                // ç»˜åˆ¶è½´çº¿
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // ç»˜åˆ¶æ ‡ç­¾
                const labelX = centerX + Math.cos(angle) * (radius + 20);
                const labelY = centerY + Math.sin(angle) * (radius + 20);
                ctx.fillText(labels[i], labelX, labelY);
            }
            
            // ç»˜åˆ¶æ•°æ®å¤šè¾¹å½¢
            ctx.strokeStyle = '#4ecdc4';
            ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 - Math.PI / 2;
                const value = values[i] / 100;
                const x = centerX + Math.cos(angle) * radius * value;
                const y = centerY + Math.sin(angle) * radius * value;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                // ç»˜åˆ¶æ•°æ®ç‚¹
                ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.closePath();
            ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#4ecdc4';
            ctx.stroke();
        }

        // ç»˜åˆ¶æŸ±çŠ¶å›¾
        function drawBarChart(scores) {
            const canvas = document.getElementById('barChart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            const barWidth = (width - padding * 2) / 4 - 10;
            
            ctx.clearRect(0, 0, width, height);
            
            const labels = ['Clarity', 'Consistency', 'Intensity', 'Truth'];
            const values = [scores.clarity, scores.consistency, scores.intensity, scores.truth];
            const colors = ['#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            
            // ç»˜åˆ¶æŸ±çŠ¶å›¾
            for (let i = 0; i < 4; i++) {
                const x = padding + i * (barWidth + 10);
                const barHeight = (values[i] / 100) * (height - padding * 2);
                const y = height - padding - barHeight;
                
                // ç»˜åˆ¶æŸ±å­
                ctx.fillStyle = colors[i];
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // ç»˜åˆ¶æ•°å€¼
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(values[i], x + barWidth / 2, y - 5);
                
                // ç»˜åˆ¶æ ‡ç­¾
                ctx.font = '10px Arial';
                ctx.fillText(labels[i], x + barWidth / 2, height - padding + 15);
            }
        }

        // Quick Calibrate - å¿«é€Ÿæ ¡å‡†
        async function quickCalibrate() {
            if (isCalibrating) return;
            
            isCalibrating = true;
            metricsBuffer = [];
            
            document.getElementById('calibrateBtn').disabled = true;
            document.getElementById('currentCommand').textContent = 'ä¿æŒä¸­æ€§è¡¨æƒ…è¿›è¡Œæ ¡å‡†...';
            
            // TTSæç¤º
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance('è¯·ä¿æŒä¸­æ€§è¡¨æƒ…ä¸€ç§’é’Ÿè¿›è¡Œä¸ªäººæ ¡å‡†');
                utterance.lang = 'zh-CN';
                speechSynthesis.speak(utterance);
            }
            
            // 1ç§’æ ¡å‡†æ—¶é—´
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // è®¡ç®—åŸºçº¿
            if (metricsBuffer.length > 0) {
                const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
                if (validMetrics.length > 0) {
                    baseline = calculateAverageMetrics(validMetrics);
                    document.getElementById('currentCommand').textContent = 'âœ… ä¸ªäººæ ¡å‡†å®Œæˆï¼ç°åœ¨å¯ä»¥å¼€å§‹è®­ç»ƒ';
                    
                    // æ›´æ–°å»ºè®®
                    updateTips(['ä¸ªäººæ ¡å‡†å·²å®Œæˆï¼Œè¡¨æƒ…è¯„åˆ†å°†åŸºäºä½ çš„é¢éƒ¨åŸºçº¿è¿›è¡Œï¼Œç»“æœä¼šæ›´å‡†ç¡®ã€‚']);
                } else {
                    document.getElementById('currentCommand').textContent = 'âŒ æ ¡å‡†å¤±è´¥ï¼Œæœªæ£€æµ‹åˆ°é¢éƒ¨';
                }
            } else {
                document.getElementById('currentCommand').textContent = 'âŒ æ ¡å‡†å¤±è´¥ï¼Œè¯·ç¡®ä¿é¢éƒ¨æ¸…æ™°å¯è§';
            }
            
            isCalibrating = false;
            document.getElementById('calibrateBtn').disabled = false;
        }

        // ä¸‹ä¸€ä¸ªè¡¨æƒ…
        function nextExpression() {
            const select = document.getElementById('commandSelect');
            const options = Array.from(select.options);
            const currentIndex = options.findIndex(opt => opt.selected);
            const nextIndex = (currentIndex + 1) % options.length;
            
            select.selectedIndex = nextIndex;
            updateUI();
            
            // éšè—ç»“æœåŒºåŸŸ
            document.getElementById('resultsSection').classList.remove('visible');
        }

        // æ›´æ–°UIçŠ¶æ€
        function updateUI() {
            const commandId = document.getElementById('commandSelect').value;
            const command = TRAINING_COMMANDS[commandId];
            
            if (command) {
                document.getElementById('currentCommand').textContent = `å‡†å¤‡ï¼š${command.text}`;
            }
            
            // æ›´æ–°æ¨¡å¼æ˜¾ç¤º
            const modeText = currentMode === 'film' ? 'å½±è§†é•œå¤´æ¨¡å¼' : 'èˆå°è¡¨æ¼”æ¨¡å¼';
            document.title = `è¡¨æƒ…è®­ç»ƒæ•™ç»ƒ - ${modeText}`;
        }

        // è¾…åŠ©å‡½æ•°
        function getCurrentCommandId() {
            return document.getElementById('commandSelect').value;
        }

        function getCurrentTarget() {
            const commandId = getCurrentCommandId();
            return TRAINING_COMMANDS[commandId] ? TRAINING_COMMANDS[commandId].target : 'neutral';
        }
    </script>
</body>
</html>