<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº¬å‰§æ—¦è§’è¡¨æƒ…è®­ç»ƒç³»ç»Ÿ - ç‰å ‚æ˜¥é£æ ¼</title>
    
    <!--
    æœ¬åœ°è¿è¡Œè¯´æ˜ï¼š
    1. æ‘„åƒå¤´éœ€è¦ HTTPS æˆ– localhost ç¯å¢ƒ
    2. ä½¿ç”¨ Python å¯åŠ¨æœ¬åœ°æœåŠ¡ï¼š
       python -m http.server 8000
       ç„¶åè®¿é—® http://localhost:8000
    3. æˆ–ä½¿ç”¨ Python 3:
       python3 -m http.server 8000
    4. æ‰€æœ‰å¤„ç†åœ¨æœ¬åœ°å®Œæˆï¼Œä¸ä¸Šä¼ ä»»ä½•å›¾åƒæˆ–è§†é¢‘æ•°æ®
    5. å»ºè®®ä½¿ç”¨è¾ƒå¼ºå…‰æºï¼Œä¾¿äºæ•æ‰çœ¼éƒ¨ç»†å¾®åŠ¨ä½œ
    -->
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'STKaiti', 'æ¥·ä½“', serif;
            background: linear-gradient(135deg, 
                #8B0000 0%,    /* æ·±çº¢ */
                #B22222 25%,   /* ç«ç –çº¢ */ 
                #CD5C5C 50%,   /* å°åº¦çº¢ */
                #F0E68C 75%,   /* å¡å…¶è‰² */
                #FFD700 100%   /* é‡‘è‰² */
            );
            color: #2F1B14;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* ä¼ ç»Ÿçº¹æ ·èƒŒæ™¯ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(255, 215, 0, 0.1) 0%, transparent 70%),
                radial-gradient(circle at 80% 20%, rgba(220, 20, 60, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: -1;
        }
        
        .app-container {
            display: grid;
            grid-template-areas: 
                "header header header header"
                "sidebar main guide tips"
                "results results results results";
            grid-template-rows: auto 1fr auto;
            grid-template-columns: 300px 1fr 280px 320px;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }
        
        /* ä¼ ç»Ÿé£æ ¼å¡ç‰‡ */
        .card {
            background: linear-gradient(145deg, 
                rgba(255, 248, 220, 0.95) 0%,
                rgba(255, 245, 238, 0.9) 100%);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            border: 3px solid;
            border-image: linear-gradient(45deg, #DAA520, #B8860B, #CD853F) 1;
            box-shadow: 
                0 8px 32px rgba(139, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
            position: relative;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            bottom: 10px;
            border: 1px solid rgba(218, 165, 32, 0.3);
            border-radius: 10px;
            pointer-events: none;
        }
        
        /* Header - æˆæ›²è¯„åˆ†é¢æ¿ */
        .header {
            grid-area: header;
            padding: 25px;
        }
        
        .title-section {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .main-title {
            font-size: 28px;
            font-weight: bold;
            color: #8B0000;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 16px;
            color: #B8860B;
            font-style: italic;
        }
        
        .opera-scores {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .opera-badge {
            text-align: center;
            padding: 15px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.3), rgba(240, 230, 140, 0.2));
            border-radius: 12px;
            border: 2px solid transparent;
            transition: all 0.4s ease;
            position: relative;
        }
        
        .opera-badge.excellent {
            border-color: #FFD700;
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.3), rgba(255, 245, 238, 0.4));
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        .opera-badge.good {
            border-color: #B8860B;
            background: linear-gradient(145deg, rgba(184, 134, 11, 0.2), rgba(255, 245, 238, 0.3));
        }
        
        .opera-badge.needs-work {
            border-color: #CD853F;
            background: linear-gradient(145deg, rgba(205, 133, 63, 0.2), rgba(255, 245, 238, 0.3));
        }
        
        .badge-name {
            font-size: 14px;
            font-weight: bold;
            color: #8B0000;
            margin-bottom: 8px;
        }
        
        .badge-chinese {
            font-size: 12px;
            color: #B8860B;
            margin-bottom: 5px;
        }
        
        .badge-score {
            font-size: 24px;
            font-weight: bold;
            color: #2F1B14;
        }
        
        .total-progress {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .total-score {
            font-size: 32px;
            font-weight: bold;
            color: #8B0000;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .progress-bar {
            flex: 1;
            max-width: 400px;
            height: 15px;
            background: rgba(139, 0, 0, 0.2);
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #B8860B;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #DAA520, #B8860B);
            width: 0%;
            transition: width 0.8s ease;
        }
        
        /* Sidebar - è®­ç»ƒæ§åˆ¶ */
        .sidebar {
            grid-area: sidebar;
            padding: 25px;
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 12px;
            font-weight: bold;
            color: #8B0000;
            font-size: 16px;
        }
        
        .role-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .role-option {
            padding: 12px;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.4), rgba(240, 230, 140, 0.2));
            border: 2px solid rgba(184, 134, 11, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 13px;
            font-weight: bold;
        }
        
        .role-option.active {
            border-color: #FFD700;
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.4), rgba(255, 245, 238, 0.5));
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }
        
        select, button {
            width: 100%;
            padding: 12px;
            border: 2px solid #B8860B;
            background: linear-gradient(145deg, rgba(255, 255, 255, 0.8), rgba(240, 230, 140, 0.3));
            color: #2F1B14;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }
        
        select:focus, button:hover {
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            outline: none;
        }
        
        .btn-primary {
            background: linear-gradient(145deg, #FFD700, #DAA520);
            border-color: #B8860B;
            color: #2F1B14;
            margin-bottom: 12px;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.3);
        }
        
        .btn-secondary {
            background: linear-gradient(145deg, rgba(184, 134, 11, 0.8), rgba(205, 133, 63, 0.6));
            color: #FFF8DC;
            margin-bottom: 12px;
        }
        
        /* Main Video Area */
        .main-area {
            grid-area: main;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
            border: 3px solid #B8860B;
        }
        
        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
        }
        
        .video-status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(139, 0, 0, 0.9);
            color: #FFD700;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .training-info {
            text-align: center;
            padding: 20px;
            background: linear-gradient(145deg, rgba(139, 0, 0, 0.1), rgba(184, 134, 11, 0.1));
            border-radius: 10px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .current-command {
            font-size: 18px;
            font-weight: bold;
            color: #8B0000;
            margin-bottom: 8px;
        }
        
        .opera-instruction {
            font-size: 14px;
            color: #B8860B;
            margin-bottom: 10px;
            font-style: italic;
        }
        
        .countdown {
            font-size: 42px;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin: 10px 0;
        }
        
        /* Expression Guide Panel - è¡¨æƒ…ç¤ºèŒƒ */
        .guide-panel {
            grid-area: guide;
            padding: 20px;
        }
        
        .guide-title {
            font-size: 18px;
            font-weight: bold;
            color: #8B0000;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
            text-align: center;
        }
        
        .expression-demo-container {
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.1), rgba(139, 0, 0, 0.05));
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            text-align: center;
        }
        
        .demo-image-frame {
            width: 200px;
            height: 200px;
            margin: 0 auto 15px;
            border: 3px solid #B8860B;
            border-radius: 15px;
            overflow: hidden;
            background: linear-gradient(145deg, rgba(255, 245, 238, 0.3), rgba(240, 230, 140, 0.2));
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .demo-canvas {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            cursor: pointer;
        }
        
        .demo-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #B8860B;
            font-size: 48px;
            background: linear-gradient(45deg, rgba(255, 215, 0, 0.1), rgba(184, 134, 11, 0.1));
        }
        
        .demo-placeholder-text {
            font-size: 12px;
            margin-top: 8px;
            color: #8B0000;
        }
        
        .expression-name {
            font-size: 16px;
            font-weight: bold;
            color: #8B0000;
            margin-bottom: 8px;
        }
        
        .expression-description {
            font-size: 13px;
            color: #B8860B;
            line-height: 1.4;
            font-style: italic;
        }
        
        /* Tips Panel - æˆæ›²æŒ‡å¯¼ */
        .tips-panel {
            grid-area: tips;
            padding: 20px;
        }
        
        .tips-title {
            font-size: 18px;
            font-weight: bold;
            color: #8B0000;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tip-item {
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.1), rgba(240, 230, 140, 0.2));
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 12px;
            font-size: 14px;
            line-height: 1.5;
            border-left: 4px solid #FFD700;
            border-top: 1px solid rgba(184, 134, 11, 0.3);
        }
        
        /* Results Section */
        .results {
            grid-area: results;
            padding: 20px;
            display: none;
        }
        
        .results.visible {
            display: block;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .results-title {
            font-size: 20px;
            font-weight: bold;
            color: #8B0000;
        }
        
        .expression-level {
            padding: 10px 20px;
            background: linear-gradient(145deg, rgba(255, 215, 0, 0.3), rgba(184, 134, 11, 0.2));
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid #B8860B;
        }
        
        .charts-container {
            display: flex;
            gap: 20px;
        }
        
        .chart-section {
            flex: 1;
        }
        
        .chart-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
            color: #8B0000;
        }
        
        canvas.chart {
            background: linear-gradient(145deg, rgba(0, 0, 0, 0.1), rgba(139, 0, 0, 0.05));
            border-radius: 10px;
            border: 2px solid rgba(184, 134, 11, 0.3);
        }
        
        /* Responsive */
        @media (max-width: 1400px) {
            .app-container {
                grid-template-areas: 
                    "header header"
                    "sidebar main"
                    "guide tips"
                    "results results";
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto 1fr auto auto;
            }
        }
        
        @media (max-width: 1000px) {
            .app-container {
                grid-template-areas: 
                    "header"
                    "sidebar"
                    "main"
                    "guide"
                    "tips"
                    "results";
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="card header">
            <div class="title-section">
                <h1 class="main-title">äº¬å‰§æ—¦è§’è¡¨æƒ…è®­ç»ƒ</h1>
                <p class="subtitle">ç‰å ‚æ˜¥é£æ ¼ Â· ä¼ ç»Ÿæˆæ›²è¡¨æ¼”è‰ºæœ¯</p>
            </div>
            
            <div class="opera-scores">
                <div class="opera-badge" id="eyeBadge">
                    <div class="badge-name">çœ¼ç¥</div>
                    <div class="badge-chinese">Eye Expression</div>
                    <div class="badge-score" id="eyeScore">0</div>
                </div>
                <div class="opera-badge" id="postureBadge">
                    <div class="badge-name">èº«æ®µ</div>
                    <div class="badge-chinese">Body Posture</div>
                    <div class="badge-score" id="postureScore">0</div>
                </div>
                <div class="opera-badge" id="charmBadge">
                    <div class="badge-name">éŸµå‘³</div>
                    <div class="badge-chinese">Opera Charm</div>
                    <div class="badge-score" id="charmScore">0</div>
                </div>
                <div class="opera-badge" id="spiritBadge">
                    <div class="badge-name">ç¥éŸµ</div>
                    <div class="badge-chinese">Spirit Grace</div>
                    <div class="badge-score" id="spiritScore">0</div>
                </div>
            </div>
            
            <div class="total-progress">
                <div class="total-score" id="totalScore">0</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
        </div>
        
        <!-- Sidebar -->
        <div class="card sidebar">
            <div class="control-group">
                <label class="control-label">è§’è‰²è¡Œå½“</label>
                <div class="role-selector">
                    <div class="role-option active" data-role="dan">
                        <div>ğŸ­</div>
                        <div>æ—¦è§’</div>
                    </div>
                    <div class="role-option" data-role="qingyi">
                        <div>ğŸ‘¸</div>
                        <div>é’è¡£</div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label" for="operaCommandSelect">æˆæ›²è¡¨æƒ…</label>
                <select id="operaCommandSelect">
                    <option value="shy_glance">å¨‡ç¾æ–œè§†ï¼ˆ3ç§’ï¼‰</option>
                    <option value="sorrowful_gaze">å“€æ€¨å‡ç¥ï¼ˆ3ç§’ï¼‰</option>
                    <option value="startled_eyes">æƒŠæçªç›®ï¼ˆ2ç§’ï¼‰</option>
                    <option value="joyful_flutter">æ¬£å–œæµçœ„ï¼ˆ3ç§’ï¼‰</option>
                    <option value="angry_stare">å—”æ€’ç›´è§†ï¼ˆ2.5ç§’ï¼‰</option>
                    <option value="thinking_pose">æ²‰æ€å‚çœ¸ï¼ˆ3ç§’ï¼‰</option>
                    <option value="elegant_smile">é›…è‡´å«ç¬‘ï¼ˆ3ç§’ï¼‰</option>
                    <option value="distant_gaze">è¿œæœ›å‡çœ¸ï¼ˆ3ç§’ï¼‰</option>
                </select>
            </div>
            
            <div class="control-group">
                <button class="btn-primary" id="startBtn">å¼€å§‹ç»ƒä¹ </button>
                <button class="btn-secondary" id="nextBtn">ä¸‹ä¸€ä¸ªè¡¨æƒ…</button>
                <button class="btn-secondary" id="calibrateBtn">ä¸ªäººæ ¡å‡†</button>
            </div>
        </div>
        
        <!-- Main Video Area -->
        <div class="card main-area">
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="overlayCanvas"></canvas>
                <div class="video-status" id="videoStatus">ç­‰å¾…æ‘„åƒå¤´åˆå§‹åŒ–...</div>
            </div>
            
            <div class="training-info">
                <div class="current-command" id="currentCommand">é€‰æ‹©æˆæ›²è¡¨æƒ…å¹¶ç‚¹å‡»å¼€å§‹ç»ƒä¹ </div>
                <div class="opera-instruction" id="operaInstruction">ä½“éªŒä¼ ç»Ÿäº¬å‰§æ—¦è§’è¡¨æ¼”è‰ºæœ¯</div>
                <div class="countdown" id="countdown"></div>
            </div>
        </div>
        
        <!-- Expression Guide Panel -->
        <div class="card guide-panel">
            <div class="guide-title">
                <span>ğŸ–¼ï¸</span>
                <span>è¡¨æƒ…ç¤ºèŒƒ</span>
            </div>
            
            <div class="expression-demo-container" id="expressionDemo">
                <div class="demo-image-frame" id="demoImageFrame">
                    <div class="demo-placeholder" id="demoPlaceholder">
                        <div>ğŸ­</div>
                        <div class="demo-placeholder-text">é€‰æ‹©è¡¨æƒ…æŸ¥çœ‹ç¤ºèŒƒ</div>
                    </div>
                </div>
                
                <div class="expression-name" id="demoExpressionName">äº¬å‰§æ—¦è§’è¡¨æƒƒ</div>
                <div class="expression-description" id="demoExpressionDesc">é€‰æ‹©ä¸Šæ–¹è¡¨æƒ…ç±»å‹ï¼ŒæŸ¥çœ‹ä¼ ç»Ÿæˆæ›²è¡¨æƒ…ç¤ºèŒƒ</div>
            </div>
        </div>
        
        <!-- Tips Panel -->
        <div class="card tips-panel">
            <div class="tips-title">
                <span>ğŸ­</span>
                <span>æˆæ›²æŒ‡å¯¼</span>
            </div>
            <div id="tipsContainer">
                <div class="tip-item">å‡†å¤‡å¼€å§‹æˆæ›²è¡¨æƒ…è®­ç»ƒï¼Œæ„Ÿå—ä¼ ç»Ÿæ—¦è§’çš„ä¼˜é›…ä¸éŸµå‘³</div>
            </div>
        </div>
        
        <!-- Results Section -->
        <div class="card results" id="resultsSection">
            <div class="results-header">
                <div class="results-title" id="resultsTitle">è®­ç»ƒç»“æœ</div>
                <div class="expression-level" id="expressionLevel">ç¨‹å¼æ ‡å‡†</div>
            </div>
            
            <div class="charts-container">
                <div class="chart-section">
                    <div class="chart-title">æˆæ›²å››éŸµ</div>
                    <canvas id="operaRadarChart" class="chart" width="300" height="200"></canvas>
                </div>
                <div class="chart-section">
                    <div class="chart-title">çœ¼ç¥æŠ€æ³•</div>
                    <canvas id="eyeChart" class="chart" width="300" height="200"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // äº¬å‰§è¡¨æƒ…AIç”Ÿæˆç¤ºèŒƒé…ç½®
        const OPERA_EXPRESSION_GUIDES = {
            shy_glance: {
                description: "å¨‡ç¾æ–œè§†ï¼šçœ¼ç¥è½»æŸ”å«è“„ï¼Œç•¥å¸¦ç¾æ¶©åœ°åå‘ä¸€ä¾§",
                drawFunction: drawShyGlanceGuide,
                colors: ['#FFB6C1', '#FF69B4', '#8B0000'],
                eyeStyle: 'sidelong',
                mouthCurve: 'slight_smile'
            },
            sorrowful_gaze: {
                description: "å“€æ€¨å‡ç¥ï¼šå‡ç¥è¿œæœ›ï¼Œçœ¼ä¸­å«æœ‰æ·¡æ·¡æ„ç»ª",
                drawFunction: drawSorrowfulGazeGuide,
                colors: ['#B0C4DE', '#4169E1', '#191970'],
                eyeStyle: 'deep_gaze',
                mouthCurve: 'slight_frown'
            },
            startled_eyes: {
                description: "æƒŠæçªç›®ï¼šåŒçœ¼åœ†çï¼Œçªç„¶å¼ å¤§ï¼Œè¡¨ç°æƒŠéª‡ç¥æ€",
                drawFunction: drawStartledEyesGuide,
                colors: ['#FFFF00', '#FF6347', '#8B0000'],
                eyeStyle: 'wide_open',
                mouthCurve: 'open'
            },
            joyful_flutter: {
                description: "æ¬£å–œæµçœ„ï¼šçœ¼ç¥çµæ´»æµè½¬ï¼Œçœ¼ä¸­æœ‰ç¥é‡‡",
                drawFunction: drawJoyfulFlutterGuide,
                colors: ['#FFD700', '#FFA500', '#8B0000'],
                eyeStyle: 'sparkling',
                mouthCurve: 'wide_smile'
            },
            angry_stare: {
                description: "å—”æ€’ç›´è§†ï¼šæ€’ç›®ç›´è§†ï¼Œå¨ä¸¥å‡›ç„¶",
                drawFunction: drawAngryStareGuide,
                colors: ['#DC143C', '#B22222', '#8B0000'],
                eyeStyle: 'intense_stare',
                mouthCurve: 'stern'
            },
            thinking_pose: {
                description: "æ²‰æ€å‚çœ¸ï¼šå‚çœ¸æ²‰æ€ï¼Œç¥æ€å®‰ç¥¥",
                drawFunction: drawThinkingPoseGuide,
                colors: ['#DDA0DD', '#9370DB', '#4B0082'],
                eyeStyle: 'downward',
                mouthCurve: 'neutral'
            },
            elegant_smile: {
                description: "é›…è‡´å«ç¬‘ï¼šæµ…ç¬‘å«æ˜¥ï¼Œé›…è‡´ç«¯åº„",
                drawFunction: drawElegantSmileGuide,
                colors: ['#F0E68C', '#DAA520', '#B8860B'],
                eyeStyle: 'gentle',
                mouthCurve: 'elegant_smile'
            },
            distant_gaze: {
                description: "è¿œæœ›å‡çœ¸ï¼šå‡çœ¸è¿œæœ›ï¼Œæ€ç»ªæ‚ è¿œ",
                drawFunction: drawDistantGazeGuide,
                colors: ['#87CEEB', '#4682B4', '#2F4F4F'],
                eyeStyle: 'distant',
                mouthCurve: 'contemplative'
            }
        };

        // AIç”Ÿæˆäº¬å‰§è¡¨æƒ…ç¤ºèŒƒç»˜åˆ¶å‡½æ•°
        function drawOperaFaceBase(ctx, width, height, colors) {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, width, height);
            
            // åˆ›å»ºæ¸å˜èƒŒæ™¯
            const bgGradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width/2);
            bgGradient.addColorStop(0, 'rgba(255, 248, 220, 0.9)');
            bgGradient.addColorStop(1, 'rgba(139, 0, 0, 0.1)');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);
            
            const centerX = width / 2;
            const centerY = height / 2;
            
            // ç»˜åˆ¶è„¸éƒ¨è½®å»“
            ctx.fillStyle = colors[0];
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, width * 0.35, height * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // è„¸éƒ¨é˜´å½±
            ctx.fillStyle = 'rgba(139, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.ellipse(centerX + width * 0.02, centerY + height * 0.02, width * 0.35, height * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            return { centerX, centerY };
        }

        function drawShyGlanceGuide(canvas) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const guide = OPERA_EXPRESSION_GUIDES.shy_glance;
            const { centerX, centerY } = drawOperaFaceBase(ctx, width, height, guide.colors);
            
            // å¨‡ç¾æ–œè§† - çœ¼ç¥å«è“„ï¼Œç•¥å‘ä¾§è§†
            
            // çœ‰æ¯› - ç•¥å¾®ä¸Šæ‰¬
            ctx.strokeStyle = guide.colors[2];
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.15, centerY - height * 0.1);
            ctx.quadraticCurveTo(centerX - width * 0.05, centerY - height * 0.12, centerX + width * 0.05, centerY - height * 0.1);
            ctx.moveTo(centerX - width * 0.05, centerY - height * 0.1);
            ctx.quadraticCurveTo(centerX + width * 0.05, centerY - height * 0.12, centerX + width * 0.15, centerY - height * 0.1);
            ctx.stroke();
            
            // çœ¼ç› - æ–œè§†ï¼Œå·¦å³ä¸å¯¹ç§°
            ctx.fillStyle = guide.colors[2];
            // å·¦çœ¼ (ä»è§‚å¯Ÿè€…è§’åº¦)
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.05, width * 0.025, height * 0.015, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // å³çœ¼ - æ›´å°ï¼Œè¡¨ç°æ–œè§†
            ctx.beginPath();
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.05, width * 0.02, height * 0.012, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // è…®çº¢ - è¡¨ç°ç¾æ¶©
            ctx.fillStyle = guide.colors[1] + '40';
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.12, centerY + height * 0.05, width * 0.04, height * 0.025, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.12, centerY + height * 0.05, width * 0.04, height * 0.025, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å”‡ - å¾®ç¬‘ä½†å«è“„
            ctx.strokeStyle = guide.colors[1];
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY + height * 0.12, width * 0.03, 0.1, Math.PI - 0.1);
            ctx.stroke();
        }

        function drawSorrowfulGazeGuide(canvas) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const guide = OPERA_EXPRESSION_GUIDES.sorrowful_gaze;
            const { centerX, centerY } = drawOperaFaceBase(ctx, width, height, guide.colors);
            
            // å“€æ€¨å‡ç¥ - çœ¼ç¥æ·±è¿œï¼Œç•¥å¸¦å¿§æ„
            
            // çœ‰æ¯› - ç•¥å¾®çš±èµ·
            ctx.strokeStyle = guide.colors[2];
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.15, centerY - height * 0.08);
            ctx.quadraticCurveTo(centerX - width * 0.05, centerY - height * 0.11, centerX + width * 0.05, centerY - height * 0.08);
            ctx.moveTo(centerX - width * 0.05, centerY - height * 0.08);
            ctx.quadraticCurveTo(centerX + width * 0.05, centerY - height * 0.11, centerX + width * 0.15, centerY - height * 0.08);
            ctx.stroke();
            
            // çœ¼ç› - æ·±é‚ƒï¼Œç•¥å¸¦æ°´æ±ªæ±ªçš„æ„Ÿè§‰
            ctx.fillStyle = guide.colors[2];
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.05, width * 0.03, height * 0.02, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.05, width * 0.03, height * 0.02, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ä¸­çš„"æ°´å…‰"
            ctx.fillStyle = guide.colors[0];
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.075, centerY - height * 0.055, width * 0.008, height * 0.005, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.085, centerY - height * 0.055, width * 0.008, height * 0.005, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å‹ - ç•¥å¾®ä¸‹æ’‡
            ctx.strokeStyle = guide.colors[1];
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY + height * 0.15, width * 0.03, Math.PI + 0.3, 2 * Math.PI - 0.3);
            ctx.stroke();
        }

        function drawStartledEyesGuide(canvas) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const guide = OPERA_EXPRESSION_GUIDES.startled_eyes;
            const { centerX, centerY } = drawOperaFaceBase(ctx, width, height, guide.colors);
            
            // æƒŠæçªç›® - åŒçœ¼åœ†ç
            
            // çœ‰æ¯› - é«˜é«˜æ‰¬èµ·
            ctx.strokeStyle = guide.colors[2];
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.15, centerY - height * 0.15);
            ctx.quadraticCurveTo(centerX - width * 0.05, centerY - height * 0.18, centerX + width * 0.05, centerY - height * 0.15);
            ctx.moveTo(centerX - width * 0.05, centerY - height * 0.15);
            ctx.quadraticCurveTo(centerX + width * 0.05, centerY - height * 0.18, centerX + width * 0.15, centerY - height * 0.15);
            ctx.stroke();
            
            // çœ¼ç› - éå¸¸å¤§ï¼Œåœ†ç
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.05, width * 0.04, height * 0.035, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.05, width * 0.04, height * 0.035, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ç³å­” - å¤§è€Œé»‘
            ctx.fillStyle = guide.colors[2];
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.05, width * 0.025, height * 0.025, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.05, width * 0.025, height * 0.025, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å‹ - å¼ å¼€è¡¨ç¤ºæƒŠè®¶
            ctx.fillStyle = guide.colors[2];
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + height * 0.12, width * 0.02, height * 0.03, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawJoyfulFlutterGuide(canvas) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const guide = OPERA_EXPRESSION_GUIDES.joyful_flutter;
            const { centerX, centerY } = drawOperaFaceBase(ctx, width, height, guide.colors);
            
            // æ¬£å–œæµçœ„ - çœ¼ç¥çµæ´»ï¼Œæœ‰ç¥é‡‡
            
            // çœ‰æ¯› - è‡ªç„¶ä¸Šæ‰¬
            ctx.strokeStyle = guide.colors[2];
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.15, centerY - height * 0.1);
            ctx.quadraticCurveTo(centerX - width * 0.05, centerY - height * 0.13, centerX + width * 0.05, centerY - height * 0.1);
            ctx.moveTo(centerX - width * 0.05, centerY - height * 0.1);
            ctx.quadraticCurveTo(centerX + width * 0.05, centerY - height * 0.13, centerX + width * 0.15, centerY - height * 0.1);
            ctx.stroke();
            
            // çœ¼ç› - æ˜äº®æœ‰ç¥
            ctx.fillStyle = guide.colors[2];
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.05, width * 0.03, height * 0.018, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.05, width * 0.03, height * 0.018, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ä¸­å…‰èŠ’ - å¤šä¸ªäº®ç‚¹è¡¨ç°ç¥é‡‡
            ctx.fillStyle = guide.colors[0];
            ctx.beginPath();
            ctx.arc(centerX - width * 0.075, centerY - height * 0.055, width * 0.005, 0, Math.PI * 2);
            ctx.arc(centerX - width * 0.085, centerY - height * 0.045, width * 0.003, 0, Math.PI * 2);
            ctx.arc(centerX + width * 0.075, centerY - height * 0.055, width * 0.005, 0, Math.PI * 2);
            ctx.arc(centerX + width * 0.085, centerY - height * 0.045, width * 0.003, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å”‡ - æ„‰æ‚¦çš„ç¬‘å®¹
            ctx.strokeStyle = guide.colors[1];
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY + height * 0.1, width * 0.05, 0.2, Math.PI - 0.2);
            ctx.stroke();
        }

        function drawAngryStareGuide(canvas) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const guide = OPERA_EXPRESSION_GUIDES.angry_stare;
            const { centerX, centerY } = drawOperaFaceBase(ctx, width, height, guide.colors);
            
            // å—”æ€’ç›´è§† - å¨ä¸¥å‡›ç„¶
            
            // çœ‰æ¯› - ä¸¥é‡çš±èµ·ï¼Œå‘ˆå€’Vå½¢
            ctx.strokeStyle = guide.colors[2];
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.15, centerY - height * 0.08);
            ctx.lineTo(centerX - width * 0.02, centerY - height * 0.12);
            ctx.moveTo(centerX + width * 0.02, centerY - height * 0.12);
            ctx.lineTo(centerX + width * 0.15, centerY - height * 0.08);
            ctx.stroke();
            
            // çœ¼ç› - ç›´è§†ï¼Œå¨ä¸¥
            ctx.fillStyle = guide.colors[2];
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.05, width * 0.025, height * 0.02, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.05, width * 0.025, height * 0.02, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ä¸­çš„æ€’ç«
            ctx.fillStyle = guide.colors[0];
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.05, width * 0.008, height * 0.006, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.05, width * 0.008, height * 0.006, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å‹ - ä¸¥è‚ƒï¼Œç•¥å¾®ä¸‹æ²‰
            ctx.strokeStyle = guide.colors[1];
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.03, centerY + height * 0.12);
            ctx.lineTo(centerX + width * 0.03, centerY + height * 0.12);
            ctx.stroke();
        }

        function drawThinkingPoseGuide(canvas) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const guide = OPERA_EXPRESSION_GUIDES.thinking_pose;
            const { centerX, centerY } = drawOperaFaceBase(ctx, width, height, guide.colors);
            
            // æ²‰æ€å‚çœ¸ - å®‰è¯¦å®é™
            
            // çœ‰æ¯› - è‡ªç„¶å¹³ç›´
            ctx.strokeStyle = guide.colors[2];
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.15, centerY - height * 0.1);
            ctx.lineTo(centerX - width * 0.05, centerY - height * 0.1);
            ctx.moveTo(centerX + width * 0.05, centerY - height * 0.1);
            ctx.lineTo(centerX + width * 0.15, centerY - height * 0.1);
            ctx.stroke();
            
            // çœ¼ç› - å‚çœ¸ï¼ŒåŠé—­çŠ¶æ€
            ctx.strokeStyle = guide.colors[2];
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX - width * 0.08, centerY - height * 0.03, width * 0.02, 0, Math.PI);
            ctx.arc(centerX + width * 0.08, centerY - height * 0.03, width * 0.02, 0, Math.PI);
            ctx.stroke();
            
            // çœ¼ç‘ - è¡¨ç°å‚çœ¸
            ctx.fillStyle = guide.colors[1] + '60';
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.04, width * 0.02, height * 0.008, 0, 0, Math.PI);
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.04, width * 0.02, height * 0.008, 0, 0, Math.PI);
            ctx.fill();
            
            // å˜´å‹ - ä¸­æ€§ï¼Œå®‰è¯¦
            ctx.strokeStyle = guide.colors[1];
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.02, centerY + height * 0.12);
            ctx.lineTo(centerX + width * 0.02, centerY + height * 0.12);
            ctx.stroke();
        }

        function drawElegantSmileGuide(canvas) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const guide = OPERA_EXPRESSION_GUIDES.elegant_smile;
            const { centerX, centerY } = drawOperaFaceBase(ctx, width, height, guide.colors);
            
            // é›…è‡´å«ç¬‘ - ç«¯åº„ä¼˜é›…
            
            // çœ‰æ¯› - ä¼˜é›…å¼§å½¢
            ctx.strokeStyle = guide.colors[2];
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.15, centerY - height * 0.1);
            ctx.quadraticCurveTo(centerX - width * 0.05, centerY - height * 0.13, centerX + width * 0.05, centerY - height * 0.1);
            ctx.moveTo(centerX - width * 0.05, centerY - height * 0.1);
            ctx.quadraticCurveTo(centerX + width * 0.05, centerY - height * 0.13, centerX + width * 0.15, centerY - height * 0.1);
            ctx.stroke();
            
            // çœ¼ç› - æ¸©å’Œå«ç¬‘
            ctx.fillStyle = guide.colors[2];
            ctx.beginPath();
            ctx.arc(centerX - width * 0.08, centerY - height * 0.05, width * 0.02, 0.1, Math.PI - 0.1);
            ctx.arc(centerX + width * 0.08, centerY - height * 0.05, width * 0.02, 0.1, Math.PI - 0.1);
            ctx.fill();
            
            // çœ¼ä¸­æ¸©å’Œçš„å…‰
            ctx.fillStyle = guide.colors[0];
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.055, width * 0.006, height * 0.004, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.055, width * 0.006, height * 0.004, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å”‡ - ä¼˜é›…çš„æµ…ç¬‘
            ctx.strokeStyle = guide.colors[1];
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY + height * 0.11, width * 0.04, 0.15, Math.PI - 0.15);
            ctx.stroke();
            
            // å˜´è§’çš„ç»†è‡´å¤„ç†
            ctx.fillStyle = guide.colors[1] + '40';
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.035, centerY + height * 0.115, width * 0.005, height * 0.003, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.035, centerY + height * 0.115, width * 0.005, height * 0.003, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawDistantGazeGuide(canvas) {
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const guide = OPERA_EXPRESSION_GUIDES.distant_gaze;
            const { centerX, centerY } = drawOperaFaceBase(ctx, width, height, guide.colors);
            
            // è¿œæœ›å‡çœ¸ - æ·±æƒ…è¿œæœ›
            
            // çœ‰æ¯› - ç•¥å¾®ä¸Šæ‰¬ï¼Œè¡¨ç°æ·±æƒ…
            ctx.strokeStyle = guide.colors[2];
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.15, centerY - height * 0.1);
            ctx.quadraticCurveTo(centerX - width * 0.05, centerY - height * 0.12, centerX + width * 0.05, centerY - height * 0.1);
            ctx.moveTo(centerX - width * 0.05, centerY - height * 0.1);
            ctx.quadraticCurveTo(centerX + width * 0.05, centerY - height * 0.12, centerX + width * 0.15, centerY - height * 0.1);
            ctx.stroke();
            
            // çœ¼ç› - æ·±é‚ƒï¼Œå‡è§†è¿œæ–¹
            ctx.fillStyle = guide.colors[2];
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.05, width * 0.028, height * 0.02, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.05, width * 0.028, height * 0.02, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ç³å­”ä¸­çš„æ·±æƒ… - å±‚æ¬¡æ„Ÿ
            ctx.fillStyle = guide.colors[1];
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.08, centerY - height * 0.05, width * 0.015, height * 0.012, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.08, centerY - height * 0.05, width * 0.015, height * 0.012, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // çœ¼ä¸­çš„å…‰ç‚¹ - è¡¨ç°å‡ç¥
            ctx.fillStyle = guide.colors[0];
            ctx.beginPath();
            ctx.ellipse(centerX - width * 0.075, centerY - height * 0.055, width * 0.006, height * 0.004, 0, 0, Math.PI * 2);
            ctx.ellipse(centerX + width * 0.085, centerY - height * 0.055, width * 0.006, height * 0.004, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å‹ - å¾®æŠ¿ï¼Œè¡¨ç°æ€ç»ªæ·±è¿œ
            ctx.strokeStyle = guide.colors[1];
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(centerX - width * 0.025, centerY + height * 0.12);
            ctx.quadraticCurveTo(centerX, centerY + height * 0.115, centerX + width * 0.025, centerY + height * 0.12);
            ctx.stroke();
        }
        
        // äº¬å‰§æ—¦è§’è¡¨æƒ…è®­ç»ƒå£ä»¤é…ç½®
        const OPERA_COMMANDS = {
            shy_glance: {
                id: "shy_glance",
                name: "å¨‡ç¾æ–œè§†",
                text: "è¯·åšå¨‡ç¾æ–œè§†çš„è¡¨æƒ…ï¼Œçœ¼ç¥è½»æŸ”å«è“„ï¼Œä¿æŒä¸‰ç§’",
                instruction: "çœ¼ç¥æ–œè§†ï¼Œå«ç¾å¸¦æ€¯ï¼Œå¦‚åˆè§æƒ…éƒæ—¶çš„å¨‡æ€",
                tts: true,
                duration: 3000,
                target: "shy",
                difficulty: "M",
                eyePattern: "sidelong_glance",
                bodyRequirement: "slight_head_tilt"
            },
            sorrowful_gaze: {
                id: "sorrowful_gaze",
                name: "å“€æ€¨å‡ç¥",
                text: "è¯·åšå“€æ€¨å‡ç¥çš„è¡¨æƒ…ï¼Œçœ¼å«æ„ç»ªï¼Œä¿æŒä¸‰ç§’",
                instruction: "å‡ç¥è¿œæœ›ï¼Œçœ¼ä¸­å«æ³ªï¼Œå¦‚æ€å›ä¸è§çš„å“€æ€¨",
                tts: true,
                duration: 3000,
                target: "sorrow",
                difficulty: "H",
                eyePattern: "deep_gaze",
                bodyRequirement: "upward_gaze"
            },
            startled_eyes: {
                id: "startled_eyes",
                name: "æƒŠæçªç›®",
                text: "è¯·åšæƒŠæçªç›®çš„è¡¨æƒ…ï¼ŒåŒç›®åœ†çï¼Œä¿æŒä¸¤ç§’",
                instruction: "åŒçœ¼åœ†çï¼Œç¥è‰²æƒŠæï¼Œå¦‚é‡ä¸æµ‹æ—¶çš„éœ‡æƒŠ",
                tts: true,
                duration: 2000,
                target: "startled",
                difficulty: "M",
                eyePattern: "wide_eyes",
                bodyRequirement: "rigid_posture"
            },
            joyful_flutter: {
                id: "joyful_flutter",
                name: "æ¬£å–œæµçœ„",
                text: "è¯·åšæ¬£å–œæµçœ„çš„è¡¨æƒ…ï¼Œçœ¼ç¥æµè½¬ç”Ÿè¾‰ï¼Œä¿æŒä¸‰ç§’",
                instruction: "çœ¼ç¥æµè½¬ï¼Œå–œä¸Šçœ‰æ¢¢ï¼Œå¦‚å¾—ä½³éŸ³æ—¶çš„æ¬£æ‚¦",
                tts: true,
                duration: 3000,
                target: "joy",
                difficulty: "M",
                eyePattern: "flowing_glance",
                bodyRequirement: "light_movement"
            },
            angry_stare: {
                id: "angry_stare",
                name: "å—”æ€’ç›´è§†",
                text: "è¯·åšå—”æ€’ç›´è§†çš„è¡¨æƒ…ï¼Œæ€’ç›®è€Œè§†ï¼Œä¿æŒä¸¤ç§’åŠ",
                instruction: "æ€’ç›®ç›´è§†ï¼Œå¨ä¸¥å‡›ç„¶ï¼Œå¦‚å—å§”å±ˆæ—¶çš„æ„¤æ‡‘",
                tts: true,
                duration: 2500,
                target: "anger",
                difficulty: "H",
                eyePattern: "direct_stare",
                bodyRequirement: "upright_posture"
            },
            thinking_pose: {
                id: "thinking_pose",
                name: "æ²‰æ€å‚çœ¸",
                text: "è¯·åšæ²‰æ€å‚çœ¸çš„è¡¨æƒ…ï¼Œç›®å…‰ä¸‹å‚æ²‰æ€ï¼Œä¿æŒä¸‰ç§’",
                instruction: "å‚çœ¸æ²‰æ€ï¼Œç¥æ€å®‰è¯¦ï¼Œå¦‚æ·±æ€ç†Ÿè™‘æ—¶çš„é™è°§",
                tts: true,
                duration: 3000,
                target: "contemplation",
                difficulty: "M",
                eyePattern: "downward_gaze",
                bodyRequirement: "composed_posture"
            },
            elegant_smile: {
                id: "elegant_smile",
                name: "é›…è‡´å«ç¬‘",
                text: "è¯·åšé›…è‡´å«ç¬‘çš„è¡¨æƒ…ï¼Œæµ…ç¬‘ç›ˆç›ˆï¼Œä¿æŒä¸‰ç§’",
                instruction: "æµ…ç¬‘å«æ˜¥ï¼Œé›…è‡´ç«¯åº„ï¼Œå¦‚å¤§å®¶é—ºç§€çš„æ¸©å©‰",
                tts: true,
                duration: 3000,
                target: "elegant_joy",
                difficulty: "M",
                eyePattern: "gentle_smile",
                bodyRequirement: "graceful_posture"
            },
            distant_gaze: {
                id: "distant_gaze",
                name: "è¿œæœ›å‡çœ¸",
                text: "è¯·åšè¿œæœ›å‡çœ¸çš„è¡¨æƒ…ï¼Œç›®å…‰æ·±è¿œï¼Œä¿æŒä¸‰ç§’",
                instruction: "å‡çœ¸è¿œæœ›ï¼Œæ€ç»ªæ‚ è¿œï¼Œå¦‚ç›¼å›å½’æ¥çš„æ·±æƒ…",
                tts: true,
                duration: 3000,
                target: "longing",
                difficulty: "H",
                eyePattern: "distant_look",
                bodyRequirement: "upward_tilt"
            }
        };

        // äº¬å‰§é¢éƒ¨å…³é”®ç‚¹ - ç‰¹åˆ«æ³¨é‡çœ¼éƒ¨ç»†èŠ‚
        const OPERA_LANDMARKS = {
            // çœ¼éƒ¨ - äº¬å‰§è¡¨æ¼”çš„æ ¸å¿ƒ
            LEFT_EYE: {
                INNER_CORNER: 33,   // å†…çœ¼è§’
                OUTER_CORNER: 133,  // å¤–çœ¼è§’
                UPPER_LID: 159,     // ä¸Šçœ¼ç‘
                LOWER_LID: 145,     // ä¸‹çœ¼ç‘
                PUPIL_AREA: [468, 469, 470, 471], // ç³å­”åŒºåŸŸï¼ˆç®€åŒ–ï¼‰
                OUTLINE: [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246]
            },
            RIGHT_EYE: {
                INNER_CORNER: 362,
                OUTER_CORNER: 263,
                UPPER_LID: 386,
                LOWER_LID: 374,
                PUPIL_AREA: [472, 473, 474, 475],
                OUTLINE: [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398]
            },
            // çœ‰æ¯› - æƒ…æ„Ÿè¡¨è¾¾çš„é‡è¦éƒ¨åˆ†
            LEFT_EYEBROW: {
                INNER: 55,
                ARCH: 70,
                OUTER: 46
            },
            RIGHT_EYEBROW: {
                INNER: 285,
                ARCH: 300,
                OUTER: 276
            },
            // å˜´éƒ¨ - é…åˆçœ¼ç¥çš„è¡¨æƒ…
            MOUTH: {
                LEFT_CORNER: 61,
                RIGHT_CORNER: 291,
                UPPER_LIP: 13,
                LOWER_LIP: 14,
                CUPID_BOW: [12, 15] // å”‡å³°
            },
            // é¢éƒ¨è½®å»“ - æ•´ä½“å§¿æ€
            FACE: {
                CHIN: 175,
                LEFT_CHEEK: 116,
                RIGHT_CHEEK: 345,
                FOREHEAD: 10
            },
            NOSE_TIP: 1
        };

        // å…¨å±€å˜é‡
        let faceMesh;
        let camera;
        let currentRole = 'dan';  // 'dan' or 'qingyi'
        let isTraining = false;
        let isCalibrating = false;
        let operaBaseline = null; // æˆæ›²è¡¨æ¼”åŸºçº¿
        let metricsBuffer = [];
        let currentSession = null;
        let frameCount = 0;
        let lastFrameTime = 0;

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', async () => {
            await initializeCamera();
            setupEventListeners();
            updateUI();
        });

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // è§’è‰²åˆ‡æ¢
            document.querySelectorAll('.role-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.role-option').forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    currentRole = option.dataset.role;
                    updateUI();
                });
            });

            // æŒ‰é’®äº‹ä»¶
            document.getElementById('startBtn').addEventListener('click', startOperaTraining);
            document.getElementById('nextBtn').addEventListener('click', nextOperaExpression);
            document.getElementById('calibrateBtn').addEventListener('click', operaCalibrate);

            // è¡¨æƒ…é€‰æ‹©
            document.getElementById('operaCommandSelect').addEventListener('change', updateUI);
        }

        // åˆå§‹åŒ–æ‘„åƒå¤´
        async function initializeCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const videoElement = document.getElementById('videoElement');
                videoElement.srcObject = stream;
                
                videoElement.onloadedmetadata = () => {
                    const canvas = document.getElementById('overlayCanvas');
                    canvas.width = videoElement.videoWidth;
                    canvas.height = videoElement.videoHeight;
                };

                await initializeFaceMesh();
                document.getElementById('videoStatus').textContent = 'æˆæ›²è®­ç»ƒç³»ç»Ÿå°±ç»ª';
                
            } catch (error) {
                console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
                document.getElementById('videoStatus').textContent = 'æ‘„åƒå¤´è®¿é—®å¤±è´¥';
            }
        }

        async function initializeFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.7, // æé«˜æ£€æµ‹ç²¾åº¦
                minTrackingConfidence: 0.7
            });

            faceMesh.onResults(onOperaResults);

            camera = new Camera(document.getElementById('videoElement'), {
                onFrame: async () => {
                    await faceMesh.send({image: document.getElementById('videoElement')});
                },
                width: 640,
                height: 480
            });

            camera.start();
        }

        // äº¬å‰§è¡¨æƒ…ç»“æœå¤„ç†
        function onOperaResults(results) {
            const now = performance.now();
            
            frameCount++;
            if (now - lastFrameTime >= 1000) {
                lastFrameTime = now;
                frameCount = 0;
            }

            const canvas = document.getElementById('overlayCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // ç»˜åˆ¶æˆæ›²è¡¨æƒ…è½®å»“
                drawOperaOverlay(ctx, landmarks);
                
                // æå–æˆæ›²è¡¨æƒ…ç‰¹å¾
                const operaMetrics = extractOperaMetrics(landmarks);
                
                // æ”¶é›†è®­ç»ƒæ•°æ®
                if ((isTraining || isCalibrating) && operaMetrics) {
                    metricsBuffer.push({
                        timestamp: now,
                        metrics: operaMetrics
                    });
                }
                
                document.getElementById('videoStatus').textContent = 'é¢éƒ¨è¯†åˆ«æ­£å¸¸ - æˆæ›²æ¨¡å¼';
            } else {
                document.getElementById('videoStatus').textContent = 'æœªæ£€æµ‹åˆ°é¢éƒ¨';
            }
        }

        // ç»˜åˆ¶æˆæ›²è¡¨æƒ…è½®å»“ - çªå‡ºçœ¼éƒ¨
        function drawOperaOverlay(ctx, landmarks) {
            // çœ¼éƒ¨è½®å»“ - é‡‘è‰²ï¼Œæ›´åŠ çªå‡º
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            drawLandmarkContour(ctx, OPERA_LANDMARKS.LEFT_EYE.OUTLINE, landmarks);
            drawLandmarkContour(ctx, OPERA_LANDMARKS.RIGHT_EYE.OUTLINE, landmarks);
            
            // çœ‰æ¯›è½®å»“ - æ·±çº¢è‰²
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 2;
            drawEyebrowLine(ctx, landmarks, 'left');
            drawEyebrowLine(ctx, landmarks, 'right');
            
            // å˜´éƒ¨è½®å»“ - æš—é‡‘è‰²
            ctx.strokeStyle = '#B8860B';
            ctx.lineWidth = 2;
            drawMouthContour(ctx, landmarks);
            
            // çœ¼ç¥æ–¹å‘æŒ‡ç¤º - æˆæ›²ç‰¹è‰²
            drawEyeGazeDirection(ctx, landmarks);
        }

        function drawLandmarkContour(ctx, indices, landmarks) {
            if (!indices || !landmarks) return;
            
            ctx.beginPath();
            let started = false;
            
            indices.forEach(idx => {
                if (landmarks[idx]) {
                    const point = landmarks[idx];
                    const x = point.x * ctx.canvas.width;
                    const y = point.y * ctx.canvas.height;
                    
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            });
            
            ctx.closePath();
            ctx.stroke();
        }

        function drawEyebrowLine(ctx, landmarks, side) {
            const brow = side === 'left' ? OPERA_LANDMARKS.LEFT_EYEBROW : OPERA_LANDMARKS.RIGHT_EYEBROW;
            
            ctx.beginPath();
            if (landmarks[brow.INNER] && landmarks[brow.ARCH] && landmarks[brow.OUTER]) {
                const inner = landmarks[brow.INNER];
                const arch = landmarks[brow.ARCH];
                const outer = landmarks[brow.OUTER];
                
                ctx.moveTo(inner.x * ctx.canvas.width, inner.y * ctx.canvas.height);
                ctx.quadraticCurveTo(
                    arch.x * ctx.canvas.width, arch.y * ctx.canvas.height,
                    outer.x * ctx.canvas.width, outer.y * ctx.canvas.height
                );
            }
            ctx.stroke();
        }

        function drawMouthContour(ctx, landmarks) {
            const mouth = OPERA_LANDMARKS.MOUTH;
            if (landmarks[mouth.LEFT_CORNER] && landmarks[mouth.RIGHT_CORNER] && 
                landmarks[mouth.UPPER_LIP] && landmarks[mouth.LOWER_LIP]) {
                
                ctx.beginPath();
                const left = landmarks[mouth.LEFT_CORNER];
                const right = landmarks[mouth.RIGHT_CORNER];
                const upper = landmarks[mouth.UPPER_LIP];
                const lower = landmarks[mouth.LOWER_LIP];
                
                ctx.moveTo(left.x * ctx.canvas.width, left.y * ctx.canvas.height);
                ctx.quadraticCurveTo(
                    upper.x * ctx.canvas.width, upper.y * ctx.canvas.height,
                    right.x * ctx.canvas.width, right.y * ctx.canvas.height
                );
                ctx.quadraticCurveTo(
                    lower.x * ctx.canvas.width, lower.y * ctx.canvas.height,
                    left.x * ctx.canvas.width, left.y * ctx.canvas.height
                );
                ctx.stroke();
            }
        }

        function drawEyeGazeDirection(ctx, landmarks) {
            // ç®€åŒ–çš„çœ¼ç¥æ–¹å‘æŒ‡ç¤º
            const leftEye = landmarks[OPERA_LANDMARKS.LEFT_EYE.INNER_CORNER];
            const rightEye = landmarks[OPERA_LANDMARKS.RIGHT_EYE.INNER_CORNER];
            
            if (leftEye && rightEye) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(leftEye.x * ctx.canvas.width, leftEye.y * ctx.canvas.height, 3, 0, Math.PI * 2);
                ctx.arc(rightEye.x * ctx.canvas.width, rightEye.y * ctx.canvas.height, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /**
         * äº¬å‰§è¡¨æƒ…ç‰¹å¾æå–
         * ä¸“æ³¨äºçœ¼ç¥ã€å§¿æ€ã€éŸµå‘³ç­‰æˆæ›²è¡¨æ¼”è¦ç´ 
         */
        function extractOperaMetrics(landmarks) {
            if (!landmarks || landmarks.length < 468) return null;

            try {
                // çœ¼éƒ¨ç‰¹å¾ - æˆæ›²è¡¨æ¼”çš„æ ¸å¿ƒ
                const leftEye = {
                    inner: landmarks[OPERA_LANDMARKS.LEFT_EYE.INNER_CORNER],
                    outer: landmarks[OPERA_LANDMARKS.LEFT_EYE.OUTER_CORNER],
                    upper: landmarks[OPERA_LANDMARKS.LEFT_EYE.UPPER_LID],
                    lower: landmarks[OPERA_LANDMARKS.LEFT_EYE.LOWER_LID]
                };
                
                const rightEye = {
                    inner: landmarks[OPERA_LANDMARKS.RIGHT_EYE.INNER_CORNER],
                    outer: landmarks[OPERA_LANDMARKS.RIGHT_EYE.OUTER_CORNER],
                    upper: landmarks[OPERA_LANDMARKS.RIGHT_EYE.UPPER_LID],
                    lower: landmarks[OPERA_LANDMARKS.RIGHT_EYE.LOWER_LID]
                };

                // çœ‰æ¯›ç‰¹å¾
                const leftBrow = {
                    inner: landmarks[OPERA_LANDMARKS.LEFT_EYEBROW.INNER],
                    arch: landmarks[OPERA_LANDMARKS.LEFT_EYEBROW.ARCH],
                    outer: landmarks[OPERA_LANDMARKS.LEFT_EYEBROW.OUTER]
                };
                
                const rightBrow = {
                    inner: landmarks[OPERA_LANDMARKS.RIGHT_EYEBROW.INNER],
                    arch: landmarks[OPERA_LANDMARKS.RIGHT_EYEBROW.ARCH],
                    outer: landmarks[OPERA_LANDMARKS.RIGHT_EYEBROW.OUTER]
                };

                // å˜´éƒ¨ç‰¹å¾
                const mouth = {
                    left: landmarks[OPERA_LANDMARKS.MOUTH.LEFT_CORNER],
                    right: landmarks[OPERA_LANDMARKS.MOUTH.RIGHT_CORNER],
                    upper: landmarks[OPERA_LANDMARKS.MOUTH.UPPER_LIP],
                    lower: landmarks[OPERA_LANDMARKS.MOUTH.LOWER_LIP]
                };

                const distance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                // 1. çœ¼ç¥è¡¨æƒ…å¼ºåº¦ (Eye Expression Intensity)
                const leftEyeOpenness = distance(leftEye.upper, leftEye.lower) / distance(leftEye.inner, leftEye.outer);
                const rightEyeOpenness = distance(rightEye.upper, rightEye.lower) / distance(rightEye.inner, rightEye.outer);
                const eyeExpression = (leftEyeOpenness + rightEyeOpenness) / 2;

                // 2. çœ¼ç¥æ–¹å‘ (Gaze Direction) - æˆæ›²ä¸­çš„"çœ¼ç¥æ´»"
                const leftEyeCenter = {
                    x: (leftEye.inner.x + leftEye.outer.x) / 2,
                    y: (leftEye.upper.y + leftEye.lower.y) / 2
                };
                const rightEyeCenter = {
                    x: (rightEye.inner.x + rightEye.outer.x) / 2,
                    y: (rightEye.upper.y + rightEye.lower.y) / 2
                };
                
                // ç®€åŒ–çš„çœ¼ç¥æ–¹å‘è®¡ç®—
                const gazeDirection = Math.abs(leftEyeCenter.x - rightEyeCenter.x) * 1000;

                // 3. çœ‰çœ¼åè°ƒ (Brow-Eye Coordination)
                const leftBrowEyeDistance = distance(leftBrow.arch, leftEye.upper);
                const rightBrowEyeDistance = distance(rightBrow.arch, rightEye.upper);
                const browEyeCoordination = 1 - Math.abs(leftBrowEyeDistance - rightBrowEyeDistance);

                // 4. é¢éƒ¨å¯¹ç§°æ€§ (Facial Symmetry)
                const eyeSymmetry = 1 - Math.abs(leftEyeOpenness - rightEyeOpenness);
                const browSymmetry = 1 - Math.abs(leftBrow.arch.y - rightBrow.arch.y) * 1000;
                const mouthSymmetry = 1 - Math.abs(mouth.left.y - mouth.right.y) * 1000;
                const facialSymmetry = (eyeSymmetry + browSymmetry + mouthSymmetry) / 3;

                // 5. å˜´éƒ¨è¡¨æƒ… (Mouth Expression)
                const mouthWidth = distance(mouth.left, mouth.right);
                const mouthHeight = distance(mouth.upper, mouth.lower);
                const mouthExpression = mouthHeight / mouthWidth;

                // 6. æ•´ä½“å§¿æ€ (Overall Posture) - åŸºäºé¢éƒ¨è§’åº¦
                const noseTip = landmarks[OPERA_LANDMARKS.NOSE_TIP];
                const chin = landmarks[OPERA_LANDMARKS.FACE.CHIN];
                const faceAngle = Math.atan2(chin.y - noseTip.y, chin.x - noseTip.x);
                const postureGrace = 1 - Math.abs(faceAngle) / Math.PI;

                // 7. çœ¼ç¥æ·±åº¦ (Eye Depth) - æˆæ›²è¡¨æ¼”çš„"ç¥éŸµ"
                const eyeDepth = eyeExpression * browEyeCoordination;

                // 8. è¡¨æƒ…å˜åŒ–å¹…åº¦ (Expression Range)
                const expressionRange = Math.abs(eyeExpression - 0.3) + Math.abs(mouthExpression - 0.1);

                return {
                    // æˆæ›²å››éŸµ
                    eyeExpression,      // çœ¼ç¥
                    postureGrace,       // èº«æ®µ  
                    operaCharm: (eyeDepth + facialSymmetry) / 2,  // éŸµå‘³
                    spiritGrace: eyeDepth,  // ç¥éŸµ
                    
                    // æŠ€æœ¯æŒ‡æ ‡
                    gazeDirection,
                    browEyeCoordination,
                    facialSymmetry,
                    mouthExpression,
                    expressionRange,
                    
                    // åŸå§‹æ•°æ®
                    leftEyeOpenness,
                    rightEyeOpenness,
                    eyeSymmetry,
                    leftBrowEyeDistance,
                    rightBrowEyeDistance
                };

            } catch (error) {
                console.error('äº¬å‰§ç‰¹å¾æå–å¤±è´¥:', error);
                return null;
            }
        }

        /**
         * äº¬å‰§è¡¨æƒ…è¯„åˆ†ç³»ç»Ÿ
         * åŸºäºä¼ ç»Ÿæˆæ›²è¡¨æ¼”çš„è¯„åˆ¤æ ‡å‡†
         */
        function scoreOperaExpression(metrics, target, role, baseline) {
            if (!metrics) return { eye: 0, posture: 0, charm: 0, spirit: 0 };

            let scores = {
                eye: 60,      // çœ¼ç¥åˆ†
                posture: 60,  // èº«æ®µåˆ†  
                charm: 60,    // éŸµå‘³åˆ†
                spirit: 60    // ç¥éŸµåˆ†
            };

            // åŸºäºä¸åŒè¡¨æƒ…ç±»å‹çš„è¯„åˆ†
            switch (target) {
                case 'shy':
                    // å¨‡ç¾æ–œè§†ï¼šçœ¼ç¥è¦å«è“„ï¼Œç•¥æœ‰ä¾§è§†
                    scores.eye = 50 + metrics.gazeDirection * 30;
                    scores.charm = 50 + (1 - metrics.eyeExpression) * 50; // çœ¼ç¥å«è“„
                    break;
                    
                case 'sorrow':
                    // å“€æ€¨å‡ç¥ï¼šçœ¼ç¥æ·±è¿œï¼Œçœ‰çœ¼é…åˆ
                    scores.eye = 40 + metrics.eyeDepth * 60;
                    scores.spirit = 30 + metrics.browEyeCoordination * 70;
                    break;
                    
                case 'startled':
                    // æƒŠæçªç›®ï¼šçœ¼ç›è¦å¼ å¤§ï¼Œè¡¨æƒ…è¦å¤¸å¼ 
                    scores.eye = 30 + metrics.eyeExpression * 70;
                    scores.posture = 40 + metrics.expressionRange * 60;
                    break;
                    
                case 'joy':
                    // æ¬£å–œæµçœ„ï¼šçœ¼ç¥è¦çµæ´»ï¼Œæœ‰ç¥é‡‡
                    scores.eye = 50 + metrics.eyeExpression * 40;
                    scores.charm = 50 + metrics.gazeDirection * 25;
                    break;
                    
                case 'anger':
                    // å—”æ€’ç›´è§†ï¼šçœ¼ç¥è¦ç›´æ¥ï¼Œå¨ä¸¥
                    scores.eye = 40 + (1 - metrics.gazeDirection / 50) * 60;
                    scores.spirit = 50 + metrics.browEyeCoordination * 50;
                    break;
                    
                case 'contemplation':
                    // æ²‰æ€å‚çœ¸ï¼šçœ¼ç¥è¦å†…æ•›ï¼Œå§¿æ€è¦é™
                    scores.eye = 50 + (1 - metrics.eyeExpression) * 50;
                    scores.posture = 60 + metrics.postureGrace * 40;
                    break;
                    
                case 'elegant_joy':
                    // é›…è‡´å«ç¬‘ï¼šçœ¼å£é…åˆï¼Œä¼˜é›…å«è“„
                    scores.eye = 50 + metrics.eyeExpression * 30;
                    scores.charm = 40 + metrics.mouthExpression * 60;
                    break;
                    
                case 'longing':
                    // è¿œæœ›å‡çœ¸ï¼šçœ¼ç¥æ·±è¿œï¼Œç¥æƒ…ä¸“æ³¨
                    scores.eye = 40 + metrics.eyeDepth * 50;
                    scores.spirit = 50 + metrics.browEyeCoordination * 50;
                    break;
            }

            // è§’è‰²ç‰¹è‰²åŠ æƒ
            if (role === 'qingyi') {
                // é’è¡£è¦æ±‚æ›´åŠ ç«¯åº„ä¼˜é›…
                scores.charm *= 1.1;
                scores.spirit *= 1.1;
            }

            // å¯¹ç§°æ€§å½±å“æ‰€æœ‰åˆ†æ•°
            const symmetryBonus = metrics.facialSymmetry * 20;
            Object.keys(scores).forEach(key => {
                scores[key] += symmetryBonus;
                scores[key] = Math.max(0, Math.min(100, Math.round(scores[key])));
            });

            return scores;
        }

        /**
         * äº¬å‰§è¡¨æ¼”æŒ‡å¯¼ç”Ÿæˆ
         */
        function generateOperaTips(scores, metrics, target, role) {
            const tips = [];
            const isQingyi = role === 'qingyi';

            // çœ¼ç¥æŒ‡å¯¼
            if (scores.eye < 70) {
                switch (target) {
                    case 'shy':
                        tips.push("å¨‡ç¾æ–œè§†éœ€è¦çœ¼ç¥å«è“„å¸¦æ€¯ï¼Œç›®å…‰ä¸è¦ç›´è§†ï¼Œç•¥å¸¦ç¾æ¶©åœ°åå‘ä¸€ä¾§ã€‚");
                        break;
                    case 'sorrow':
                        tips.push("å“€æ€¨å‡ç¥è¦æ±‚çœ¼ç¥æ·±è¿œï¼Œä»¿ä½›åœ¨å‡è§†è¿œæ–¹ï¼Œçœ¼ä¸­å«æœ‰æ·¡æ·¡æ„ç»ªã€‚");
                        break;
                    case 'startled':
                        tips.push("æƒŠæçªç›®éœ€è¦åŒçœ¼åœ†çï¼Œçªç„¶å¼ å¤§ï¼Œè¡¨ç°å‡ºè¢«æƒŠå“çš„ç¥æ€ã€‚");
                        break;
                    case 'joy':
                        tips.push("æ¬£å–œæµçœ„è¦æ±‚çœ¼ç¥çµæ´»æµè½¬ï¼Œçœ¼ä¸­æœ‰ç¥é‡‡ï¼Œè¡¨ç°å‡ºå†…å¿ƒçš„å–œæ‚¦ã€‚");
                        break;
                    default:
                        tips.push("çœ¼ç¥æ˜¯æˆæ›²è¡¨æ¼”çš„çµé­‚ï¼Œéœ€è¦æ ¹æ®æƒ…æ„Ÿå˜åŒ–è°ƒæ•´çœ¼ç¥çš„æ·±æµ…å’Œæ–¹å‘ã€‚");
                }
            }

            // èº«æ®µå§¿æ€æŒ‡å¯¼
            if (scores.posture < 70) {
                if (isQingyi) {
                    tips.push("é’è¡£èº«æ®µè¦æ±‚ç«¯åº„å…¸é›…ï¼Œå¤´éƒ¨å¾®å¾®ä¸Šæ‰¬ï¼Œä¿æŒè´µæ—å¥³æ€§çš„å¨ä»ªã€‚");
                } else {
                    tips.push("æ—¦è§’èº«æ®µè¦ä½“ç°å¥³æ€§çš„æŸ”ç¾ï¼Œå¤´éƒ¨è§’åº¦è¦é…åˆçœ¼ç¥è¡¨æƒ…çš„å˜åŒ–ã€‚");
                }
            }

            // éŸµå‘³æŒ‡å¯¼
            if (scores.charm < 70) {
                tips.push("æˆæ›²è¡¨æ¼”çš„éŸµå‘³æ¥è‡ªäºçœ¼ç¥ä¸è¡¨æƒ…çš„å’Œè°ç»Ÿä¸€ï¼Œéœ€è¦å¤šç»ƒä¹ çœ¼å£é…åˆã€‚");
            }

            // ç¥éŸµæŒ‡å¯¼
            if (scores.spirit < 70) {
                tips.push("ç¥éŸµæ˜¯æˆæ›²è¡¨æ¼”çš„æœ€é«˜å¢ƒç•Œï¼Œè¦ä»å†…å¿ƒä½“ä¼šè§’è‰²æƒ…æ„Ÿï¼Œè®©è¡¨æƒ…è‡ªç„¶æµéœ²ã€‚");
            }

            // å¯¹ç§°æ€§æé†’
            if (metrics.facialSymmetry < 0.8) {
                tips.push("æ³¨æ„é¢éƒ¨è¡¨æƒ…çš„å¯¹ç§°æ€§ï¼Œå·¦å³çœ‰çœ¼è¦åè°ƒç»Ÿä¸€ï¼Œé¿å…è¡¨æƒ…åƒµç¡¬ã€‚");
            }

            // ç‰¹å®šè¡¨æƒ…çš„ä¸“é¡¹æŒ‡å¯¼
            if (target === 'shy' && metrics.gazeDirection < 0.3) {
                tips.push("å¨‡ç¾è¡¨æƒ…çš„ç²¾é«“åœ¨äº'æ–œè§†'ï¼Œè¦å­¦ä¼šç”¨çœ¼è§’ä½™å…‰è¡¨è¾¾å«è“„çš„æƒ…æ„Ÿã€‚");
            }

            if (target === 'sorrow' && metrics.browEyeCoordination < 0.7) {
                tips.push("å“€æ€¨è¡¨æƒ…éœ€è¦çœ‰çœ¼é…åˆï¼Œçœ‰å¤´è½»çš±ï¼Œçœ¼ç¥å‡é‡ï¼Œè¡¨ç°å†…å¿ƒçš„æ„è‹¦ã€‚");
            }

            // é¼“åŠ±æ€§åé¦ˆ
            if (tips.length === 0) {
                const avgScore = (scores.eye + scores.posture + scores.charm + scores.spirit) / 4;
                if (avgScore > 85) {
                    tips.push("å‡ºè‰²çš„è¡¨æ¼”ï¼å·²ç»å¾ˆå¥½åœ°æŒæ¡äº†äº¬å‰§æ—¦è§’çš„è¡¨æƒ…éŸµå‘³ï¼Œç»§ç»­ä¿æŒã€‚");
                } else {
                    tips.push("è¡¨æ¼”ä¸é”™ï¼Œç»§ç»­ç»ƒä¹ ï¼Œå¤šä½“ä¼šä¼ ç»Ÿæˆæ›²è¡¨æ¼”çš„ç²¾é«“å’Œå†…æ¶µã€‚");
                }
            }

            return tips.slice(0, 4);
        }

        // å¼€å§‹æˆæ›²è®­ç»ƒ
        async function startOperaTraining() {
            if (isTraining) return;
            
            const commandId = document.getElementById('operaCommandSelect').value;
            const command = OPERA_COMMANDS[commandId];
            
            if (!command) return;
            
            isTraining = true;
            metricsBuffer = [];
            
            // æ›´æ–°UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('currentCommand').textContent = command.name;
            document.getElementById('operaInstruction').textContent = command.instruction;
            
            // TTSæ’­æŠ¥
            if (command.tts && 'speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(command.text);
                utterance.lang = 'zh-CN';
                utterance.rate = 0.9; // ç¨æ…¢ä¸€ç‚¹ï¼Œæ›´ç¬¦åˆæˆæ›²èŠ‚å¥
                speechSynthesis.speak(utterance);
            }
            
            // å€’è®¡æ—¶
            await operaCountdown(3);
            
            // å¼€å§‹è®°å½•
            currentSession = {
                role: currentRole,
                command: command,
                startTime: performance.now()
            };
            
            // è®­ç»ƒè®¡æ—¶
            setTimeout(() => {
                finishOperaTraining();
            }, command.duration);
            
            // æ˜¾ç¤ºå€’è®¡æ—¶
            showOperaCountdown(command.duration);
        }

        // æˆæ›²é£æ ¼å€’è®¡æ—¶
        async function operaCountdown(seconds) {
            const countdownEl = document.getElementById('countdown');
            
            for (let i = seconds; i > 0; i--) {
                countdownEl.textContent = i;
                countdownEl.style.color = '#8B0000';
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            countdownEl.textContent = 'å¼€å§‹ï¼';
            countdownEl.style.color = '#FFD700';
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        // æ˜¾ç¤ºè®­ç»ƒå€’è®¡æ—¶
        function showOperaCountdown(duration) {
            const countdownEl = document.getElementById('countdown');
            const startTime = Date.now();
            
            const updateCountdown = () => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, duration - elapsed);
                const seconds = (remaining / 1000).toFixed(1);
                
                countdownEl.textContent = `${seconds}ç§’`;
                countdownEl.style.color = '#B8860B';
                
                if (remaining > 0) {
                    requestAnimationFrame(updateCountdown);
                } else {
                    countdownEl.textContent = '';
                }
            };
            
            requestAnimationFrame(updateCountdown);
        }

        // å®Œæˆæˆæ›²è®­ç»ƒ
        function finishOperaTraining() {
            isTraining = false;
            currentSession.endTime = performance.now();
            
            // åˆ†æç»“æœ
            if (metricsBuffer.length > 0) {
                analyzeOperaSession();
            }
            
            document.getElementById('startBtn').disabled = false;
        }

        // åˆ†ææˆæ›²è®­ç»ƒä¼šè¯
        function analyzeOperaSession() {
            const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
            if (validMetrics.length === 0) return;
            
            const avgMetrics = calculateAverageMetrics(validMetrics);
            
            // æˆæ›²è¯„åˆ†
            const operaScores = scoreOperaExpression(avgMetrics, getCurrentTarget(), currentRole, operaBaseline);
            
            // ç”Ÿæˆæˆæ›²æŒ‡å¯¼
            const tips = generateOperaTips(operaScores, avgMetrics, getCurrentTarget(), currentRole);
            
            // æ›´æ–°UI
            updateOperaScoreDisplay(operaScores);
            updateTips(tips);
            showOperaResults(operaScores, avgMetrics);
        }

        // è®¡ç®—å¹³å‡ç‰¹å¾
        function calculateAverageMetrics(metrics) {
            const avg = {};
            const keys = Object.keys(metrics[0]);
            
            keys.forEach(key => {
                avg[key] = metrics.reduce((sum, m) => sum + m[key], 0) / metrics.length;
            });
            
            return avg;
        }

        // æ›´æ–°æˆæ›²è¯„åˆ†æ˜¾ç¤º
        function updateOperaScoreDisplay(scores) {
            // æ›´æ–°å››ä¸ªæˆæ›²è¯„åˆ†å¾½ç« 
            updateOperaBadge('eyeBadge', 'eyeScore', scores.eye);
            updateOperaBadge('postureBadge', 'postureScore', scores.posture);
            updateOperaBadge('charmBadge', 'charmScore', scores.charm);
            updateOperaBadge('spiritBadge', 'spiritScore', scores.spirit);
            
            // æ›´æ–°æ€»åˆ†
            const totalScore = Math.round((scores.eye + scores.posture + scores.charm + scores.spirit) / 4);
            document.getElementById('totalScore').textContent = totalScore;
            document.getElementById('progressFill').style.width = `${totalScore}%`;
        }

        // æ›´æ–°å•ä¸ªæˆæ›²å¾½ç« 
        function updateOperaBadge(badgeId, scoreId, score) {
            const badge = document.getElementById(badgeId);
            const scoreEl = document.getElementById(scoreId);
            
            scoreEl.textContent = score;
            
            // æ¸…é™¤æ ·å¼
            badge.classList.remove('excellent', 'good', 'needs-work');
            
            // æ ¹æ®åˆ†æ•°è®¾ç½®æ ·å¼
            if (score >= 85) {
                badge.classList.add('excellent');
            } else if (score >= 70) {
                badge.classList.add('good');
            } else {
                badge.classList.add('needs-work');
            }
        }

        // æ›´æ–°å»ºè®®é¢æ¿
        function updateTips(tips) {
            const container = document.getElementById('tipsContainer');
            container.innerHTML = '';
            
            tips.forEach(tip => {
                const tipEl = document.createElement('div');
                tipEl.className = 'tip-item';
                tipEl.textContent = tip;
                container.appendChild(tipEl);
            });
        }

        // æ˜¾ç¤ºæˆæ›²ç»“æœ
        function showOperaResults(scores, metrics) {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.classList.add('visible');
            
            // æ›´æ–°æ ‡é¢˜
            const commandName = OPERA_COMMANDS[getCurrentCommandId()].name;
            document.getElementById('resultsTitle').textContent = `${currentRole === 'dan' ? 'æ—¦è§’' : 'é’è¡£'} - ${commandName}`;
            
            // æ›´æ–°è¡¨æƒ…ç­‰çº§æ ‡ç­¾
            const avgScore = (scores.eye + scores.posture + scores.charm + scores.spirit) / 4;
            const levelLabel = document.getElementById('expressionLevel');
            
            if (avgScore >= 85) {
                levelLabel.textContent = 'ç¨‹å¼ç²¾æ¹›';
                levelLabel.style.background = 'linear-gradient(145deg, rgba(255, 215, 0, 0.4), rgba(184, 134, 11, 0.3))';
            } else if (avgScore >= 70) {
                levelLabel.textContent = 'ç¨‹å¼æ ‡å‡†';
                levelLabel.style.background = 'linear-gradient(145deg, rgba(184, 134, 11, 0.3), rgba(205, 133, 63, 0.2))';
            } else {
                levelLabel.textContent = 'éœ€è¦ç»ƒä¹ ';
                levelLabel.style.background = 'linear-gradient(145deg, rgba(205, 133, 63, 0.3), rgba(160, 82, 45, 0.2))';
            }
            
            // ç»˜åˆ¶å›¾è¡¨
            drawOperaRadarChart(scores);
            drawEyeChart(metrics);
        }

        // ç»˜åˆ¶æˆæ›²é›·è¾¾å›¾
        function drawOperaRadarChart(scores) {
            const canvas = document.getElementById('operaRadarChart');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 40;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼ - é‡‘è‰²é£æ ¼
            ctx.strokeStyle = 'rgba(218, 165, 32, 0.3)';
            ctx.lineWidth = 1;
            
            for (let i = 1; i <= 5; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * i / 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶åæ ‡è½´å’Œæ ‡ç­¾
            const labels = ['çœ¼ç¥', 'èº«æ®µ', 'éŸµå‘³', 'ç¥éŸµ'];
            const values = [scores.eye, scores.posture, scores.charm, scores.spirit];
            
            ctx.font = 'bold 14px STKaiti, æ¥·ä½“, serif';
            ctx.fillStyle = '#8B0000';
            ctx.textAlign = 'center';
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 - Math.PI / 2;
                const x1 = centerX;
                const y1 = centerY;
                const x2 = centerX + Math.cos(angle) * radius;
                const y2 = centerY + Math.sin(angle) * radius;
                
                // ç»˜åˆ¶è½´çº¿
                ctx.strokeStyle = 'rgba(139, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // ç»˜åˆ¶æ ‡ç­¾
                const labelX = centerX + Math.cos(angle) * (radius + 25);
                const labelY = centerY + Math.sin(angle) * (radius + 25);
                ctx.fillText(labels[i], labelX, labelY);
            }
            
            // ç»˜åˆ¶æ•°æ®å¤šè¾¹å½¢ - é‡‘çº¢æ¸å˜
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(255, 215, 0, 0.6)');
            gradient.addColorStop(1, 'rgba(139, 0, 0, 0.3)');
            
            ctx.fillStyle = gradient;
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 - Math.PI / 2;
                const value = values[i] / 100;
                const x = centerX + Math.cos(angle) * radius * value;
                const y = centerY + Math.sin(angle) * radius * value;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                // ç»˜åˆ¶æ•°æ®ç‚¹
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#B8860B';
            ctx.stroke();
        }

        // ç»˜åˆ¶çœ¼ç¥æŠ€æ³•å›¾è¡¨
        function drawEyeChart(metrics) {
            const canvas = document.getElementById('eyeChart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            
            ctx.clearRect(0, 0, width, height);
            
            // çœ¼ç¥ç›¸å…³æŒ‡æ ‡
            const eyeData = [
                { label: 'çœ¼ç¥è¡¨è¾¾', value: metrics.eyeExpression * 100, color: '#FFD700' },
                { label: 'çœ¼ç¥æ–¹å‘', value: Math.min(100, metrics.gazeDirection * 2), color: '#DAA520' },
                { label: 'çœ‰çœ¼åè°ƒ', value: metrics.browEyeCoordination * 100, color: '#B8860B' },
                { label: 'é¢éƒ¨å¯¹ç§°', value: metrics.facialSymmetry * 100, color: '#CD853F' }
            ];
            
            // ç»˜åˆ¶æŸ±çŠ¶å›¾
            const barWidth = (width - padding * 2) / eyeData.length - 10;
            
            eyeData.forEach((data, i) => {
                const x = padding + i * (barWidth + 10);
                const barHeight = (data.value / 100) * (height - padding * 2);
                const y = height - padding - barHeight;
                
                // ç»˜åˆ¶æŸ±å­ - æ¸å˜æ•ˆæœ
                const gradient = ctx.createLinearGradient(0, y, 0, y + barHeight);
                gradient.addColorStop(0, data.color);
                gradient.addColorStop(1, data.color + '80');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // ç»˜åˆ¶è¾¹æ¡†
                ctx.strokeStyle = data.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, barWidth, barHeight);
                
                // ç»˜åˆ¶æ•°å€¼
                ctx.fillStyle = '#8B0000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(data.value), x + barWidth / 2, y - 5);
                
                // ç»˜åˆ¶æ ‡ç­¾
                ctx.font = '11px STKaiti, æ¥·ä½“, serif';
                ctx.fillText(data.label, x + barWidth / 2, height - padding + 15);
            });
        }

        // æˆæ›²ä¸ªäººæ ¡å‡†
        async function operaCalibrate() {
            if (isCalibrating) return;
            
            isCalibrating = true;
            metricsBuffer = [];
            
            document.getElementById('calibrateBtn').disabled = true;
            document.getElementById('currentCommand').textContent = 'æˆæ›²è¡¨æƒ…ä¸ªäººæ ¡å‡†ä¸­...';
            document.getElementById('operaInstruction').textContent = 'è¯·ä¿æŒè‡ªç„¶ä¸­æ€§è¡¨æƒ…ï¼Œå»ºç«‹ä¸ªäººåŸºçº¿';
            
            // TTSæç¤º
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance('è¯·ä¿æŒè‡ªç„¶è¡¨æƒ…ä¸¤ç§’é’Ÿï¼Œè¿›è¡Œæˆæ›²è¡¨æ¼”ä¸ªäººæ ¡å‡†');
                utterance.lang = 'zh-CN';
                speechSynthesis.speak(utterance);
            }
            
            // 2ç§’æ ¡å‡†æ—¶é—´
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // è®¡ç®—æˆæ›²åŸºçº¿
            if (metricsBuffer.length > 0) {
                const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
                if (validMetrics.length > 0) {
                    operaBaseline = calculateAverageMetrics(validMetrics);
                    document.getElementById('currentCommand').textContent = 'âœ… æˆæ›²è¡¨æƒ…ä¸ªäººæ ¡å‡†å®Œæˆï¼';
                    document.getElementById('operaInstruction').textContent = 'ç°åœ¨å¯ä»¥å¼€å§‹äº¬å‰§æ—¦è§’è¡¨æƒ…è®­ç»ƒ';
                    
                    updateTips(['æˆæ›²è¡¨æƒ…ä¸ªäººæ ¡å‡†å·²å®Œæˆï¼Œåç»­çš„çœ¼ç¥ã€èº«æ®µã€éŸµå‘³è¯„åˆ†å°†åŸºäºæ‚¨çš„ä¸ªäººåŸºçº¿ï¼Œæ›´åŠ å‡†ç¡®è´´åˆã€‚']);
                } else {
                    document.getElementById('currentCommand').textContent = 'âŒ æ ¡å‡†å¤±è´¥ï¼Œæœªæ£€æµ‹åˆ°é¢éƒ¨';
                    document.getElementById('operaInstruction').textContent = 'è¯·ç¡®ä¿æ‘„åƒå¤´èƒ½å¤Ÿæ¸…æ™°æ•æ‰åˆ°æ‚¨çš„é¢éƒ¨';
                }
            }
            
            isCalibrating = false;
            document.getElementById('calibrateBtn').disabled = false;
        }

        // ä¸‹ä¸€ä¸ªæˆæ›²è¡¨æƒ…
        function nextOperaExpression() {
            const select = document.getElementById('operaCommandSelect');
            const options = Array.from(select.options);
            const currentIndex = options.findIndex(opt => opt.selected);
            const nextIndex = (currentIndex + 1) % options.length;
            
            select.selectedIndex = nextIndex;
            updateUI();
            
            // éšè—ç»“æœåŒºåŸŸ
            document.getElementById('resultsSection').classList.remove('visible');
        }

        // æ›´æ–°UIçŠ¶æ€
        function updateUI() {
            const commandId = document.getElementById('operaCommandSelect').value;
            const command = OPERA_COMMANDS[commandId];
            
            if (command) {
                document.getElementById('currentCommand').textContent = `å‡†å¤‡ç»ƒä¹ ï¼š${command.name}`;
                document.getElementById('operaInstruction').textContent = command.instruction;
                
                // æ›´æ–°è¡¨æƒ…ç¤ºèŒƒå›¾ç‰‡
                updateExpressionDemo(commandId);
            }
            
            // æ›´æ–°æ ‡é¢˜æ˜¾ç¤º
            const roleText = currentRole === 'dan' ? 'æ—¦è§’' : 'é’è¡£';
            document.querySelector('.main-title').textContent = `äº¬å‰§${roleText}è¡¨æƒ…è®­ç»ƒ`;
        }
        
        // æ›´æ–°è¡¨æƒ…ç¤ºèŒƒ - ä½¿ç”¨AIç”Ÿæˆçš„Canvasç»˜åˆ¶
        function updateExpressionDemo(commandId) {
            const guideData = OPERA_EXPRESSION_GUIDES[commandId];
            const command = OPERA_COMMANDS[commandId];
            
            if (!guideData || !command) return;
            
            // æ›´æ–°è¡¨æƒ…åç§°å’Œæè¿°
            document.getElementById('demoExpressionName').textContent = command.name;
            document.getElementById('demoExpressionDesc').textContent = guideData.description;
            
            // æ›´æ–°Canvasç¤ºèŒƒ
            const imageFrame = document.getElementById('demoImageFrame');
            
            // æ¸…ç©ºå½“å‰å†…å®¹
            imageFrame.innerHTML = '';
            
            // åˆ›å»ºCanvaså…ƒç´ 
            const canvas = document.createElement('canvas');
            canvas.className = 'demo-canvas';
            canvas.width = 200;
            canvas.height = 200;
            canvas.alt = `${command.name}AIç¤ºèŒƒ`;
            
            // æ·»åŠ åˆ°DOM
            imageFrame.appendChild(canvas);
            
            // ç»˜åˆ¶è¡¨æƒ…ç¤ºèŒƒ
            try {
                guideData.drawFunction(canvas);
                
                // æ·»åŠ æ·¡å…¥åŠ¨ç”»æ•ˆæœ
                canvas.style.opacity = '0';
                canvas.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    canvas.style.opacity = '1';
                }, 100);
                
                // æ·»åŠ ç‚¹å‡»äº¤äº’æ•ˆæœ
                canvas.addEventListener('click', () => {
                    // é‡æ–°ç»˜åˆ¶ï¼Œæ·»åŠ ä¸€äº›åŠ¨æ€æ•ˆæœ
                    const ctx = canvas.getContext('2d');
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    guideData.drawFunction(canvas);
                    ctx.restore();
                    
                    setTimeout(() => {
                        guideData.drawFunction(canvas);
                    }, 200);
                });
                
            } catch (error) {
                console.error('ç»˜åˆ¶è¡¨æƒ…ç¤ºèŒƒå¤±è´¥:', error);
                // é™çº§å¤„ç†ï¼šæ˜¾ç¤ºæ–‡å­—æç¤º
                imageFrame.innerHTML = `
                    <div class="demo-placeholder">
                        <div style="font-size: 48px;">ğŸ­</div>
                        <div class="demo-placeholder-text">${command.name}</div>
                        <div style="font-size: 12px; margin-top: 5px;">AIç¤ºèŒƒåŠ è½½ä¸­...</div>
                    </div>
                `;
            }
        }

        // è¾…åŠ©å‡½æ•°
        function getCurrentCommandId() {
            return document.getElementById('operaCommandSelect').value;
        }

        function getCurrentTarget() {
            const commandId = getCurrentCommandId();
            return OPERA_COMMANDS[commandId] ? OPERA_COMMANDS[commandId].target : 'neutral';
        }
    </script>
</body>
</html>