<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Facial Expression Coach - Professional</title>
    <!--
    Local setup instructions:
    1. Camera requires HTTPS or localhost, use the following command to start local server:
       python -m http.server 8000
       Then visit http://localhost:8000
    
    2. Or use Python 3:
       python3 -m http.server 8000
       
    3. All processing is done locally, no image or video data is uploaded
    -->
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Step container styles */
        .step-container {
            display: none;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border-radius: 24px;
            padding: 40px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        
        .step-container.active {
            display: block;
            animation: slideInUp 0.6s ease-out;
        }
        
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Step titles */
        .step-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .step-subtitle {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 30px;
        }
        
        /* Step progress indicator */
        .step-progress {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 40px;
            gap: 20px;
        }
        
        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        
        .progress-dot.active {
            background: #4ecdc4;
            transform: scale(1.5);
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.6);
        }
        
        .progress-dot.completed {
            background: #96ceb4;
        }
        
        /* Welcome screen */
        .welcome-content {
            max-width: 600px;
            margin: 0 auto;
        }
        
        .welcome-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .feature-list {
            text-align: left;
            margin: 30px 0;
            background: rgba(0, 0, 0, 0.2);
            padding: 25px;
            border-radius: 16px;
        }
        
        .feature-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            font-size: 16px;
        }
        
        .feature-icon {
            font-size: 24px;
            margin-right: 15px;
            width: 40px;
        }
        
        /* Setup screen */
        .mode-selection {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        
        .mode-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .mode-card:hover {
            transform: translateY(-5px);
            border-color: #4ecdc4;
            box-shadow: 0 10px 30px rgba(78, 205, 196, 0.3);
        }
        
        .mode-card.selected {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.2);
        }
        
        .mode-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .mode-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .mode-description {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.5;
        }
        
        /* Calibration screen */
        .calibration-content {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 0 auto 30px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        .beauty-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            z-index: 20;
        }
        
        .beauty-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .beauty-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .beauty-switch.active {
            background: #4ecdc4;
        }
        
        .beauty-switch-knob {
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
        }
        
        .beauty-switch.active .beauty-switch-knob {
            transform: translateX(24px);
        }
        
        .beauty-label {
            font-size: 12px;
            color: #fff;
            font-weight: 500;
        }
        
        .beauty-slider {
            display: none;
            margin-bottom: 8px;
        }
        
        .beauty-slider.active {
            display: block;
        }
        
        .beauty-slider input {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .beauty-slider input::-webkit-slider-thumb {
            width: 14px;
            height: 14px;
            background: #4ecdc4;
            border-radius: 50%;
            cursor: pointer;
            -webkit-appearance: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .beauty-slider-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 4px;
        }
        
        .video-wrapper {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
        }
        
        #videoElement,
        #videoElement2,
        #videoElement3 {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        #videoElement,
        #videoElement2,
        #videoElement3,
        #beautifiedCanvas,
        #beautifiedCanvas2,
        #beautifiedCanvas3 {
            transform: scaleX(-1);
        }
        
        #beautifiedCanvas,
        #beautifiedCanvas2,
        #beautifiedCanvas3 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 2;
            pointer-events: none;
        }
        
        #overlayCanvas,
        #overlayCanvas2,
        #overlayCanvas3 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }
        
        .video-status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .countdown-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: bold;
            color: #4ecdc4;
            text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.8);
            z-index: 10;
            display: none;
        }
        
        .countdown-overlay.show {
            display: block;
            animation: countdownPulse 1s ease-out;
        }
        
        @keyframes countdownPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        /* Training screen */
        .training-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 40px;
            align-items: start;
        }
        
        @media (max-width: 1200px) {
            .training-content {
                grid-template-columns: 1fr;
            }
        }
        
        .expression-guide {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
        }
        
        .expression-demo {
            font-size: 80px;
            margin-bottom: 20px;
            animation: expressionDemo 2s ease-in-out infinite;
        }
        
        @keyframes expressionDemo {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .expression-text {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #4ecdc4;
        }
        
        .expression-tips {
            font-size: 16px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 30px;
        }
        
        .training-progress {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            height: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .training-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #45b7d1);
            width: 0%;
            transition: width 0.1s ease;
        }
        
        /* Results screen */
        .results-content {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .score-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .score-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 25px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .score-card.excellent {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.2);
        }
        
        .score-card.good {
            border-color: #45b7d1;
            background: rgba(69, 183, 209, 0.2);
        }
        
        .score-card.needs-work {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
        }
        
        .score-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .score-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
        }
        
        .score-value {
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .score-change {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .feedback-section {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .feedback-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #4ecdc4;
        }
        
        .feedback-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }
        
        .feedback-icon {
            font-size: 20px;
            margin-right: 15px;
            margin-top: 2px;
        }
        
        .feedback-text {
            flex: 1;
            line-height: 1.5;
        }
        
        /* Button styles */
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            color: #ffffff;
            min-width: 200px;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .btn-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }
        
        /* Generate video button special styles */
        #makeShareVideoBtn {
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e);
            font-size: 18px;
            padding: 18px 35px;
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.3);
        }
        
        #makeShareVideoBtn:hover {
            background: linear-gradient(45deg, #ff5252, #ff7979);
            box-shadow: 0 6px 25px rgba(255, 107, 107, 0.4);
        }
        
        /* Animations and effects */
        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #4ecdc4;
            animation: confetti 3s ease-out forwards;
        }
        
        @keyframes confetti {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
        
        /* Status indicator */
        .status-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .status-ready {
            background: rgba(150, 206, 180, 0.9);
            color: #ffffff;
        }
        
        .status-running {
            background: rgba(78, 205, 196, 0.9);
            color: #ffffff;
            animation: pulse 1.5s infinite;
        }
        
        .status-error {
            background: rgba(255, 107, 107, 0.9);
            color: #ffffff;
        }
        
        /* Language switcher */
        .language-switcher {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
        }
        
        .lang-link {
            display: inline-block;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            color: #ffffff;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .lang-link:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .app-container {
                padding: 15px;
            }
            
            .step-container {
                padding: 25px;
            }
            
            .step-title {
                font-size: 24px;
            }
            
            .mode-selection {
                grid-template-columns: 1fr;
            }
            
            .training-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .score-display {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Language switcher -->
        <div class="language-switcher">
            <a href="./index-en.html" class="lang-link">üá∫üá∏ English</a>
        </div>
        
        <!-- Status indicator -->
        <div class="status-indicator" id="statusIndicator">Initializing...</div>
        
        <!-- Step 1: Welcome Screen -->
        <div class="step-container active" id="welcomeStep">
            <div class="step-progress">
                <div class="progress-dot active"></div>
                <div class="progress-dot"></div>
                <div class="progress-dot"></div>
                <div class="progress-dot"></div>
                <div class="progress-dot"></div>
            </div>
            
            <div class="welcome-content">
                <div class="welcome-icon">üé≠</div>
                <h1 class="step-title">Facial Expression Coach</h1>
                <p class="step-subtitle">AI-driven professional acting training system</p>
                
                <div class="feature-list">
                    <div class="feature-item">
                        <span class="feature-icon">üé¨</span>
                        <span>Film vs Stage Performance Mode</span>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">üìä</span>
                        <span>Four-dimensional professional scoring system</span>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">üéØ</span>
                        <span>Personalized Calibration & Feedback</span>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">‚ú®</span>
                        <span>Smart beauty filter, boost confidence</span>
                    </div>
                    <div class="feature-item">
                        <span class="feature-icon">üîí</span>
                        <span>Local computation, privacy protected</span>
                    </div>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="nextStep()">Start Training</button>
                </div>
            </div>
        </div>
        
        <!-- Step 2: Mode Selection -->
        <div class="step-container" id="modeStep">
            <div class="step-progress">
                <div class="progress-dot completed"></div>
                <div class="progress-dot active"></div>
                <div class="progress-dot"></div>
                <div class="progress-dot"></div>
                <div class="progress-dot"></div>
            </div>
            
            <h2 class="step-title">Choose Performance Mode</h2>
            <p class="step-subtitle">Different modes will affect scoring criteria and training focus</p>
            
            <div class="mode-selection">
                <div class="mode-card" onclick="selectMode('film')">
                    <div class="mode-icon">üé¨</div>
                    <div class="mode-title">Film Mode</div>
                    <div class="mode-description">
                        Suitable for close-up filming, focusing on subtle and natural expressions. Over-exaggeration will be penalized.
                    </div>
                </div>
                
                <div class="mode-card" onclick="selectMode('stage')">
                    <div class="mode-icon">üé≠</div>
                    <div class="mode-title">Stage Mode</div>
                    <div class="mode-description">
                        Suitable for stage performance, requiring clear and visible expression amplitude for audiences in the back rows.
                    </div>
                </div>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="prevStep()">Back</button>
                <button class="btn btn-primary" id="modeNextBtn" onclick="nextStep()" disabled>Next</button>
            </div>
        </div>
        
        <!-- Step 3: Camera Setup -->
        <div class="step-container" id="cameraStep">
            <div class="step-progress">
                <div class="progress-dot completed"></div>
                <div class="progress-dot completed"></div>
                <div class="progress-dot active"></div>
                <div class="progress-dot"></div>
                <div class="progress-dot"></div>
            </div>
            
            <h2 class="step-title">Camera Setup</h2>
            <p class="step-subtitle">Please allow camera access and ensure your face is clearly visible</p>
            
            <div class="calibration-content">
                <div class="video-container">
                    <div class="video-wrapper">
                        <video id="videoElement" autoplay muted playsinline></video>
                        <canvas id="beautifiedCanvas"></canvas>
                        <canvas id="overlayCanvas"></canvas>
                        <div class="video-status" id="videoStatus">Detecting...</div>
                        <div class="countdown-overlay" id="countdownOverlay">3</div>
                        
                        <div class="beauty-controls">
                            <div class="beauty-toggle">
                                <div class="beauty-switch" id="beautySwitch" onclick="toggleBeauty()">
                                    <div class="beauty-switch-knob"></div>
                                </div>
                                <span class="beauty-label">Beauty</span>
                            </div>
                            
                            
                            <div class="beauty-slider" id="smoothSlider">
                                <div class="beauty-slider-label">Smooth</div>
                                <input type="range" min="0" max="100" value="50" id="smoothRange" oninput="updateBeauty()">
                            </div>
                            
                            <div class="beauty-slider" id="brightnessSlider">
                                <div class="beauty-slider-label">Brightness</div>
                                <input type="range" min="-50" max="50" value="10" id="brightnessRange" oninput="updateBeauty()">
                            </div>
                            
                            <div class="beauty-slider" id="contrastSlider">
                                <div class="beauty-slider-label">Contrast</div>
                                <input type="range" min="-50" max="50" value="15" id="contrastRange" oninput="updateBeauty()">
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="feature-list" style="text-align: center;">
                    <div class="feature-item" style="justify-content: center;">
                        <span class="feature-icon">üí°</span>
                        <span>Ensure sufficient lighting and avoid backlight</span>
                    </div>
                    <div class="feature-item" style="justify-content: center;">
                        <span class="feature-icon">üë§</span>
                        <span>Keep facing the camera directly</span>
                    </div>
                    <div class="feature-item" style="justify-content: center;">
                        <span class="feature-icon">üìè</span>
                        <span>Head should occupy about 1/3 of the frame</span>
                    </div>
                </div>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="prevStep()">Back</button>
                <button class="btn btn-primary" id="cameraNextBtn" onclick="nextStep()" disabled>Start Calibration</button>
            </div>
        </div>
        
        <!-- Step 4: Personal Calibration -->
        <div class="step-container" id="calibrationStep">
            <div class="step-progress">
                <div class="progress-dot completed"></div>
                <div class="progress-dot completed"></div>
                <div class="progress-dot completed"></div>
                <div class="progress-dot active"></div>
                <div class="progress-dot"></div>
            </div>
            
            <h2 class="step-title">Personal Calibration</h2>
            <p class="step-subtitle">Keep a neutral expression for 2 seconds to establish your facial baseline</p>
            
            <div class="calibration-content">
                <div class="video-container">
                    <div class="video-wrapper">
                        <video id="videoElement2" autoplay muted playsinline></video>
                        <canvas id="beautifiedCanvas2"></canvas>
                        <canvas id="overlayCanvas2"></canvas>
                        <div class="video-status" id="videoStatus2">Ready to calibrate...</div>
                        <div class="countdown-overlay" id="countdownOverlay2">Ready</div>
                        
                        <div class="beauty-controls">
                            <div class="beauty-toggle">
                                <div class="beauty-switch" id="beautySwitch2" onclick="toggleBeauty()">
                                    <div class="beauty-switch-knob"></div>
                                </div>
                                <span class="beauty-label">Beauty</span>
                            </div>
                            
                            <div class="beauty-slider" id="smoothSlider2">
                                <div class="beauty-slider-label">Smooth</div>
                                <input type="range" min="0" max="100" value="50" id="smoothRange2" oninput="updateBeauty()">
                            </div>
                            
                            <div class="beauty-slider" id="brightnessSlider2">
                                <div class="beauty-slider-label">Brightness</div>
                                <input type="range" min="-50" max="50" value="10" id="brightnessRange2" oninput="updateBeauty()">
                            </div>
                            
                            <div class="beauty-slider" id="contrastSlider2">
                                <div class="beauty-slider-label">Contrast</div>
                                <input type="range" min="-50" max="50" value="15" id="contrastRange2" oninput="updateBeauty()">
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="training-progress">
                    <div class="training-progress-fill" id="calibrationProgress"></div>
                </div>
                
                <div id="calibrationInstructions" class="expression-tips">
                    Keep a relaxed neutral expression, do not smile or frown
                </div>
            </div>
            
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="prevStep()">Back</button>
                <button class="btn btn-primary" id="calibrationBtn" onclick="startCalibration()">Start Calibration</button>
            </div>
        </div>
        
        <!-- Step 5: Expression Training -->
        <div class="step-container" id="trainingStep">
            <div class="step-progress">
                <div class="progress-dot completed"></div>
                <div class="progress-dot completed"></div>
                <div class="progress-dot completed"></div>
                <div class="progress-dot completed"></div>
                <div class="progress-dot active"></div>
            </div>
            
            <h2 class="step-title">Expression Training</h2>
            <p class="step-subtitle" id="trainingSubtitle">Follow the guidance to complete expression practice</p>
            
            <div class="training-content">
                <div class="video-container">
                    <div class="video-wrapper">
                        <video id="videoElement3" autoplay muted playsinline></video>
                        <canvas id="beautifiedCanvas3"></canvas>
                        <canvas id="overlayCanvas3"></canvas>
                        <div class="video-status" id="videoStatus3">Ready to train...</div>
                        <div class="countdown-overlay" id="countdownOverlay3">3</div>
                        
                        <div class="beauty-controls">
                            <div class="beauty-toggle">
                                <div class="beauty-switch" id="beautySwitch3" onclick="toggleBeauty()">
                                    <div class="beauty-switch-knob"></div>
                                </div>
                                <span class="beauty-label">Beauty</span>
                            </div>
                            
                            <div class="beauty-slider" id="smoothSlider3">
                                <div class="beauty-slider-label">Smooth</div>
                                <input type="range" min="0" max="100" value="50" id="smoothRange3" oninput="updateBeauty()">
                            </div>
                            
                            <div class="beauty-slider" id="brightnessSlider3">
                                <div class="beauty-slider-label">Brightness</div>
                                <input type="range" min="-50" max="50" value="10" id="brightnessRange3" oninput="updateBeauty()">
                            </div>
                            
                            <div class="beauty-slider" id="contrastSlider3">
                                <div class="beauty-slider-label">Contrast</div>
                                <input type="range" min="-50" max="50" value="15" id="contrastRange3" oninput="updateBeauty()">
                            </div>
                        </div>
                    </div>
                    
                    <div class="training-progress">
                        <div class="training-progress-fill" id="trainingProgress"></div>
                    </div>
                </div>
                
                <div class="expression-guide">
                    <div class="expression-demo" id="expressionDemo">üòä</div>
                    <div class="expression-text" id="expressionText">Natural Smile</div>
                    <div class="expression-tips" id="expressionTips">
                        Naturally lift the corners of your mouth, hold for 2 seconds
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-secondary" id="skipBtn" onclick="nextExpression()">Skip</button>
                        <button class="btn btn-primary" id="startTrainingBtn" onclick="startExpression()">Start</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Results screen -->
        <div class="step-container" id="resultsStep">
            <h2 class="step-title">Training Results</h2>
            <p class="step-subtitle" id="resultSubtitle">Your Performance in Film Mode</p>
            
            <div class="results-content">
                <div class="score-display">
                    <div class="score-card" id="clarityCard">
                        <div class="score-icon">üéØ</div>
                        <div class="score-label">Clarity</div>
                        <div class="score-value" id="clarityValue">85</div>
                        <div class="score-change" id="clarityChange">+5</div>
                    </div>
                    
                    <div class="score-card" id="consistencyCard">
                        <div class="score-icon">‚öñÔ∏è</div>
                        <div class="score-label">Consistency</div>
                        <div class="score-value" id="consistencyValue">92</div>
                        <div class="score-change" id="consistencyChange">+3</div>
                    </div>
                    
                    <div class="score-card" id="intensityCard">
                        <div class="score-icon">‚ö°</div>
                        <div class="score-label">Intensity</div>
                        <div class="score-value" id="intensityValue">78</div>
                        <div class="score-change" id="intensityChange">-2</div>
                    </div>
                    
                    <div class="score-card" id="truthCard">
                        <div class="score-icon">üí´</div>
                        <div class="score-label">Truth</div>
                        <div class="score-value" id="truthValue">88</div>
                        <div class="score-change" id="truthChange">+7</div>
                    </div>
                </div>
                
                <div class="feedback-section">
                    <div class="feedback-title">üí° Professional Guidance</div>
                    <div id="feedbackContainer">
                        <div class="feedback-item">
                            <div class="feedback-icon">‚ú®</div>
                            <div class="feedback-text">Excellent performance! Your expressions are natural and authentic, keep up this state.</div>
                        </div>
                        <div class="feedback-item">
                            <div class="feedback-icon">üé≠</div>
                            <div class="feedback-text">Good grasp of film performance style, you can try more challenging expressions.</div>
                        </div>
                    </div>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-primary" id="makeShareVideoBtn">üì∏ Create Photo Video</button>
                </div>
                
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="restartTraining()">üîÑ Retrain</button>
                    <button class="btn btn-primary" onclick="continueTraining()">‚ûï Continue Practice</button>
                </div>
            </div>
        </div>
        
        <!-- Celebration animation container -->
        <div class="celebration" id="celebrationContainer"></div>
    </div>

    <script>
        // Training command configuration
        const TRAINING_COMMANDS = {
            smile_natural: {
                id: "smile_natural",
                text: "Please make a natural smile and hold for two seconds",
                emoji: "üòä",
                tips: "Naturally lift the corners of your mouth, gentle eyes",
                tts: true,
                duration: 2000,
                target: "smile",
                duchenne: false,
                difficulty: "E"
            },
            smile_duchenne: {
                id: "smile_duchenne", 
                text: "Please make a Duchenne smile and hold for two seconds",
                emoji: "üòÑ",
                tips: "Eyes slightly squinted, mouth corners up, genuine joy",
                tts: true,
                duration: 2000,
                target: "smile",
                duchenne: true,
                difficulty: "M"
            },
            surprised: {
                id: "surprised",
                text: "Please make a surprised expression",
                emoji: "üòÆ",
                tips: "Open mouth wide with raised eyebrows",
                tts: true,
                duration: 1500,
                target: "surprised",
                duchenne: false,
                difficulty: "M"
            },
            sad: {
                id: "sad",
                text: "Please make a sad expression",
                emoji: "üò¢",
                tips: "Furrow brows, mouth corners down",
                tts: true,
                duration: 2000,
                target: "sad",
                duchenne: false,
                difficulty: "H"
            },
            angry: {
                id: "angry",
                text: "Please make an angry expression",
                emoji: "üò†",
                tips: "Lower eyebrows, focused gaze",
                tts: true,
                duration: 2000,
                target: "angry",
                duchenne: false,
                difficulty: "H"
            }
        };

        // Global variables
        let faceMesh;
        let camera;
        let currentStep = 0;
        let selectedMode = null;
        let isRunning = false;
        let isCalibrating = false;
        let currentSession = null;
        let baseline = null;
        let metricsBuffer = [];
        let lastFrameTime = 0;
        let frameCount = 0;
        let currentExpressionIndex = 0;
        let trainingSequence = ['smile_natural', 'smile_duchenne', 'surprised', 'sad', 'angry'];
        let countdownTimer = null;
        let trainingTimer = null;
        
        // Beauty filter related variables
        let beautyEnabled = false;
        let beautySettings = {
            smooth: 50,
            brightness: 10,
            contrast: 15
        };
        
        // DOM element references
        const steps = ['welcomeStep', 'modeStep', 'cameraStep', 'calibrationStep', 'trainingStep'];
        const videoElements = ['videoElement', 'videoElement2', 'videoElement3'];
        const overlayCanvases = ['overlayCanvas', 'overlayCanvas2', 'overlayCanvas3'];
        
        // MediaPipe landmark indices
        const LANDMARKS = {
            MOUTH: {
                LEFT_CORNER: 61,
                RIGHT_CORNER: 291,
                TOP: 13,
                BOTTOM: 14,
                UPPER_LIP: [12, 15, 16, 17, 18, 200],
                LOWER_LIP: [146, 91, 181, 84, 17, 314, 405, 320, 307, 375]
            },
            LEFT_EYE: {
                TOP: 159,
                BOTTOM: 145,
                LEFT: 33,
                RIGHT: 133,
                OUTLINE: [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246]
            },
            RIGHT_EYE: {
                TOP: 386,
                BOTTOM: 374,
                LEFT: 362,
                RIGHT: 263,
                OUTLINE: [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398]
            },
            LEFT_EYEBROW: {
                INNER: 55,
                OUTER: 46,
                CENTER: 70
            },
            RIGHT_EYEBROW: {
                INNER: 285,
                OUTER: 276,
                CENTER: 300
            },
            NOSE_TIP: 1
        };

        // Step navigation functions
        async function nextStep() {
            if (currentStep < steps.length - 1) {
                document.getElementById(steps[currentStep]).classList.remove('active');
                currentStep++;
                document.getElementById(steps[currentStep]).classList.add('active');
                
                // Special handling
                if (currentStep === 2) { // Camera setup step
                    initializeCamera();
                } else if (currentStep === 3) { // Calibration step
                    await setupCalibrationVideo();
                } else if (currentStep === 4) { // Training step
                    await setupTrainingVideo();
                }
            }
        }

        function prevStep() {
            if (currentStep > 0) {
                document.getElementById(steps[currentStep]).classList.remove('active');
                currentStep--;
                document.getElementById(steps[currentStep]).classList.add('active');
            }
        }

        // Mode selection
        function selectMode(mode) {
            selectedMode = mode;
            
            // Update UI
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            event.target.closest('.mode-card').classList.add('selected');
            document.getElementById('modeNextBtn').disabled = false;
        }

        // Status update
        function updateStatus(message, type = 'ready') {
            const indicator = document.getElementById('statusIndicator');
            indicator.textContent = message;
            indicator.className = `status-indicator status-${type}`;
        }

        // Camera initialization
        async function initializeCamera() {
            try {
                updateStatus('Starting camera...', 'running');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: 640, 
                        height: 480,
                        facingMode: 'user'
                    }
                });
                
                // Set stream for all video elements
                videoElements.forEach(id => {
                    const video = document.getElementById(id);
                    if (video) {
                        video.srcObject = stream;
                        video.onloadedmetadata = () => {
                            const canvasId = id.replace('videoElement', 'overlayCanvas') || 'overlayCanvas';
                            const canvas = document.getElementById(canvasId);
                            if (canvas) {
                                canvas.width = video.videoWidth;
                                canvas.height = video.videoHeight;
                            }
                        };
                    }
                });
                
                await initializeFaceMesh();
                updateStatus('Camera ready', 'ready');
                document.getElementById('cameraNextBtn').disabled = false;
                
            } catch (error) {
                console.error('Camera initialization failed:', error);
                updateStatus('Camera access failed', 'error');
            }
        }

        async function initializeFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onFaceMeshResults);

            // Initial camera settings for camera test step
            camera = new Camera(document.getElementById('videoElement'), {
                onFrame: async () => {
                    const video = document.getElementById('videoElement');
                    if (video && video.videoWidth > 0) {
                        await faceMesh.send({image: video});
                    }
                },
                width: 640,
                height: 480
            });

            camera.start();
        }

        function getCurrentVideo() {
            const activeStep = document.querySelector('.step-container.active');
            if (activeStep) {
                const video = activeStep.querySelector('video');
                if (isCalibrating && video) {
                    console.log('Getting video element during calibration:', video.id, 'from step:', activeStep.id);
                }
                return video;
            }
            return document.getElementById('videoElement');
        }
        
        function getCurrentProcessedCanvas() {
            const activeStep = document.querySelector('.step-container.active');
            if (activeStep) {
                const canvas = activeStep.querySelector('[id*="beautifiedCanvas"]');
                if (isCalibrating) {
                    console.log('Getting canvas during calibration:', canvas ? canvas.id : 'null', 'activeStep:', activeStep.id);
                }
                return canvas;
            }
            return document.getElementById('beautifiedCanvas');
        }

        function getCurrentCanvas() {
            const activeStep = document.querySelector('.step-container.active');
            if (activeStep) {
                const canvas = activeStep.querySelector('canvas');
                return canvas;
            }
            return document.getElementById('overlayCanvas');
        }

        function onFaceMeshResults(results) {
            const now = performance.now();
            
            // Debug: Check if MediaPipe is working during calibration
            if (isCalibrating && Math.random() < 0.1) { // 10% chance to print
                console.log('MediaPipe onFaceMeshResults called, landmarks:', results.multiFaceLandmarks?.length || 0);
            }
            
            // Update FPS (simplified version)
            frameCount++;
            if (now - lastFrameTime >= 1000) {
                lastFrameTime = now;
                frameCount = 0;
            }

            // Get current active canvas
            const canvas = getCurrentCanvas();
            if (!canvas) {
                if (isCalibrating) {
                    console.error('Unable to get current canvas during calibration');
                }
                return;
            }
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // Draw overlay
                drawOverlay(ctx, landmarks, canvas);
                
                // Extract features
                const metrics = extractMetrics(landmarks);
                
                // Collect training data
                if ((isRunning || isCalibrating) && metrics) {
                    metricsBuffer.push({
                        timestamp: now,
                        metrics: metrics
                    });
                    
                    // Debug info
                    if (isCalibrating && metricsBuffer.length % 5 === 0) {
                        console.log(`Calibration in progress, collected ${metricsBuffer.length} data points`, metrics);
                    }
                } else if (isCalibrating) {
                    // Debug: If calibrating but no data collected
                    console.log('Calibrating but no valid data collected, metrics:', metrics);
                }
                
                // Update video status
                updateVideoStatus(true);
            } else {
                // Debug: No face detected during calibration
                if (isCalibrating) {
                    console.log('No facial landmarks detected during calibration');
                }
                updateVideoStatus(false);
            }
        }

        function updateVideoStatus(faceDetected) {
            const activeStep = document.querySelector('.step-container.active');
            if (activeStep) {
                const statusElement = activeStep.querySelector('.video-status');
                if (statusElement) {
                    statusElement.textContent = faceDetected ? 'Face Detected' : 'No Face Detected';
                    statusElement.style.color = faceDetected ? '#4ecdc4' : '#ff6b6b';
                }
            }
        }

        // Draw overlay
        function drawOverlay(ctx, landmarks, canvas) {
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;

            // Draw mouth outline
            drawLandmarkContour(ctx, LANDMARKS.MOUTH.UPPER_LIP, landmarks, canvas, '#4ecdc4');
            drawLandmarkContour(ctx, LANDMARKS.MOUTH.LOWER_LIP, landmarks, canvas, '#4ecdc4');

            // Draw eye outline
            drawLandmarkContour(ctx, LANDMARKS.LEFT_EYE.OUTLINE, landmarks, canvas, '#45b7d1');
            drawLandmarkContour(ctx, LANDMARKS.RIGHT_EYE.OUTLINE, landmarks, canvas, '#45b7d1');
        }

        function drawLandmarkContour(ctx, indices, landmarks, canvas, color) {
            if (!indices || !landmarks) return;
            
            ctx.strokeStyle = color;
            ctx.beginPath();
            
            let started = false;
            indices.forEach(idx => {
                if (landmarks[idx]) {
                    const point = landmarks[idx];
                    const x = point.x * canvas.width;
                    const y = point.y * canvas.height;
                    
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            });
            
            ctx.closePath();
            ctx.stroke();
        }

        // Feature extraction (simplified version)
        function extractMetrics(landmarks) {
            if (!landmarks || landmarks.length < 468) return null;

            try {
                const mouth = {
                    leftCorner: landmarks[LANDMARKS.MOUTH.LEFT_CORNER],
                    rightCorner: landmarks[LANDMARKS.MOUTH.RIGHT_CORNER], 
                    top: landmarks[LANDMARKS.MOUTH.TOP],
                    bottom: landmarks[LANDMARKS.MOUTH.BOTTOM]
                };

                const eyes = {
                    leftTop: landmarks[LANDMARKS.LEFT_EYE.TOP],
                    leftBottom: landmarks[LANDMARKS.LEFT_EYE.BOTTOM],
                    rightTop: landmarks[LANDMARKS.RIGHT_EYE.TOP],
                    rightBottom: landmarks[LANDMARKS.RIGHT_EYE.BOTTOM]
                };

                const distance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                const mouthWidth = distance(mouth.leftCorner, mouth.rightCorner);
                const mouthHeight = distance(mouth.top, mouth.bottom);
                const mouthRatio = mouthWidth / (mouthHeight + 0.001);
                const mouthOpen = mouthHeight / (mouthWidth + 0.001);

                const leftEAR = distance(eyes.leftTop, eyes.leftBottom) / distance(landmarks[LANDMARKS.LEFT_EYE.LEFT], landmarks[LANDMARKS.LEFT_EYE.RIGHT]);
                const rightEAR = distance(eyes.rightTop, eyes.rightBottom) / distance(landmarks[LANDMARKS.RIGHT_EYE.LEFT], landmarks[LANDMARKS.RIGHT_EYE.RIGHT]);
                const eyeEAR = (leftEAR + rightEAR) / 2;

                return {
                    mouthRatio,
                    mouthOpen,
                    eyeEAR,
                    symMouth: 1 - Math.min(1, Math.abs(mouth.leftCorner.y - mouth.rightCorner.y) * 1000),
                    poseYawProxy: 1 - Math.min(1, Math.abs(landmarks[LANDMARKS.NOSE_TIP].x - 0.5) * 2),
                    illumScore: 0.8 // Simplified
                };
            } catch (error) {
                console.error('Feature extraction failed:', error);
                return null;
            }
        }

        // Calibration function
        async function setupCalibrationVideo() {
            // Calibration page video setup
            document.getElementById('calibrationInstructions').textContent = 'Keep a relaxed neutral expression, do not smile or frown';
            
            // Force restart camera and bind to calibration video element
            if (camera) {
                camera.stop();
            }
            
            // Recreate camera for calibration step
            camera = new Camera(document.getElementById('videoElement2'), {
                onFrame: async () => {
                    const video = document.getElementById('videoElement2');
                    if (video && video.videoWidth > 0) {
                        if (isCalibrating && Math.random() < 0.05) {
                            console.log('Sending frame to MediaPipe during calibration, video size:', video.videoWidth, 'x', video.videoHeight);
                        }
                        await faceMesh.send({image: video});
                    } else if (isCalibrating) {
                        console.warn('Video element not ready during calibration:', video ? 'no width' : 'no video');
                    }
                },
                width: 640,
                height: 480
            });
            
            camera.start();
            renderBeautifiedVideo();
            
            console.log('Calibration page setup complete');
        }

        function startCalibration() {
            if (isCalibrating) return;
            
            console.log('Starting calibration process...');
            console.log('MediaPipe status - faceMesh:', !!faceMesh, 'camera:', !!camera);
            console.log('Current video element status:', document.getElementById('videoElement2')?.videoWidth || 'N/A');
            
            isCalibrating = true;
            metricsBuffer = [];
            
            document.getElementById('calibrationBtn').disabled = true;
            updateStatus('Calibrating...', 'running');
            
            // Countdown
            let countdown = 3;
            const countdownElement = document.getElementById('countdownOverlay2');
            const progressElement = document.getElementById('calibrationProgress');
            
            countdownElement.textContent = countdown;
            countdownElement.classList.add('show');
            
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownElement.textContent = countdown;
                } else {
                    countdownElement.textContent = 'Start';
                    clearInterval(countdownInterval);
                    
                    // Start calibration
                    setTimeout(() => {
                        countdownElement.classList.remove('show');
                        startCalibrationCapture();
                    }, 500);
                }
            }, 1000);
        }

        function startCalibrationCapture() {
            const duration = 2000;
            const startTime = performance.now();
            const progressElement = document.getElementById('calibrationProgress');
            
            const updateProgress = () => {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(100, (elapsed / duration) * 100);
                progressElement.style.width = `${progress}%`;
                
                if (elapsed < duration) {
                    requestAnimationFrame(updateProgress);
                } else {
                    finishCalibration();
                }
            };
            
            updateProgress();
        }

        function finishCalibration() {
            isCalibrating = false;
            
            console.log(`Calibration ended, collected ${metricsBuffer.length} data points`);
            
            if (metricsBuffer.length > 0) {
                baseline = calculateBaseline(metricsBuffer);
                console.log('Calculated baseline data:', baseline);
                updateStatus('Calibration completed', 'ready');
                
                // Show success and auto proceed to next step
                document.getElementById('calibrationInstructions').innerHTML = 
                    '‚úÖ Calibration successful! Established your personal facial baseline<br>You can now start expression training';
                
                setTimeout(() => {
                    nextStep();
                }, 2000);
                
            } else {
                console.error('Calibration failed: No facial data collected');
                updateStatus('Calibration failed', 'error');
                document.getElementById('calibrationBtn').disabled = false;
                document.getElementById('calibrationInstructions').textContent = 'No face detected, please retry calibration';
            }
        }

        function calculateBaseline(buffer) {
            const metrics = buffer.map(item => item.metrics).filter(m => m !== null);
            if (metrics.length === 0) return null;
            
            const average = arr => arr.reduce((sum, val) => sum + val, 0) / arr.length;
            
            return {
                mouthRatio: average(metrics.map(m => m.mouthRatio)),
                eyeEAR: average(metrics.map(m => m.eyeEAR)),
                mouthOpen: average(metrics.map(m => m.mouthOpen))
            };
        }

        // Training function
        async function setupTrainingVideo() {
            // Training page video setup - recreate camera for training step
            if (camera) {
                camera.stop();
            }
            
            // Recreate camera for training step
            camera = new Camera(document.getElementById('videoElement3'), {
                onFrame: async () => {
                    const video = document.getElementById('videoElement3');
                    if (video && video.videoWidth > 0) {
                        await faceMesh.send({image: video});
                    }
                },
                width: 640,
                height: 480
            });
            
            camera.start();
            loadCurrentExpression();
        }

        function loadCurrentExpression() {
            const commandId = trainingSequence[currentExpressionIndex];
            const command = TRAINING_COMMANDS[commandId];
            
            if (!command) {
                // Training completed, show results
                showFinalResults();
                return;
            }
            
            document.getElementById('expressionDemo').textContent = command.emoji;
            document.getElementById('expressionText').textContent = command.text.replace('Please make a ', '').replace(' and hold for two seconds', '').replace(' and hold for one and a half seconds', '');
            document.getElementById('expressionTips').textContent = command.tips;
            document.getElementById('trainingSubtitle').textContent = `Expression ${currentExpressionIndex + 1}/${trainingSequence.length}: ${command.text.replace('Please make a ', '').replace(' and hold for two seconds', '').replace(' and hold for one and a half seconds', '')}`;
            
            // Reset button state
            document.getElementById('startTrainingBtn').disabled = false;
            document.getElementById('startTrainingBtn').textContent = 'Start';
        }

        function startExpression() {
            if (isRunning) return;
            
            // Initialize photo capture function when starting training for the first time
            if (currentExpressionIndex === 0) {
                initPhotoCapture();
            }
            
            const commandId = trainingSequence[currentExpressionIndex];
            const command = TRAINING_COMMANDS[commandId];
            
            isRunning = true;
            metricsBuffer = [];
            
            document.getElementById('startTrainingBtn').disabled = true;
            document.getElementById('skipBtn').disabled = true;
            updateStatus('Training...', 'running');
            
            // TTS playback
            if (command.tts && 'speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(command.text);
                speechSynthesis.speak(utterance);
            }
            
            // Countdown
            let countdown = 3;
            const countdownElement = document.getElementById('countdownOverlay3');
            countdownElement.textContent = countdown;
            countdownElement.classList.add('show');
            
            countdownTimer = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownElement.textContent = countdown;
                } else {
                    countdownElement.textContent = 'Start!';
                    clearInterval(countdownTimer);
                    
                    setTimeout(() => {
                        countdownElement.classList.remove('show');
                        startExpressionCapture(command);
                    }, 500);
                }
            }, 1000);
        }

        function startExpressionCapture(command) {
            const duration = command.duration;
            const startTime = performance.now();
            const progressElement = document.getElementById('trainingProgress');
            
            currentSession = {
                mode: selectedMode,
                command: command,
                startTime: startTime
            };
            
            const updateProgress = () => {
                const elapsed = performance.now() - startTime;
                const progress = Math.min(100, (elapsed / duration) * 100);
                progressElement.style.width = `${progress}%`;
                
                if (elapsed < duration) {
                    requestAnimationFrame(updateProgress);
                } else {
                    finishExpression();
                }
            };
            
            updateProgress();
        }

        function finishExpression() {
            isRunning = false;
            currentSession.endTime = performance.now();
            
            // Capture photo of current expression
            capturePhoto();
            
            // Analyze results of this expression
            if (metricsBuffer.length > 0) {
                const result = analyzeExpression();
                showExpressionResult(result);
            }
            
            // Prepare next expression or complete training
            setTimeout(() => {
                currentExpressionIndex++;
                if (currentExpressionIndex < trainingSequence.length) {
                    loadCurrentExpression();
                } else {
                    showFinalResults();
                }
            }, 3000);
        }

        function nextExpression() {
            if (countdownTimer) clearInterval(countdownTimer);
            if (trainingTimer) clearInterval(trainingTimer);
            
            document.getElementById('countdownOverlay3').classList.remove('show');
            document.getElementById('trainingProgress').style.width = '0%';
            
            isRunning = false;
            currentExpressionIndex++;
            
            if (currentExpressionIndex < trainingSequence.length) {
                loadCurrentExpression();
            } else {
                showFinalResults();
            }
        }

        function analyzeExpression() {
            const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
            if (validMetrics.length === 0) return null;
            
            const average = arr => arr.reduce((sum, val) => sum + val, 0) / arr.length;
            
            const avgMetrics = {
                mouthRatio: average(validMetrics.map(m => m.mouthRatio)),
                eyeEAR: average(validMetrics.map(m => m.eyeEAR)),
                mouthOpen: average(validMetrics.map(m => m.mouthOpen)),
                symMouth: average(validMetrics.map(m => m.symMouth))
            };
            
            // Simplified scoring
            const scores = calculateSimpleScores(avgMetrics, currentSession.command.target);
            
            return {
                scores: scores,
                metrics: avgMetrics
            };
        }

        function calculateSimpleScores(metrics, target) {
            let match = 50;
            
            // Calculate match score based on expression type
            switch (target) {
                case 'smile':
                    const smileIntensity = baseline ? 
                        (metrics.mouthRatio - baseline.mouthRatio) : 
                        (metrics.mouthRatio - 2.5);
                    match = Math.max(0, Math.min(100, smileIntensity * 30 + 60));
                    break;
                    
                case 'surprised':
                    match = Math.max(0, Math.min(100, metrics.mouthOpen * 150 + 30));
                    break;
                    
                case 'sad':
                case 'angry':
                    match = Math.max(30, Math.min(90, 70 + Math.random() * 20));
                    break;
                    
                default:
                    match = Math.max(40, Math.min(90, 60 + Math.random() * 30));
            }
            
            return {
                clarity: Math.round(match + Math.random() * 10 - 5),
                consistency: Math.round(metrics.symMouth * 100),
                intensity: Math.round(Math.min(100, match * (selectedMode === 'stage' ? 1.1 : 0.9))),
                truth: Math.round(Math.max(60, match - 5 + Math.random() * 10))
            };
        }

        function showExpressionResult(result) {
            if (!result) return;
            
            const avgScore = (result.scores.clarity + result.scores.consistency + result.scores.intensity + result.scores.truth) / 4;
            
            // Update expression guidance area to show results
            document.getElementById('expressionDemo').textContent = avgScore > 80 ? 'üéâ' : avgScore > 60 ? 'üëç' : 'üí™';
            document.getElementById('expressionText').textContent = avgScore > 80 ? 'Excellent!' : avgScore > 60 ? 'Good!' : 'Keep trying!';
            document.getElementById('expressionTips').innerHTML = `
                Clarity: ${result.scores.clarity} | Consistency: ${result.scores.consistency}<br>
                Intensity: ${result.scores.intensity} | Truth: ${result.scores.truth}
            `;
            
            // If performance is excellent, play celebration animation
            if (avgScore > 85) {
                showCelebration();
            }
            
            updateStatus('Expression completed', 'ready');
            document.getElementById('skipBtn').disabled = false;
        }

        function showCelebration() {
            const container = document.getElementById('celebrationContainer');
            
            // Create ribbon effect
            for (let i = 0; i < 20; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.background = ['#4ecdc4', '#45b7d1', '#96ceb4', '#ff6b6b'][Math.floor(Math.random() * 4)];
                confetti.style.animationDelay = Math.random() * 2 + 's';
                container.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 3000);
            }
        }

        function showFinalResults() {
            // Training ended, save photos but don't redirect
            savePhotosOnly();
            
            // Switch to results page
            document.getElementById('trainingStep').classList.remove('active');
            document.getElementById('resultsStep').classList.add('active');
            
            // Update results data (simulated data)
            const results = {
                clarity: 78 + Math.floor(Math.random() * 20),
                consistency: 82 + Math.floor(Math.random() * 15),
                intensity: selectedMode === 'stage' ? 88 + Math.floor(Math.random() * 12) : 72 + Math.floor(Math.random() * 18),
                truth: 85 + Math.floor(Math.random() * 15)
            };
            
            updateResultsDisplay(results);
            generateFeedback(results);
            updateStatus('Training Complete', 'ready');
        }

        function updateResultsDisplay(results) {
            // Update score display
            document.getElementById('clarityValue').textContent = results.clarity;
            document.getElementById('consistencyValue').textContent = results.consistency;
            document.getElementById('intensityValue').textContent = results.intensity;
            document.getElementById('truthValue').textContent = results.truth;
            
            // Update score card styles
            updateScoreCard('clarityCard', results.clarity);
            updateScoreCard('consistencyCard', results.consistency);
            updateScoreCard('intensityCard', results.intensity);
            updateScoreCard('truthCard', results.truth);
            
            // Update mode display
            document.getElementById('resultSubtitle').textContent = 
                `Your Performance in ${selectedMode === 'film' ? 'Film' : 'Stage'} Mode`;
        }

        function updateScoreCard(cardId, score) {
            const card = document.getElementById(cardId);
            card.classList.remove('excellent', 'good', 'needs-work');
            
            if (score >= 85) {
                card.classList.add('excellent');
            } else if (score >= 70) {
                card.classList.add('good');
            } else {
                card.classList.add('needs-work');
            }
        }

        function generateFeedback(results) {
            const feedback = [];
            const avgScore = (results.clarity + results.consistency + results.intensity + results.truth) / 4;
            
            if (avgScore >= 85) {
                feedback.push({
                    icon: 'üéâ',
                    text: 'Excellent performance! Your expression control has reached professional level.'
                });
            } else if (avgScore >= 75) {
                feedback.push({
                    icon: 'üëç',
                    text: 'Good performance! Continue practicing for even greater improvement.'
                });
            } else {
                feedback.push({
                    icon: 'üí™',
                    text: 'Room for improvement. Suggest practicing basic expressions more.'
                });
            }
            
            if (results.intensity < 70 && selectedMode === 'stage') {
                feedback.push({
                    icon: 'üé≠',
                    text: 'Stage performance requires larger expression amplitude so that audiences in the back rows can see clearly.'
                });
            }
            
            if (results.intensity > 85 && selectedMode === 'film') {
                feedback.push({
                    icon: 'üé¨',
                    text: 'In film acting, being overly exaggerated may seem unnatural. Appropriate restraint would be better.'
                });
            }
            
            if (results.truth < 75) {
                feedback.push({
                    icon: 'üí´',
                    text: 'The authenticity of your expression needs improvement. Try to feel the emotion from within.'
                });
            }
            
            // Show feedback
            const container = document.getElementById('feedbackContainer');
            container.innerHTML = '';
            
            feedback.forEach(item => {
                const feedbackElement = document.createElement('div');
                feedbackElement.className = 'feedback-item';
                feedbackElement.innerHTML = `
                    <div class="feedback-icon">${item.icon}</div>
                    <div class="feedback-text">${item.text}</div>
                `;
                container.appendChild(feedbackElement);
            });
        }

        // Restart training
        function restartTraining() {
            currentExpressionIndex = 0;
            currentStep = 0;
            selectedMode = null;
            baseline = null;
            
            // Reset photo capture state
            capturedPhotos = [];
            if (photoCanvas) {
                photoCanvas = null;
            }
            
            // Reset UI
            document.getElementById('resultsStep').classList.remove('active');
            document.getElementById('welcomeStep').classList.add('active');
            
            // Reset mode selection
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.getElementById('modeNextBtn').disabled = true;
            
            updateStatus('Restart', 'ready');
        }

        // Continue training
        function continueTraining() {
            currentExpressionIndex = 0;
            
            // Return to training step
            document.getElementById('resultsStep').classList.remove('active');
            document.getElementById('trainingStep').classList.add('active');
            currentStep = 4;
            
            loadCurrentExpression();
            updateStatus('Continue training', 'ready');
        }

        // Beauty filter functions
        function toggleBeauty() {
            beautyEnabled = !beautyEnabled;
            
            // Only update beauty filter switch state, don't affect mirror switch
            const beautySwitch = document.getElementById('beautySwitch');
            if (beautySwitch) {
                if (beautyEnabled) {
                    beautySwitch.classList.add('active');
                } else {
                    beautySwitch.classList.remove('active');
                }
            }
            
            // Show/hide sliders
            document.querySelectorAll('.beauty-slider').forEach(slider => {
                if (beautyEnabled) {
                    slider.classList.add('active');
                } else {
                    slider.classList.remove('active');
                }
            });
            
            updateBeauty();
        }
        
        
        function updateBeauty() {
            if (!beautyEnabled) return;
            
            // Get current active step slider values
            const activeStep = document.querySelector('.step-container.active');
            if (activeStep) {
                const smoothRange = activeStep.querySelector('[id*="smoothRange"]');
                const brightnessRange = activeStep.querySelector('[id*="brightnessRange"]');
                const contrastRange = activeStep.querySelector('[id*="contrastRange"]');
                
                if (smoothRange) beautySettings.smooth = parseInt(smoothRange.value);
                if (brightnessRange) beautySettings.brightness = parseInt(brightnessRange.value);
                if (contrastRange) beautySettings.contrast = parseInt(contrastRange.value);
            }
        }
        
        function applyBeautyFilter(sourceCanvas, targetCanvas) {
            if (!beautyEnabled) {
                // If beauty filter is off, directly copy original image
                const sourceCtx = sourceCanvas.getContext('2d');
                const targetCtx = targetCanvas.getContext('2d');
                targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
                targetCtx.drawImage(sourceCanvas, 0, 0);
                return;
            }
            
            const sourceCtx = sourceCanvas.getContext('2d');
            const targetCtx = targetCanvas.getContext('2d');
            
            // Get image data
            const imageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
            const data = imageData.data;
            
            // Apply beauty effects
            for (let i = 0; i < data.length; i += 4) {
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];
                
                // Smoothing effect (simplified Gaussian blur)
                if (beautySettings.smooth > 0) {
                    const smoothFactor = beautySettings.smooth / 100 * 0.3;
                    r = r + (128 - r) * smoothFactor;
                    g = g + (128 - g) * smoothFactor;
                    b = b + (128 - b) * smoothFactor;
                }
                
                // Brightness adjustment
                const brightnessFactor = beautySettings.brightness / 50;
                r = Math.max(0, Math.min(255, r + brightnessFactor * 30));
                g = Math.max(0, Math.min(255, g + brightnessFactor * 30));
                b = Math.max(0, Math.min(255, b + brightnessFactor * 30));
                
                // Contrast adjustment
                const contrastFactor = (beautySettings.contrast + 50) / 50;
                r = Math.max(0, Math.min(255, (r - 128) * contrastFactor + 128));
                g = Math.max(0, Math.min(255, (g - 128) * contrastFactor + 128));
                b = Math.max(0, Math.min(255, (b - 128) * contrastFactor + 128));
                
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
            
            // Draw processed data to target canvas
            targetCtx.putImageData(imageData, 0, 0);
        }
        
        function renderBeautifiedVideo() {
            const activeStep = document.querySelector('.step-container.active');
            if (!activeStep) return;
            
            // Debug info
            if (isCalibrating && Math.random() < 0.01) { // 1% chance to print, avoid too many logs
                console.log('renderBeautifiedVideo running, activeStep:', activeStep.id);
            }
            
            const video = activeStep.querySelector('video');
            const beautifiedCanvas = activeStep.querySelector('[id*="beautifiedCanvas"]');
            
            if (!video || !beautifiedCanvas || video.videoWidth === 0) {
                requestAnimationFrame(renderBeautifiedVideo);
                return;
            }
            
            // Set canvas size
            if (beautifiedCanvas.width !== video.videoWidth) {
                beautifiedCanvas.width = video.videoWidth;
                beautifiedCanvas.height = video.videoHeight;
            }
            
            const ctx = beautifiedCanvas.getContext('2d');
            
            if (beautyEnabled) {
                // First draw video frame to temporary canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(video, 0, 0);
                
                // Apply beauty filter
                applyBeautyFilter(tempCanvas, beautifiedCanvas);
            } else {
                // Directly draw original video
                ctx.drawImage(video, 0, 0);
            }
            
            // Continue to next frame
            requestAnimationFrame(renderBeautifiedVideo);
        }

        // === Recording state ===
        // Photo capture related variables
        let capturedPhotos = [];
        let photoCanvas = null;
        let mixedStream;

        // If microphone capture is needed, set this to true (default false for video only)
        const ENABLE_MIC = false;

        // Use beautified canvas as video source (consistent with page: #beautifiedCanvas3)
        function getCanvasStream() {
            const canvas = document.getElementById('beautifiedCanvas3');
            // 30fps, adjustable as needed
            return canvas.captureStream(30);
        }

        function initPhotoCapture() {
            // Initialize photo capture function
            capturedPhotos = [];
            if (!photoCanvas) {
                photoCanvas = document.createElement('canvas');
            }
            console.log('Photo capture initialized');
        }
        
        function capturePhoto() {
            console.log('=== Starting photo capture ===');
            console.log('Current expression index:', currentExpressionIndex);
            console.log('Training sequence:', trainingSequence);
            console.log('Current expression ID:', trainingSequence[currentExpressionIndex]);
            
            // Get video element from current step
            const videoElement = document.getElementById('videoElement3');
            
            if (!videoElement) {
                console.warn('Video element videoElement3 not found');
                return null;
            }
            
            if (videoElement.videoWidth === 0) {
                console.warn('Video not loaded yet, width is 0');
                return null;
            }
            
            console.log('Video element ready, capturing photo...');
            
            // Set canvas size to match video
            photoCanvas.width = videoElement.videoWidth;
            photoCanvas.height = videoElement.videoHeight;
            
            const ctx = photoCanvas.getContext('2d');
            
            // Draw video frame to canvas (flip horizontally for mirror effect)
            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(videoElement, -photoCanvas.width, 0);
            ctx.restore();
            
            // Convert to base64
            const photoDataUrl = photoCanvas.toDataURL('image/jpeg', 0.85);
            
            // Store photo with expression info
            const photoData = {
                dataUrl: photoDataUrl,
                expressionIndex: currentExpressionIndex,
                expressionId: trainingSequence[currentExpressionIndex],
                expressionName: TRAINING_COMMANDS[trainingSequence[currentExpressionIndex]].text,
                timestamp: Date.now()
            };
            
            capturedPhotos.push(photoData);
            console.log(`‚úÖ Photo captured! Expression ${currentExpressionIndex}:`, trainingSequence[currentExpressionIndex]);
            console.log('Total photos captured:', capturedPhotos.length);
            console.log('Photo data size:', photoDataUrl.length, 'characters');
            
            return photoData;
        }

        function generateVideoFromPhotos() {
            // Save photo data to sessionStorage, redirect to share page
            if (capturedPhotos.length > 0) {
                sessionStorage.setItem('capturedPhotos', JSON.stringify(capturedPhotos));
                console.log(`Saved ${capturedPhotos.length} photos to sessionStorage`);
                window.location.href = 'video-share-en.html';
            } else {
                alert('No photos captured, please try training again');
            }
        }
        
        function savePhotosOnly() {
            // Only save photos, don't redirect
            if (capturedPhotos.length > 0) {
                sessionStorage.setItem('capturedPhotos', JSON.stringify(capturedPhotos));
                console.log(`Training completed, saved ${capturedPhotos.length} photos`);
            }
        }

        function blobToBase64(blob) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.readAsDataURL(blob); // data:URL(base64)
            });
        }

        // === Bind recording to "training start/end" ===
        // Start recording when user clicks "Start" to begin expression training; stop recording when training sequence completes and enters results.
        // If you already have training state machine in your code, please call at appropriate start/stop hooks: startRecording() / stopRecordingAndGo().
        // Temporary minimal implementation: start when clicking start training button; stop when showing results page (#resultsStep).
        (function wireRecording() {
            // Start button (English page id='startTrainingBtn'; Chinese page consistent or named "Start" button):
            const startBtn = document.getElementById('startTrainingBtn');
            if (startBtn) {
                startBtn.addEventListener('click', () => {
                    // Prevent multiple starts
                    if (!recorder || recorder.state === 'inactive') {
                        startRecording();
                    }
                }, { once: false });
            }

            // Comment out auto redirect, let user decide whether to generate video
            // const resultsStep = document.getElementById('resultsStep');
            // const observer = new MutationObserver(() => {
            //     if (resultsStep.classList.contains('active')) {
            //         stopRecordingAndGo();
            //     }
            // });
            // if (resultsStep) observer.observe(resultsStep, { attributes: true, attributeFilter: ['class'] });

            // Share video button event
            const shareBtn = document.getElementById('makeShareVideoBtn');
            if (shareBtn) {
                shareBtn.addEventListener('click', () => {
                    // User actively chooses to generate share video
                    generateVideoFromPhotos();
                });
            }
        })();

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            updateStatus('Welcome to Facial Expression Coach', 'ready');
            // Start beauty rendering loop
            renderBeautifiedVideo();
        });
    </script>
</body>
</html>