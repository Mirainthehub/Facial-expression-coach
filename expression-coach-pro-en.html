<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>表情训练教练 - 专业版</title>
    
    <!--
    本地运行说明：
    1. 摄像头需要 HTTPS 或 localhost 环境
    2. 使用 Python 启动本地服务：
       python -m http.server 8000
       然后访问 http://localhost:8000
    3. 或使用 Python 3:
       python3 -m http.server 8000
    4. 所有处理在本地完成，不上传任何图像或视频数据
    -->
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .app-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar main tips"
                "results results results";
            grid-template-rows: auto 1fr auto;
            grid-template-columns: 300px 1fr 350px;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }
        
        /* Header - Progress and Badges */
        .header {
            grid-area: header;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }
        .lang-switch {
            position: absolute;
            top: 14px;
            right: 16px;
            font-size: 12px;
            background: rgba(255,255,255,0.12);
            padding: 6px 10px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            text-decoration: none;
            color: #fff;
        }
        .lang-switch:hover { border-color: #4ecdc4; }
        
        .progress-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .total-score {
            font-size: 24px;
            font-weight: bold;
            color: #4ecdc4;
            min-width: 80px;
        }
        
        .progress-bar {
            flex: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #45b7d1);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .badges {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .badge {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .badge.excellent { border-color: #4ecdc4; background: rgba(78, 205, 196, 0.2); }
        .badge.good { border-color: #45b7d1; background: rgba(69, 183, 209, 0.2); }
        .badge.needs-work { border-color: #ff6b6b; background: rgba(255, 107, 107, 0.2); }
        
        .badge-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .badge-name {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .badge-score {
            font-size: 18px;
            font-weight: bold;
        }
        
        .tech-indicators {
            display: flex;
            justify-content: space-around;
            font-size: 11px;
            opacity: 0.7;
        }
        
        .tech-item {
            text-align: center;
        }
        
        /* Sidebar - Controls */
        .sidebar {
            grid-area: sidebar;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #4ecdc4;
        }
        
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .mode-option {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 12px;
        }
        
        .mode-option.active {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.2);
        }
        
        select, button {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:focus, button:hover {
            border-color: #4ecdc4;
            outline: none;
        }
        
        button {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .toggle-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 14px;
            opacity: 0.9;
        }
        .toggle-row input { accent-color: #4ecdc4; }
        
        .btn-primary {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            margin-bottom: 10px;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }
        
        /* Main Video Area */
        .main-area {
            grid-area: main;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
        }
        
        .video-status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
        }
        
        .training-info {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .current-command {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 5px;
        }
        
        .countdown {
            font-size: 36px;
            font-weight: bold;
            color: #ff6b6b;
            margin: 10px 0;
        }
        
        /* Tips Panel */
        .tips-panel {
            grid-area: tips;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .tips-title {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tip-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.4;
            border-left: 4px solid #4ecdc4;
        }

        /* Script Guide */
        .script-item {
            background: rgba(255, 255, 255, 0.08);
            padding: 14px;
            border-radius: 10px;
            border-left: 4px solid #feca57;
        }
        .script-meta {
            font-size: 12px;
            opacity: 0.85;
            margin-bottom: 8px;
            color: #feca57;
            font-weight: 600;
        }
        .script-excerpt {
            font-size: 15px;
            margin-bottom: 8px;
        }
        .script-note {
            font-size: 12px;
            opacity: 0.9;
        }
        .script-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        /* Results Section */
        .results {
            grid-area: results;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }
        
        .results.visible {
            display: block;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .results-title {
            font-size: 20px;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .amplitude-label {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .amplitude-subtle { color: #45b7d1; }
        .amplitude-medium { color: #4ecdc4; }
        .amplitude-exaggerated { color: #ff6b6b; }
        
        .charts-container {
            display: flex;
            gap: 20px;
        }
        
        .chart-section {
            flex: 1;
        }
        
        .chart-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        canvas.chart {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .app-container {
                grid-template-areas: 
                    "header"
                    "sidebar"
                    "main"
                    "tips"
                    "results";
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <a class="lang-switch" href="./expression-coach-pro.html">中文</a>
            <div class="progress-section">
                <div class="total-score" id="totalScore">0</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="badges">
                <div class="badge" id="clarityBadge">
                    <div class="badge-icon">🎯</div>
                    <div class="badge-name">Clarity</div>
                    <div class="badge-score" id="clarityScore">0</div>
                </div>
                <div class="badge" id="consistencyBadge">
                    <div class="badge-icon">⚖️</div>
                    <div class="badge-name">Consistency</div>
                    <div class="badge-score" id="consistencyScore">0</div>
                </div>
                <div class="badge" id="intensityBadge">
                    <div class="badge-icon">⚡</div>
                    <div class="badge-name">Intensity</div>
                    <div class="badge-score" id="intensityScore">0</div>
                </div>
                <div class="badge" id="truthBadge">
                    <div class="badge-icon">💫</div>
                    <div class="badge-name">Truth</div>
                    <div class="badge-score" id="truthScore">0</div>
                </div>
            </div>
            
            <div class="tech-indicators">
                <div class="tech-item">
                    <div>Match</div>
                    <div id="matchScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Symmetry</div>
                    <div id="symmetryScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Stability</div>
                    <div id="stabilityScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Aesthetics</div>
                    <div id="aestheticsScore">0</div>
                </div>
            </div>
        </div>
        
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="control-group">
                <label class="control-label">Performance Mode</label>
                <div class="mode-selector">
                    <div class="mode-option active" data-mode="film">
                        <div>🎬</div>
                        <div>Film</div>
                    </div>
                    <div class="mode-option" data-mode="stage">
                        <div>🎭</div>
                        <div>Stage</div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label" for="commandSelect">Training Prompt</label>
                <select id="commandSelect">
                    <option value="smile_natural">Natural Smile (2s)</option>
                    <option value="smile_duchenne">Duchenne Smile (2s)</option>
                    <option value="neutral">Neutral Face (2s)</option>
                    <option value="focus">Focused (2s)</option>
                    <option value="surprised">Surprised (1.5s)</option>
                    <option value="sad">Sad (2s)</option>
                    <option value="disgust">Disgust (2s)</option>
                    <option value="angry">Angry (2s)</option>
                </select>
            </div>
            
            <div class="control-group">
                <button class="btn-primary" id="startBtn">Start Training</button>
                <button class="btn-secondary" id="nextBtn">Next Expression</button>
                <button class="btn-secondary" id="calibrateBtn">Quick Calibrate</button>
                <button class="btn-secondary" id="resetCalibrateBtn">Reset Calibration</button>
            </div>

            <div class="control-group">
                <label class="control-label">Preferences</label>
                <div class="toggle-row"><input type="checkbox" id="toggleAutoTTS" checked> Auto TTS</div>
                <div class="toggle-row"><input type="checkbox" id="toggleMirror" checked> Mirror Video</div>
            </div>
        </div>
        
        <!-- Main Video Area -->
        <div class="main-area">
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="overlayCanvas"></canvas>
                <div class="video-status" id="videoStatus">Waiting for camera...</div>
            </div>
            
            <div class="training-info">
                <div class="current-command" id="currentCommand">Pick a prompt and press Start</div>
                <div class="countdown" id="countdown"></div>
            </div>
        </div>
        
        <!-- Tips Panel -->
        <div class="tips-panel">
            <div class="tips-title">
                <span>💡</span>
                <span>Acting Tips</span>
            </div>
            <div id="tipsContainer">
                <div class="tip-item">Choose a mode and target expression to begin.</div>
            </div>

            <div class="tips-title" style="margin-top:16px;">
                <span>📜</span>
                <span>Script Coach</span>
            </div>
            <div id="scriptGuideContainer" class="script-item">
                <div id="scriptMeta" class="script-meta">Dream of the Red Chamber · Scene · Role</div>
                <div id="scriptExcerpt" class="script-excerpt">After choosing an expression, a matching line or imagery will appear.</div>
                <div id="scriptNote" class="script-note">Tip: Enter the role first; let the face follow naturally.</div>
                <div class="script-actions">
                    <button id="prevScriptBtn" class="btn-secondary">Previous</button>
                    <button id="nextScriptBtn" class="btn-secondary">Another</button>
                    <button id="ttsScriptBtn" class="btn-secondary">Speak Line</button>
                </div>
            </div>
        </div>
        
        <!-- Results Section -->
        <div class="results" id="resultsSection">
            <div class="results-header">
                <div class="results-title" id="resultsTitle">Training Results</div>
                <div class="amplitude-label" id="amplitudeLabel">Medium</div>
            </div>
            
            <div class="charts-container">
                <div class="chart-section">
                    <div class="chart-title">Acting Dimensions</div>
                    <canvas id="radarChart" class="chart" width="300" height="200"></canvas>
                </div>
                <div class="chart-section">
                    <div class="chart-title">Technical Metrics</div>
                    <canvas id="barChart" class="chart" width="300" height="200"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Training prompts config
        const TRAINING_COMMANDS = {
            smile_natural: {
                id: "smile_natural",
                text: "Make a natural smile and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "smile",
                duchenne: false,
                difficulty: "E"
            },
            smile_duchenne: {
                id: "smile_duchenne", 
                text: "Duchenne smile: engage the eyes and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "smile",
                duchenne: true,
                difficulty: "M"
            },
            neutral: {
                id: "neutral",
                text: "Hold a neutral face for 2 seconds",
                tts: true,
                duration: 2000,
                target: "neutral",
                duchenne: false,
                difficulty: "E"
            },
            focus: {
                id: "focus",
                text: "Make a focused expression and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "focus",
                duchenne: false,
                difficulty: "M"
            },
            surprised: {
                id: "surprised",
                text: "Make a surprised expression and hold for 1.5 seconds",
                tts: true,
                duration: 1500,
                target: "surprised",
                duchenne: false,
                difficulty: "M"
            },
            sad: {
                id: "sad",
                text: "Make a sad expression and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "sad",
                duchenne: false,
                difficulty: "H"
            },
            disgust: {
                id: "disgust",
                text: "Make a disgust expression and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "disgust",
                duchenne: false,
                difficulty: "H"
            },
            angry: {
                id: "angry",
                text: "Make an angry expression and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "angry",
                duchenne: false,
                difficulty: "H"
            }
        };

        // MediaPipe landmarks 索引 (基于468点模型)
        const LANDMARKS = {
            // 嘴部关键点
            MOUTH: {
                LEFT_CORNER: 61,    // 左嘴角
                RIGHT_CORNER: 291,  // 右嘴角
                TOP: 13,           // 上唇中心
                BOTTOM: 14,        // 下唇中心
                UPPER_LIP: [12, 15, 16, 17, 18, 200], // 上唇轮廓
                LOWER_LIP: [146, 91, 181, 84, 17, 314, 405, 320, 307, 375] // 下唇轮廓
            },
            // 左眼关键点
            LEFT_EYE: {
                TOP: 159,
                BOTTOM: 145,
                LEFT: 33,
                RIGHT: 133,
                OUTLINE: [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246]
            },
            // 右眼关键点
            RIGHT_EYE: {
                TOP: 386,
                BOTTOM: 374,
                LEFT: 362,
                RIGHT: 263,
                OUTLINE: [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398]
            },
            // 眉毛关键点
            LEFT_EYEBROW: {
                INNER: 55,   // 左眉内侧
                OUTER: 46,   // 左眉外侧
                CENTER: 70   // 左眉中心
            },
            RIGHT_EYEBROW: {
                INNER: 285,  // 右眉内侧
                OUTER: 276,  // 右眉外侧
                CENTER: 300  // 右眉中心
            },
            NOSE_TIP: 1,     // 鼻尖
            FACE_OUTLINE: [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109]
        };

        // 全局变量
        let faceMesh;
        let camera;
        let currentMode = 'film';  // 'film' or 'stage'
        let isTraining = false;
        let isCalibrating = false;
        let baseline = null; // 个人基线
        let currentSession = null;
        let metricsBuffer = [];
        let lastFrameTime = 0;
        let frameCount = 0;
        let fps = 0;
        let scriptIndices = {}; // 剧本索引（按target存储）
        let settings = { autoTTS: true, mirror: true };

        // 红楼梦·剧本引导素材（精简、公版）
        const SCRIPT_GUIDES = {
            smile: [
                {
                    work: 'Dream of the Red Chamber', role: 'Jia Baoyu', scene: 'Garden chat',
                    excerpt: 'Seeing Daiyu smiling gently, he cannot help a soft smile.',
                    coaching: 'Natural: lift mouth corners lightly, let the eyes soften; easy breath.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Lin Daiyu', scene: 'With Baochai',
                    excerpt: 'Baochai’s warm words ease her heart; a knowing smile appears.',
                    coaching: 'Duchenne: let the smile rise from the eyes, then the mouth.'
                }
            ],
            neutral: [
                {
                    work: 'Dream of the Red Chamber', role: 'Xue Baochai', scene: 'Listening calmly',
                    excerpt: 'Composed and poised, neither pleased nor angry, serene as jade.',
                    coaching: 'Neutral: relax jaw and brow, steady gaze, even breath.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Grandmother Jia', scene: 'Seated at the hall',
                    excerpt: 'Sits with ease; kindness contained; features at rest as usual.',
                    coaching: 'On camera, keep stillness; minimize micro-expressions.'
                }
            ],
            focus: [
                {
                    work: 'Dream of the Red Chamber', role: 'Lin Daiyu', scene: 'Burying flowers, composing',
                    excerpt: 'She bends to pick petals, eyes intent, weighing each word.',
                    coaching: 'Focus: lower eyelids slightly, relax forehead, fix the gaze on one point.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Xue Baochai', scene: 'Copying sutras',
                    excerpt: 'Breath steady; hands firm and eyes set; no distraction.',
                    coaching: 'Reduce fidgets; lips lightly closed; fine nasal breath; hands-mind united.'
                }
            ],
            surprised: [
                {
                    work: 'Dream of the Red Chamber', role: 'Jia Baoyu', scene: 'First meeting Daiyu',
                    excerpt: 'At her arrival, his heart stirs; eyes open slightly; a brief start.',
                    coaching: 'Surprise: lift brows a touch, release jaw, let a natural inhale happen.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Wang Xifeng', scene: 'Hearing sudden news',
                    excerpt: 'On hearing strange news, she turns quickly, expression jolted.',
                    coaching: 'Pop the brows/eyes then settle quickly; avoid overdoing it.'
                }
            ],
            sad: [
                {
                    work: 'Dream of the Red Chamber', role: 'Lin Daiyu', scene: 'Ode to Fallen Flowers',
                    excerpt: 'Petals fall and scatter; fragrance fades—who will pity?',
                    coaching: 'Sadness: slight brow knit, corners contained, gaze down, shallow breath.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Shi Xiangyun', scene: 'Weeping by the stone',
                    excerpt: 'Leaning alone by the rock, tears not yet dry, a smile hard to keep.',
                    coaching: 'Restrained sorrow: feeling inside, shape in small; avoid sobbing excess.'
                }
            ],
            disgust: [
                {
                    work: 'Dream of the Red Chamber', role: 'Lin Daiyu', scene: 'Aversion to vulgarity',
                    excerpt: 'Hearing coarse talk, she turns away; nose narrows; lips press lightly.',
                    coaching: 'Disgust: lift upper lip a little; wrinkle nose subtly; moderate amplitude.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Jia Baoyu', scene: 'Tiring of success-talk',
                    excerpt: 'At talk of fame and office, he grows impatient and changes the topic.',
                    coaching: 'More emotional disdain: avert gaze; draw corners in slightly.'
                }
            ],
            angry: [
                {
                    work: 'Dream of the Red Chamber', role: 'Wang Xifeng', scene: 'Household scolding',
                    excerpt: 'Brows pressed; eyes cold; her rebuke quiets the hall.',
                    coaching: 'Anger: lower brows, fix gaze; powered exhale, face stays organized.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Tanchun', scene: 'Resolute management',
                    excerpt: 'Firm words within measure; expression determined.',
                    coaching: 'Restrained anger: set jaw; lower brows with steady eyes; keep force internal.'
                }
            ]
        };

        // 初始化应用
        document.addEventListener('DOMContentLoaded', async () => {
            loadSettings();
            loadBaseline();
            await initializeCamera();
            setupEventListeners();
            applyMirror(settings.mirror);
            syncPreferenceUI();
            updateUI();
            updateScriptGuide();
        });

        // 设置事件监听器
        function setupEventListeners() {
            // 模式切换
            document.querySelectorAll('.mode-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.mode-option').forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    currentMode = option.dataset.mode;
                    updateUI();
                });
            });

            // 按钮事件
            document.getElementById('startBtn').addEventListener('click', startTraining);
            document.getElementById('nextBtn').addEventListener('click', nextExpression);
            document.getElementById('calibrateBtn').addEventListener('click', quickCalibrate);
            const resetBtn = document.getElementById('resetCalibrateBtn');
            if (resetBtn) resetBtn.addEventListener('click', resetCalibration);

            // 口令选择
            document.getElementById('commandSelect').addEventListener('change', () => {
                updateUI();
                updateScriptGuide();
            });

            // 剧本引导按钮
            const nextBtn = document.getElementById('nextScriptBtn');
            const prevBtn = document.getElementById('prevScriptBtn');
            const ttsBtn = document.getElementById('ttsScriptBtn');
            if (nextBtn) nextBtn.addEventListener('click', () => cycleScript(1));
            if (prevBtn) prevBtn.addEventListener('click', () => cycleScript(-1));
            if (ttsBtn) ttsBtn.addEventListener('click', speakCurrentScript);

            // 偏好设置
            const autoTTSChk = document.getElementById('toggleAutoTTS');
            const mirrorChk = document.getElementById('toggleMirror');
            if (autoTTSChk) autoTTSChk.addEventListener('change', () => { settings.autoTTS = !!autoTTSChk.checked; saveSettings(); });
            if (mirrorChk) mirrorChk.addEventListener('change', () => { settings.mirror = !!mirrorChk.checked; applyMirror(settings.mirror); saveSettings(); });

            // 快捷键
            window.addEventListener('keydown', (e) => {
                if (e.target && ['INPUT','SELECT','TEXTAREA'].includes(e.target.tagName)) return;
                if (e.key === 's' || e.key === 'S') startTraining();
                if (e.key === 'n' || e.key === 'N') nextExpression();
                if (e.key === 'c' || e.key === 'C') quickCalibrate();
                if (e.key === 't' || e.key === 'T') speakCurrentScript();
            });
        }

        // 初始化摄像头和MediaPipe
        async function initializeCamera() {
            try {
                // 获取摄像头
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const videoElement = document.getElementById('videoElement');
                videoElement.srcObject = stream;
                
                videoElement.onloadedmetadata = () => {
                    const canvas = document.getElementById('overlayCanvas');
                    canvas.width = videoElement.videoWidth;
                    canvas.height = videoElement.videoHeight;
                };

                await initializeFaceMesh();
                document.getElementById('videoStatus').textContent = 'Camera ready';
                
            } catch (error) {
                console.error('Camera init failed:', error);
                document.getElementById('videoStatus').textContent = 'Camera access failed';
            }
        }

        async function initializeFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onResults);

            camera = new Camera(document.getElementById('videoElement'), {
                onFrame: async () => {
                    await faceMesh.send({image: document.getElementById('videoElement')});
                },
                width: 640,
                height: 480
            });

            camera.start();
        }

        // MediaPipe结果处理
        function onResults(results) {
            const now = performance.now();
            
            // 计算FPS
            frameCount++;
            if (now - lastFrameTime >= 1000) {
                fps = frameCount;
                lastFrameTime = now;
                frameCount = 0;
            }

            const canvas = document.getElementById('overlayCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // 绘制轮廓
                drawOverlay(ctx, landmarks);
                
                // 提取特征
                const metrics = extractMetrics(landmarks);
                
                // 收集训练数据
                if ((isTraining || isCalibrating) && metrics) {
                    metricsBuffer.push({
                        timestamp: now,
                        metrics: metrics
                    });
                }
                
                document.getElementById('videoStatus').textContent = `Face detected · FPS: ${fps}`;
            } else {
                document.getElementById('videoStatus').textContent = 'No face detected';
            }
        }

        // 绘制面部轮廓 - 简化版本，主要显示嘴部和眼部
        function drawOverlay(ctx, landmarks) {
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;

            // 绘制嘴部轮廓
            drawLandmarkContour(ctx, LANDMARKS.MOUTH.UPPER_LIP, landmarks, '#4ecdc4');
            drawLandmarkContour(ctx, LANDMARKS.MOUTH.LOWER_LIP, landmarks, '#4ecdc4');

            // 绘制眼部轮廓
            drawLandmarkContour(ctx, LANDMARKS.LEFT_EYE.OUTLINE, landmarks, '#45b7d1');
            drawLandmarkContour(ctx, LANDMARKS.RIGHT_EYE.OUTLINE, landmarks, '#45b7d1');
        }

        function drawLandmarkContour(ctx, indices, landmarks, color) {
            if (!indices || !landmarks) return;
            
            ctx.strokeStyle = color;
            ctx.beginPath();
            
            let started = false;
            indices.forEach(idx => {
                if (landmarks[idx]) {
                    const point = landmarks[idx];
                    const x = point.x * ctx.canvas.width;
                    const y = point.y * ctx.canvas.height;
                    
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            });
            
            ctx.closePath();
            ctx.stroke();
        }

        /**
         * 特征提取函数
         * 基于MediaPipe 468点模型提取关键表情特征
         */
        function extractMetrics(landmarks) {
            if (!landmarks || landmarks.length < 468) return null;

            try {
                // 嘴部特征点
                const mouth = {
                    leftCorner: landmarks[LANDMARKS.MOUTH.LEFT_CORNER],
                    rightCorner: landmarks[LANDMARKS.MOUTH.RIGHT_CORNER], 
                    top: landmarks[LANDMARKS.MOUTH.TOP],
                    bottom: landmarks[LANDMARKS.MOUTH.BOTTOM]
                };

                // 眼部特征点
                const eyes = {
                    leftTop: landmarks[LANDMARKS.LEFT_EYE.TOP],
                    leftBottom: landmarks[LANDMARKS.LEFT_EYE.BOTTOM],
                    leftLeft: landmarks[LANDMARKS.LEFT_EYE.LEFT],
                    leftRight: landmarks[LANDMARKS.LEFT_EYE.RIGHT],
                    rightTop: landmarks[LANDMARKS.RIGHT_EYE.TOP],
                    rightBottom: landmarks[LANDMARKS.RIGHT_EYE.BOTTOM],
                    rightLeft: landmarks[LANDMARKS.RIGHT_EYE.LEFT],
                    rightRight: landmarks[LANDMARKS.RIGHT_EYE.RIGHT]
                };

                // 眉毛特征点
                const brows = {
                    leftInner: landmarks[LANDMARKS.LEFT_EYEBROW.INNER],
                    leftOuter: landmarks[LANDMARKS.LEFT_EYEBROW.OUTER],
                    leftCenter: landmarks[LANDMARKS.LEFT_EYEBROW.CENTER],
                    rightInner: landmarks[LANDMARKS.RIGHT_EYEBROW.INNER],
                    rightOuter: landmarks[LANDMARKS.RIGHT_EYEBROW.OUTER],
                    rightCenter: landmarks[LANDMARKS.RIGHT_EYEBROW.CENTER]
                };

                const distance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                // 1. mouthRatio = mouthWidth / mouthHeight (微笑时增大)
                const mouthWidth = distance(mouth.leftCorner, mouth.rightCorner);
                const mouthHeight = distance(mouth.top, mouth.bottom);
                const mouthRatio = mouthWidth / (mouthHeight + 0.001);

                // 2. mouthOpen = mouthHeight / mouthWidth (惊讶/张口时增大)
                const mouthOpen = mouthHeight / (mouthWidth + 0.001);

                // 3. eyeEAR = Eye Aspect Ratio 平均值 (Duchenne笑时减小)
                const leftEAR = distance(eyes.leftTop, eyes.leftBottom) / distance(eyes.leftLeft, eyes.leftRight);
                const rightEAR = distance(eyes.rightTop, eyes.rightBottom) / distance(eyes.rightLeft, eyes.rightRight);
                const eyeEAR = (leftEAR + rightEAR) / 2;

                // 4. browActivity - 眉毛活动度 (基于眉心/眉尾垂直位移)
                const leftBrowHeight = Math.abs(brows.leftCenter.y - eyes.leftTop.y);
                const rightBrowHeight = Math.abs(brows.rightCenter.y - eyes.rightTop.y);
                const browActivity = (leftBrowHeight + rightBrowHeight) / 2;

                // 5. symMouth - 嘴部对称性 (0-1, 基于左右嘴角y坐标差)
                const symMouth = 1 - Math.min(1, Math.abs(mouth.leftCorner.y - mouth.rightCorner.y) * 1000);

                // 6. poseYawProxy - 简化偏航代理 (基于鼻尖相对面部中心的水平偏移)
                const noseTip = landmarks[LANDMARKS.NOSE_TIP];
                const poseYawProxy = 1 - Math.min(1, Math.abs(noseTip.x - 0.5) * 2);

                // 7. illumScore - 亮度均匀度粗评 (简化版本，基于面部区域)
                const illumScore = 0.8; // 简化实现，实际应基于像素亮度分析

                return {
                    mouthRatio,
                    mouthOpen,
                    eyeEAR,
                    browActivity,
                    symMouth,
                    poseYawProxy,
                    illumScore,
                    // 额外的辅助数据
                    mouthWidth,
                    mouthHeight,
                    leftEAR,
                    rightEAR
                };

            } catch (error) {
                console.error('特征提取失败:', error);
                return null;
            }
        }

        /**
         * 技术层评分函数
         * 输入: 特征数据, 模式, 目标表情, 个人基线
         * 输出: Match/Symmetry/Stability/Aesthetics 四个技术指标 (0-100)
         */
        function scoreFromMetrics(metrics, mode, target, baseline) {
            if (!metrics) return { match: 0, symmetry: 0, stability: 0, aesthetics: 0 };

            // 1. Match 匹配度 - 基于目标表情的特征匹配
            let match = calculateMatchScore(metrics, target, baseline);

            // 2. Symmetry 对称性 - 直接映射symMouth
            const symmetry = Math.round(metrics.symMouth * 100);

            // 3. Stability 稳定性 - 基于2秒窗口内的方差 (简化实现)
            const stability = calculateStability();

            // 4. Aesthetics 美观度 - 基于姿态和光照
            const aesthetics = Math.round((metrics.poseYawProxy * 0.6 + metrics.illumScore * 0.4) * 100);

            // 最终技术分合成
            const finalTechScore = Math.round(
                0.5 * match + 
                0.2 * symmetry + 
                0.2 * stability + 
                0.1 * aesthetics
            );

            return {
                match: Math.max(0, Math.min(100, match)),
                symmetry: Math.max(0, Math.min(100, symmetry)),
                stability: Math.max(0, Math.min(100, stability)),
                aesthetics: Math.max(0, Math.min(100, aesthetics)),
                final: Math.max(0, Math.min(100, finalTechScore))
            };
        }

        // 计算匹配度分数
        function calculateMatchScore(metrics, target, baseline) {
            let score = 50; // 基础分

            if (!baseline) {
                // 无基线时的绝对评分
                switch (target) {
                    case 'smile':
                        // 微笑: 嘴角上扬 (mouthRatio增大)
                        score = Math.min(100, (metrics.mouthRatio - 2.0) * 40 + 60);
                        break;
                    case 'surprised':
                        // 惊讶: 张口 + 眼裂增大
                        score = Math.min(100, metrics.mouthOpen * 80 + 30);
                        break;
                    case 'sad':
                        // 悲伤: 眉内收 + 嘴角下垂
                        score = Math.max(30, 70 - metrics.mouthRatio * 10);
                        break;
                    case 'angry':
                        // 愤怒: 眉压低 + 目光集中
                        score = 60 + (1 - metrics.browActivity) * 30;
                        break;
                    case 'disgust':
                        // 厌恶: 上唇抬起
                        score = 50 + metrics.mouthOpen * 30;
                        break;
                    case 'neutral':
                        // 中性: 各指标接近平均值
                        score = 80 - Math.abs(metrics.mouthRatio - 2.5) * 20;
                        break;
                    case 'focus':
                        // 专注: 轻微眯眼
                        score = 70 + (0.3 - metrics.eyeEAR) * 100;
                        break;
                }
            } else {
                // 基于个人基线的相对评分
                const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
                const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR; // 注意方向
                const dMouthOpen = metrics.mouthOpen - baseline.mouthOpen;
                const dBrowActivity = metrics.browActivity - baseline.browActivity;

                switch (target) {
                    case 'smile':
                        score = 60 + dMouthRatio * 50;
                        // Duchenne笑检测
                        if (TRAINING_COMMANDS[getCurrentCommandId()].duchenne && dEyeEAR > 0.02) {
                            score += 20; // 眼部参与的加分
                        }
                        break;
                    case 'surprised':
                        score = 60 + dMouthOpen * 100 + dEyeEAR * 50;
                        break;
                    case 'sad':
                        score = 60 + dBrowActivity * 40 - dMouthRatio * 30;
                        break;
                    case 'angry':
                        score = 60 - dBrowActivity * 50 + Math.min(0, -dEyeEAR * 30);
                        break;
                    case 'disgust':
                        score = 60 + dMouthOpen * 80;
                        break;
                    case 'neutral':
                        // 中性脸：各项变化都应该很小
                        const totalChange = Math.abs(dMouthRatio) + Math.abs(dEyeEAR) + Math.abs(dMouthOpen);
                        score = 80 - totalChange * 200;
                        break;
                    case 'focus':
                        score = 60 + dEyeEAR * 100; // 轻微眯眼
                        break;
                }
            }

            return Math.max(10, Math.min(100, Math.round(score)));
        }

        // 计算稳定性 (简化实现)
        function calculateStability() {
            if (metricsBuffer.length < 10) return 70; // 默认值
            
            // 计算最近10帧的嘴部特征方差
            const recent = metricsBuffer.slice(-10).map(item => item.metrics.mouthRatio);
            const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
            const variance = recent.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / recent.length;
            
            // 方差越小，稳定性越高
            return Math.max(0, Math.min(100, Math.round(100 - variance * 1000)));
        }

        /**
         * 表演学科四维映射
         * 将技术指标映射为表演专业的四个维度
         */
        function mapToActingDimensions(techScores, metrics, mode) {
            const isFilm = mode === 'film';
            const isStage = mode === 'stage';

            // 1. Clarity 清晰度 - 表情是否清晰可读
            let clarity = techScores.match * 0.7 + techScores.aesthetics * 0.3;
            
            // 舞台模式需要更大的幅度才能获得高清晰度分
            if (isStage) {
                const amplitude = calculateAmplitude(metrics);
                if (amplitude < 0.3) clarity *= 0.7; // 幅度不足扣分
            }

            // 2. Consistency 一致性 - 面部各部分是否协调
            let consistency = techScores.stability * 0.8;
            
            // 眼嘴协调性检测 (简化版)
            const eyeMouthConsistency = calculateEyeMouthConsistency(metrics);
            consistency += eyeMouthConsistency * 0.2;

            // 3. Intensity 强度 - 表情幅度是否适合模式
            const amplitude = calculateAmplitude(metrics);
            let intensity = amplitude * 100;
            
            // 根据模式调整强度评分
            if (isStage) {
                // 舞台模式偏好更高强度
                intensity *= 1.2;
            } else if (isFilm) {
                // 影视模式对过度强度扣分
                if (amplitude > 0.8) intensity *= 0.7;
            }

            // 4. Truth 真实性 - 检测假表情
            let truth = calculateTruthScore(metrics, getCurrentTarget());

            return {
                clarity: Math.max(0, Math.min(100, Math.round(clarity))),
                consistency: Math.max(0, Math.min(100, Math.round(consistency))),
                intensity: Math.max(0, Math.min(100, Math.round(intensity))),
                truth: Math.max(0, Math.min(100, Math.round(truth)))
            };
        }

        // 计算表情幅度
        function calculateAmplitude(metrics) {
            if (!baseline) return 0.5; // 无基线时返回中等幅度
            
            const dMouthRatio = Math.abs(metrics.mouthRatio - baseline.mouthRatio);
            const dEyeEAR = Math.abs(metrics.eyeEAR - baseline.eyeEAR);
            const dMouthOpen = Math.abs(metrics.mouthOpen - baseline.mouthOpen);
            
            // 综合各项特征的变化幅度
            return Math.min(1, (dMouthRatio + dEyeEAR * 2 + dMouthOpen) / 3);
        }

        // 计算眼嘴协调性
        function calculateEyeMouthConsistency(metrics) {
            if (!baseline) return 50;
            
            const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
            const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR; // 注意方向
            
            // 微笑时，嘴角上扬应该伴随眼部变化
            if (dMouthRatio > 0.1) { // 明显的嘴角上扬
                return dEyeEAR > 0.01 ? 80 : 40; // 有眼部参与得高分
            }
            
            return 60; // 默认中等协调性
        }

        // 计算真实性分数
        function calculateTruthScore(metrics, target) {
            if (!baseline) return 70; // 无基线时的默认值
            
            const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
            const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR;
            
            let truth = 75; // 基础真实性分数
            
            switch (target) {
                case 'smile':
                    // 检测假笑: 嘴角上扬但眼部无变化
                    if (dMouthRatio > 0.1 && dEyeEAR < 0.005) {
                        truth -= 30; // 严重假笑
                    } else if (dMouthRatio > 0.05 && dEyeEAR < 0.01) {
                        truth -= 15; // 轻微假笑
                    }
                    break;
                    
                case 'sad':
                    // 悲伤时眉眼嘴的方向应该一致
                    const browDown = metrics.browActivity < baseline.browActivity;
                    const mouthDown = dMouthRatio < -0.02;
                    if (browDown !== mouthDown) {
                        truth -= 20; // 表情不一致
                    }
                    break;
                    
                case 'surprised':
                    // 惊讶时眉毛上扬和张嘴应该同时发生
                    const browUp = metrics.browActivity > baseline.browActivity;
                    const mouthOpen = metrics.mouthOpen > baseline.mouthOpen + 0.05;
                    if (browUp !== mouthOpen) {
                        truth -= 15;
                    }
                    break;
            }
            
            return Math.max(30, Math.min(100, truth));
        }

        /**
         * 表演语言反馈生成
         * 基于评分结果生成自然的中文表演建议
         */
        function generateActingTips(dimScores, metrics, target, mode) {
            const tips = [];
            const isFilm = mode === 'film';
            const isStage = mode === 'stage';
            const amplitude = calculateAmplitude(metrics);
            
            // Clarity 清晰度反馈
            if (dimScores.clarity < 60) {
                if (isStage) {
                    tips.push("Clarity is low for stage distance. Enlarge mouth spread or brow movement about 15%.");
                } else {
                    tips.push("Expression isn’t clear enough. Make the action a touch more defined while staying natural.");
                }
            }
            
            // Intensity 强度反馈
            if (dimScores.intensity > 85 && isFilm) {
                tips.push("Amplitude is exaggerated for camera. Reduce about 20% to preserve authenticity.");
            } else if (dimScores.intensity < 50 && isStage) {
                tips.push("For stage, increase amplitude so faces read from the back rows.");
            }
            
            // Truth 真实性反馈
            if (dimScores.truth < 60) {
                switch (target) {
                    case 'smile':
                        tips.push("笑停在嘴角，眼神没有到位。轻眯眼10%，把注意力放在'想笑的理由'上。");
                        break;
                    case 'sad':
                        tips.push("悲伤表情需要眉眼嘴的统一。先从内心感受开始，让表情自然流露。");
                        break;
                    case 'angry':
                        tips.push("愤怒不只是眉毛，眼神的专注和嘴部的紧绷同样重要。");
                        break;
                }
            }
            
            // Consistency 一致性反馈
            if (dimScores.consistency < 60) {
                tips.push("Upper and lower face aren’t unified. Set the eyes first, then bring in the mouth gradually.");
            }
            
            // 光照和姿态反馈
            if (metrics.illumScore < 0.6) {
                tips.push("Adjust light to a 30–45° frontal angle to improve readability.");
            }
            
            if (metrics.poseYawProxy < 0.7) {
                tips.push("Face the camera frontally; avoid profile which reduces recognition.");
            }
            
            // 特定表情的专项建议
            addSpecificTips(tips, target, metrics, dimScores);
            
            // 如果没有问题，给予鼓励
            if (tips.length === 0) {
                const avgScore = (dimScores.clarity + dimScores.consistency + dimScores.intensity + dimScores.truth) / 4;
                if (avgScore > 80) {
                    tips.push("Great work — natural and truthful, fitting " + (isFilm ? "film" : "stage") + " demands.");
                } else {
                    tips.push("Solid overall. Keep this state; practice will make it feel even more natural.");
                }
            }
            
            return tips.slice(0, 4); // 限制为最多4条建议
        }

        // 添加特定表情的专项建议
        function addSpecificTips(tips, target, metrics, dimScores) {
            switch (target) {
                case 'smile':
                    if (TRAINING_COMMANDS[getCurrentCommandId()].duchenne) {
                        if (dimScores.truth < 70) {
                            tips.push("Duchenne needs eye involvement. Recall a truly happy moment so the eye corners engage.");
                        }
                    }
                    break;
                    
                case 'surprised':
                    if (metrics.mouthOpen < (baseline ? baseline.mouthOpen + 0.05 : 0.1)) {
                        tips.push("For surprise, release the jaw and separate the lips — as if truly startled.");
                    }
                    break;
                    
                case 'sad':
                    if (dimScores.intensity < 50) {
                        tips.push("Sadness isn’t only drooping corners. A slight brow knit and distant gaze help.");
                    }
                    break;
                    
                case 'angry':
                    if (dimScores.clarity < 60) {
                        tips.push("Core of anger is the eyes. Lower the brows while keeping the gaze concentrated.");
                    }
                    break;
            }
        }

        // 开始训练
        async function startTraining() {
            if (isTraining) return;
            
            const commandId = document.getElementById('commandSelect').value;
            const command = TRAINING_COMMANDS[commandId];
            
            if (!command) return;
            
            isTraining = true;
            metricsBuffer = [];
            
            // 更新UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('currentCommand').textContent = command.text;
            
            // 自动播报：先播报剧本台词，再播报训练口令
            try {
                if (settings.autoTTS) {
                    await speakCurrentScriptAsync();
                    if (command.tts) {
                        await ttsSpeak(command.text);
                    }
                    // 0.5秒呼吸停顿
                    await new Promise(r => setTimeout(r, 500));
                }
            } catch (e) { /* 忽略TTS错误 */ }
            
            // 倒计时
            await countdown(3);
            
            // 开始记录
            currentSession = {
                mode: currentMode,
                command: command,
                startTime: performance.now()
            };
            
            // 训练计时
            setTimeout(() => {
                finishTraining();
            }, command.duration);
            
            // 显示倒计时
            showTrainingCountdown(command.duration);
        }

        // 基础TTS，返回Promise用于串联
        function ttsSpeak(text, opts = {}) {
            return new Promise((resolve) => {
                if (!('speechSynthesis' in window) || !text) return resolve();
                try { window.speechSynthesis.cancel(); } catch (e) {}
                const u = new SpeechSynthesisUtterance(text);
                u.lang = opts.lang || 'en-US';
                if (opts.rate) u.rate = opts.rate;
                if (opts.pitch) u.pitch = opts.pitch;
                if (opts.volume) u.volume = opts.volume;
                const done = () => resolve();
                u.onend = done; u.onerror = done; u.onpause = done; u.onboundary = null;
                window.speechSynthesis.speak(u);
                // 保险超时：最长6秒
                setTimeout(done, opts.timeoutMs || 6000);
            });
        }

        // 朗读当前剧本台词（Promise版）
        function speakCurrentScriptAsync() {
            const excerpt = (document.getElementById('scriptExcerpt')?.textContent || '').trim();
            if (!excerpt) return Promise.resolve();
            const text = excerpt.replace(/^“|”$/g, '');
            return ttsSpeak(text, { lang: 'en-US', timeoutMs: 7000 });
        }

        // 倒计时显示
        async function countdown(seconds) {
            const countdownEl = document.getElementById('countdown');
            
            for (let i = seconds; i > 0; i--) {
                countdownEl.textContent = i;
                countdownEl.style.color = '#ff6b6b';
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            countdownEl.textContent = 'Go!';
            countdownEl.style.color = '#4ecdc4';
            await new Promise(resolve => setTimeout(resolve, 500));
            countdownEl.textContent = '';
        }

        // 显示训练倒计时
        function showTrainingCountdown(duration) {
            const countdownEl = document.getElementById('countdown');
            const startTime = Date.now();
            
            const updateCountdown = () => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, duration - elapsed);
                const seconds = (remaining / 1000).toFixed(1);
                
                countdownEl.textContent = `${seconds}s`;
                countdownEl.style.color = '#4ecdc4';
                
                if (remaining > 0) {
                    requestAnimationFrame(updateCountdown);
                } else {
                    countdownEl.textContent = '';
                }
            };
            
            requestAnimationFrame(updateCountdown);
        }

        // 完成训练
        function finishTraining() {
            isTraining = false;
            currentSession.endTime = performance.now();
            
            // 分析结果
            if (metricsBuffer.length > 0) {
                analyzeSession();
            }
            
            document.getElementById('startBtn').disabled = false;
        }

        // 分析训练会话
        function analyzeSession() {
            // 计算平均特征
            const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
            if (validMetrics.length === 0) return;
            
            const avgMetrics = calculateAverageMetrics(validMetrics);
            
            // 技术层评分
            const techScores = scoreFromMetrics(avgMetrics, currentMode, getCurrentTarget(), baseline);
            
            // 表演维度映射
            const dimScores = mapToActingDimensions(techScores, avgMetrics, currentMode);
            
            // 生成反馈
            const tips = generateActingTips(dimScores, avgMetrics, getCurrentTarget(), currentMode);
            
            // 更新UI
            updateScoreDisplay(techScores, dimScores);
            updateTips(tips);
            showResults(dimScores, avgMetrics);
        }

        // 计算平均特征
        function calculateAverageMetrics(metrics) {
            const avg = {};
            const keys = Object.keys(metrics[0]);
            
            keys.forEach(key => {
                avg[key] = metrics.reduce((sum, m) => sum + m[key], 0) / metrics.length;
            });
            
            return avg;
        }

        // 更新分数显示
        function updateScoreDisplay(techScores, dimScores) {
            // 更新徽章
            updateBadge('clarityBadge', 'clarityScore', dimScores.clarity);
            updateBadge('consistencyBadge', 'consistencyScore', dimScores.consistency);
            updateBadge('intensityBadge', 'intensityScore', dimScores.intensity);
            updateBadge('truthBadge', 'truthScore', dimScores.truth);
            
            // 更新技术指标
            document.getElementById('matchScore').textContent = techScores.match;
            document.getElementById('symmetryScore').textContent = techScores.symmetry;
            document.getElementById('stabilityScore').textContent = techScores.stability;
            document.getElementById('aestheticsScore').textContent = techScores.aesthetics;
            
            // 更新总分和进度条
            const totalScore = Math.round((dimScores.clarity + dimScores.consistency + dimScores.intensity + dimScores.truth) / 4);
            document.getElementById('totalScore').textContent = totalScore;
            document.getElementById('progressFill').style.width = `${totalScore}%`;
        }

        // 更新单个徽章
        function updateBadge(badgeId, scoreId, score) {
            const badge = document.getElementById(badgeId);
            const scoreEl = document.getElementById(scoreId);
            
            scoreEl.textContent = score;
            
            // 移除所有样式类
            badge.classList.remove('excellent', 'good', 'needs-work');
            
            // 根据分数添加样式
            if (score >= 80) {
                badge.classList.add('excellent');
            } else if (score >= 60) {
                badge.classList.add('good');
            } else {
                badge.classList.add('needs-work');
            }
        }

        // 更新建议面板
        function updateTips(tips) {
            const container = document.getElementById('tipsContainer');
            container.innerHTML = '';
            
            tips.forEach(tip => {
                const tipEl = document.createElement('div');
                tipEl.className = 'tip-item';
                tipEl.textContent = tip;
                container.appendChild(tipEl);
            });
        }

        // 显示结果区域
        function showResults(dimScores, metrics) {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.classList.add('visible');
            
            // 更新标题
            const commandText = TRAINING_COMMANDS[getCurrentCommandId()].text;
            document.getElementById('resultsTitle').textContent = `${currentMode === 'film' ? 'Film' : 'Stage'} mode - ${commandText}`;
            
            // 更新幅度标签
            const amplitude = calculateAmplitude(metrics);
            const amplitudeLabel = document.getElementById('amplitudeLabel');
            
            if (amplitude < 0.3) {
                amplitudeLabel.textContent = 'Subtle';
                amplitudeLabel.className = 'amplitude-label amplitude-subtle';
            } else if (amplitude < 0.7) {
                amplitudeLabel.textContent = 'Medium';
                amplitudeLabel.className = 'amplitude-label amplitude-medium';
            } else {
                amplitudeLabel.textContent = 'Exaggerated';
                amplitudeLabel.className = 'amplitude-label amplitude-exaggerated';
            }
            
            // 绘制图表
            drawRadarChart(dimScores);
            drawBarChart(dimScores);
        }

        // 绘制雷达图
        function drawRadarChart(scores) {
            const canvas = document.getElementById('radarChart');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 40;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            
            for (let i = 1; i <= 5; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * i / 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // 绘制坐标轴和标签
            const labels = ['Clarity', 'Consistency', 'Intensity', 'Truth'];
            const values = [scores.clarity, scores.consistency, scores.intensity, scores.truth];
            
            ctx.font = '12px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 - Math.PI / 2;
                const x1 = centerX;
                const y1 = centerY;
                const x2 = centerX + Math.cos(angle) * radius;
                const y2 = centerY + Math.sin(angle) * radius;
                
                // 绘制轴线
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // 绘制标签
                const labelX = centerX + Math.cos(angle) * (radius + 20);
                const labelY = centerY + Math.sin(angle) * (radius + 20);
                ctx.fillText(labels[i], labelX, labelY);
            }
            
            // 绘制数据多边形
            ctx.strokeStyle = '#4ecdc4';
            ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 - Math.PI / 2;
                const value = values[i] / 100;
                const x = centerX + Math.cos(angle) * radius * value;
                const y = centerY + Math.sin(angle) * radius * value;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                // 绘制数据点
                ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.closePath();
            ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#4ecdc4';
            ctx.stroke();
        }

        // 绘制柱状图
        function drawBarChart(scores) {
            const canvas = document.getElementById('barChart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            const barWidth = (width - padding * 2) / 4 - 10;
            
            ctx.clearRect(0, 0, width, height);
            
            const labels = ['Clarity', 'Consistency', 'Intensity', 'Truth'];
            const values = [scores.clarity, scores.consistency, scores.intensity, scores.truth];
            const colors = ['#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            
            // 绘制柱状图
            for (let i = 0; i < 4; i++) {
                const x = padding + i * (barWidth + 10);
                const barHeight = (values[i] / 100) * (height - padding * 2);
                const y = height - padding - barHeight;
                
                // 绘制柱子
                ctx.fillStyle = colors[i];
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // 绘制数值
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(values[i], x + barWidth / 2, y - 5);
                
                // 绘制标签
                ctx.font = '10px Arial';
                ctx.fillText(labels[i], x + barWidth / 2, height - padding + 15);
            }
        }

        // Quick Calibrate
        async function quickCalibrate() {
            if (isCalibrating) return;
            
            isCalibrating = true;
            metricsBuffer = [];
            
            document.getElementById('calibrateBtn').disabled = true;
            document.getElementById('currentCommand').textContent = 'Hold a neutral face for calibration...';
            
            // TTS提示
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance('Please hold a neutral face for one second to calibrate');
                utterance.lang = 'en-US';
                speechSynthesis.speak(utterance);
            }
            
            // 1.2秒校准时间（舍弃前200ms）
            const startTs = performance.now();
            await new Promise(resolve => setTimeout(resolve, 1200));
            
            // 计算基线
            if (metricsBuffer.length > 0) {
                const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
                if (validMetrics.length > 0) {
                    // 舍弃前200ms的样本
                    const filtered = metricsBuffer.filter(it => it.timestamp >= startTs + 200).map(it => it.metrics);
                    baseline = calculateAverageMetrics(filtered.length ? filtered : validMetrics);
                    try { localStorage.setItem('fec_baseline', JSON.stringify(baseline)); } catch (e) {}
                    document.getElementById('currentCommand').textContent = '✅ Calibration complete! You can start training now';
                    
                    // 更新建议
                    updateTips(['Calibration saved. Scoring will be based on your personal baseline for better accuracy.']);
                } else {
                    document.getElementById('currentCommand').textContent = '❌ Calibration failed. No face detected';
                }
            } else {
                document.getElementById('currentCommand').textContent = '❌ Calibration failed. Please ensure your face is clearly visible';
            }
            
            isCalibrating = false;
            document.getElementById('calibrateBtn').disabled = false;
        }

        function resetCalibration() {
            baseline = null;
            try { localStorage.removeItem('fec_baseline'); } catch (e) {}
            updateTips(['Calibration has been reset. Run Quick Calibrate before training for more accurate feedback.']);
            document.getElementById('currentCommand').textContent = 'Calibration cleared. You can run Quick Calibrate again.';
        }

        // 下一个表情
        function nextExpression() {
            const select = document.getElementById('commandSelect');
            const options = Array.from(select.options);
            const currentIndex = options.findIndex(opt => opt.selected);
            const nextIndex = (currentIndex + 1) % options.length;
            
            select.selectedIndex = nextIndex;
            updateUI();
            updateScriptGuide();
            
            // 隐藏结果区域
            document.getElementById('resultsSection').classList.remove('visible');
        }

        // 更新UI状态
        function updateUI() {
            const commandId = document.getElementById('commandSelect').value;
            const command = TRAINING_COMMANDS[commandId];
            
            if (command) {
                document.getElementById('currentCommand').textContent = `Ready: ${command.text}`;
            }
            
            // Update mode title
            const modeText = currentMode === 'film' ? 'Film mode' : 'Stage mode';
            document.title = `Expression Coach Pro - ${modeText}`;
        }

        // 辅助函数
        function getCurrentCommandId() {
            return document.getElementById('commandSelect').value;
        }

        function getCurrentTarget() {
            const commandId = getCurrentCommandId();
            return TRAINING_COMMANDS[commandId] ? TRAINING_COMMANDS[commandId].target : 'neutral';
        }

        // 偏好设置与镜像
        function loadSettings() {
            try {
                const s = JSON.parse(localStorage.getItem('fec_settings') || '{}');
                settings = { autoTTS: true, mirror: true, ...s };
            } catch (e) { settings = { autoTTS: true, mirror: true }; }
        }
        function saveSettings() {
            try { localStorage.setItem('fec_settings', JSON.stringify(settings)); } catch (e) {}
        }
        function syncPreferenceUI() {
            const autoTTSChk = document.getElementById('toggleAutoTTS');
            const mirrorChk = document.getElementById('toggleMirror');
            if (autoTTSChk) autoTTSChk.checked = !!settings.autoTTS;
            if (mirrorChk) mirrorChk.checked = !!settings.mirror;
        }
        function applyMirror(flag) {
            const v = document.getElementById('videoElement');
            const c = document.getElementById('overlayCanvas');
            if (v) v.style.transform = flag ? 'scaleX(-1)' : 'none';
            if (c) c.style.transform = flag ? 'scaleX(-1)' : 'none';
        }
        function loadBaseline() {
            try {
                const b = JSON.parse(localStorage.getItem('fec_baseline') || 'null');
                if (b && typeof b === 'object') {
                    baseline = b;
                    updateTips(['Loaded saved calibration. Your scores will use your personal baseline.']);
                }
            } catch (e) {}
        }

        // 剧本引导逻辑
        function mapCommandTargetToScriptKey(target) {
            // 目前训练target即对应脚本key
            return target === 'smile' ? 'smile' : target;
        }

        function getScriptListForTarget(target) {
            const key = mapCommandTargetToScriptKey(target || 'neutral');
            return SCRIPT_GUIDES[key] || [];
        }

        function getScriptIndex(target) {
            const key = mapCommandTargetToScriptKey(target);
            if (!(key in scriptIndices)) scriptIndices[key] = 0;
            return scriptIndices[key];
        }

        function setScriptIndex(target, idx) {
            const key = mapCommandTargetToScriptKey(target);
            scriptIndices[key] = idx;
        }

        function updateScriptGuide() {
            const target = getCurrentTarget();
            const list = getScriptListForTarget(target);
            const metaEl = document.getElementById('scriptMeta');
            const excerptEl = document.getElementById('scriptExcerpt');
            const noteEl = document.getElementById('scriptNote');

            if (!metaEl || !excerptEl || !noteEl) return;

            if (!list.length) {
                metaEl.textContent = 'Dream of the Red Chamber · No matching scene';
                excerptEl.textContent = 'No script guidance configured for this expression yet.';
                noteEl.textContent = 'Tip: You can still train using the Acting Tips above.';
                return;
            }

            const idx = Math.max(0, Math.min(getScriptIndex(target), list.length - 1));
            const item = list[idx];
            metaEl.textContent = `${item.work} · ${item.scene} · Role: ${item.role}`;
            excerptEl.textContent = `“${item.excerpt}”`;
            noteEl.textContent = item.coaching || '';
        }

        function cycleScript(step) {
            const target = getCurrentTarget();
            const list = getScriptListForTarget(target);
            if (!list.length) return;
            const cur = getScriptIndex(target);
            const next = (cur + step + list.length) % list.length;
            setScriptIndex(target, next);
            updateScriptGuide();
        }

        function speakCurrentScript() {
            if (!('speechSynthesis' in window)) return;
            const excerpt = (document.getElementById('scriptExcerpt')?.textContent || '').trim();
            if (!excerpt) return;
            const text = excerpt.replace(/^“|”$/g, '');
            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = 'zh-CN';
            try { window.speechSynthesis.cancel(); } catch (e) {}
            window.speechSynthesis.speak(utter);
        }
    </script>
</body>
</html>
