<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ë°®ÊÉÖËÆ≠ÁªÉÊïôÁªÉ - ‰∏ì‰∏öÁâà</title>
    
    <!--
    Êú¨Âú∞ËøêË°åËØ¥ÊòéÔºö
    1. ÊëÑÂÉèÂ§¥ÈúÄË¶Å HTTPS Êàñ localhost ÁéØÂ¢É
    2. ‰ΩøÁî® Python ÂêØÂä®Êú¨Âú∞ÊúçÂä°Ôºö
       python -m http.server 8000
       ÁÑ∂ÂêéËÆøÈóÆ http://localhost:8000
    3. Êàñ‰ΩøÁî® Python 3:
       python3 -m http.server 8000
    4. ÊâÄÊúâÂ§ÑÁêÜÂú®Êú¨Âú∞ÂÆåÊàêÔºå‰∏ç‰∏ä‰º†‰ªª‰ΩïÂõæÂÉèÊàñËßÜÈ¢ëÊï∞ÊçÆ
    -->
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .app-container {
            display: grid;
            grid-template-areas: 
                "header header header"
                "sidebar main tips"
                "results results results";
            grid-template-rows: auto 1fr auto;
            grid-template-columns: 300px 1fr 350px;
            height: 100vh;
            padding: 20px;
            gap: 20px;
        }
        
        /* Header - Progress and Badges */
        .header {
            grid-area: header;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }
        .lang-switch {
            position: absolute;
            top: 14px;
            right: 16px;
            font-size: 12px;
            background: rgba(255,255,255,0.12);
            padding: 6px 10px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            text-decoration: none;
            color: #fff;
        }
        .lang-switch:hover { border-color: #4ecdc4; }
        
        .progress-section {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .total-score {
            font-size: 24px;
            font-weight: bold;
            color: #4ecdc4;
            min-width: 80px;
        }
        
        .progress-bar {
            flex: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #45b7d1);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .badges {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .badge {
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .badge.excellent { border-color: #4ecdc4; background: rgba(78, 205, 196, 0.2); }
        .badge.good { border-color: #45b7d1; background: rgba(69, 183, 209, 0.2); }
        .badge.needs-work { border-color: #ff6b6b; background: rgba(255, 107, 107, 0.2); }
        
        .badge-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .badge-name {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .badge-score {
            font-size: 18px;
            font-weight: bold;
        }
        
        .tech-indicators {
            display: flex;
            justify-content: space-around;
            font-size: 11px;
            opacity: 0.7;
        }
        
        .tech-item {
            text-align: center;
        }
        
        /* Sidebar - Controls */
        .sidebar {
            grid-area: sidebar;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #4ecdc4;
        }
        
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .mode-option {
            flex: 1;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 12px;
        }
        
        .mode-option.active {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.2);
        }
        
        select, button {
            width: 100%;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:focus, button:hover {
            border-color: #4ecdc4;
            outline: none;
        }
        
        button {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .toggle-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 14px;
            opacity: 0.9;
        }
        .toggle-row input { accent-color: #4ecdc4; }
        
        .btn-primary {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            border: none;
            margin-bottom: 10px;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
        }
        
        /* Main Video Area */
        .main-area {
            grid-area: main;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        #videoElement {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform: scaleX(-1);
        }
        
        .video-status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
        }
        
        .training-info {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        .current-command {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 5px;
        }
        
        .countdown {
            font-size: 36px;
            font-weight: bold;
            color: #ff6b6b;
            margin: 10px 0;
        }
        
        /* Tips Panel */
        .tips-panel {
            grid-area: tips;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .tips-title {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tip-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.4;
            border-left: 4px solid #4ecdc4;
        }

        /* Script Guide */
        .script-item {
            background: rgba(255, 255, 255, 0.08);
            padding: 14px;
            border-radius: 10px;
            border-left: 4px solid #feca57;
        }
        .script-meta {
            font-size: 12px;
            opacity: 0.85;
            margin-bottom: 8px;
            color: #feca57;
            font-weight: 600;
        }
        .script-excerpt {
            font-size: 15px;
            margin-bottom: 8px;
        }
        .script-note {
            font-size: 12px;
            opacity: 0.9;
        }
        .script-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        /* Results Section */
        .results {
            grid-area: results;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
        }
        
        .results.visible {
            display: block;
        }
        
        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .results-title {
            font-size: 20px;
            font-weight: bold;
            color: #4ecdc4;
        }
        
        .amplitude-label {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .amplitude-subtle { color: #45b7d1; }
        .amplitude-medium { color: #4ecdc4; }
        .amplitude-exaggerated { color: #ff6b6b; }
        
        .charts-container {
            display: flex;
            gap: 20px;
        }
        
        .chart-section {
            flex: 1;
        }
        
        .chart-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: bold;
        }
        
        canvas.chart {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .app-container {
                grid-template-areas: 
                    "header"
                    "sidebar"
                    "main"
                    "tips"
                    "results";
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <a class="lang-switch" href="./expression-coach-pro.html">‰∏≠Êñá</a>
            <div class="progress-section">
                <div class="total-score" id="totalScore">0</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="badges">
                <div class="badge" id="clarityBadge">
                    <div class="badge-icon">üéØ</div>
                    <div class="badge-name">Clarity</div>
                    <div class="badge-score" id="clarityScore">0</div>
                </div>
                <div class="badge" id="consistencyBadge">
                    <div class="badge-icon">‚öñÔ∏è</div>
                    <div class="badge-name">Consistency</div>
                    <div class="badge-score" id="consistencyScore">0</div>
                </div>
                <div class="badge" id="intensityBadge">
                    <div class="badge-icon">‚ö°</div>
                    <div class="badge-name">Intensity</div>
                    <div class="badge-score" id="intensityScore">0</div>
                </div>
                <div class="badge" id="truthBadge">
                    <div class="badge-icon">üí´</div>
                    <div class="badge-name">Truth</div>
                    <div class="badge-score" id="truthScore">0</div>
                </div>
            </div>
            
            <div class="tech-indicators">
                <div class="tech-item">
                    <div>Match</div>
                    <div id="matchScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Symmetry</div>
                    <div id="symmetryScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Stability</div>
                    <div id="stabilityScore">0</div>
                </div>
                <div class="tech-item">
                    <div>Aesthetics</div>
                    <div id="aestheticsScore">0</div>
                </div>
            </div>
        </div>
        
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="control-group">
                <label class="control-label">Performance Mode</label>
                <div class="mode-selector">
                    <div class="mode-option active" data-mode="film">
                        <div>üé¨</div>
                        <div>Film</div>
                    </div>
                    <div class="mode-option" data-mode="stage">
                        <div>üé≠</div>
                        <div>Stage</div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label class="control-label" for="commandSelect">Training Prompt</label>
                <select id="commandSelect">
                    <option value="smile_natural">Natural Smile (2s)</option>
                    <option value="smile_duchenne">Duchenne Smile (2s)</option>
                    <option value="neutral">Neutral Face (2s)</option>
                    <option value="focus">Focused (2s)</option>
                    <option value="surprised">Surprised (1.5s)</option>
                    <option value="sad">Sad (2s)</option>
                    <option value="disgust">Disgust (2s)</option>
                    <option value="angry">Angry (2s)</option>
                </select>
            </div>
            
            <div class="control-group">
                <button class="btn-primary" id="startBtn">Start Training</button>
                <button class="btn-secondary" id="nextBtn">Next Expression</button>
                <button class="btn-secondary" id="calibrateBtn">Quick Calibrate</button>
                <button class="btn-secondary" id="resetCalibrateBtn">Reset Calibration</button>
            </div>

            <div class="control-group">
                <label class="control-label">Preferences</label>
                <div class="toggle-row"><input type="checkbox" id="toggleAutoTTS" checked> Auto TTS</div>
                <div class="toggle-row"><input type="checkbox" id="toggleMirror" checked> Mirror Video</div>
            </div>
        </div>
        
        <!-- Main Video Area -->
        <div class="main-area">
            <div class="video-container">
                <video id="videoElement" autoplay muted playsinline></video>
                <canvas id="overlayCanvas"></canvas>
                <div class="video-status" id="videoStatus">Waiting for camera...</div>
            </div>
            
            <div class="training-info">
                <div class="current-command" id="currentCommand">Pick a prompt and press Start</div>
                <div class="countdown" id="countdown"></div>
            </div>
        </div>
        
        <!-- Tips Panel -->
        <div class="tips-panel">
            <div class="tips-title">
                <span>üí°</span>
                <span>Acting Tips</span>
            </div>
            <div id="tipsContainer">
                <div class="tip-item">Choose a mode and target expression to begin.</div>
            </div>

            <div class="tips-title" style="margin-top:16px;">
                <span>üìú</span>
                <span>Script Coach</span>
            </div>
            <div id="scriptGuideContainer" class="script-item">
                <div id="scriptMeta" class="script-meta">Dream of the Red Chamber ¬∑ Scene ¬∑ Role</div>
                <div id="scriptExcerpt" class="script-excerpt">After choosing an expression, a matching line or imagery will appear.</div>
                <div id="scriptNote" class="script-note">Tip: Enter the role first; let the face follow naturally.</div>
                <div class="script-actions">
                    <button id="prevScriptBtn" class="btn-secondary">Previous</button>
                    <button id="nextScriptBtn" class="btn-secondary">Another</button>
                    <button id="ttsScriptBtn" class="btn-secondary">Speak Line</button>
                </div>
            </div>
        </div>
        
        <!-- Results Section -->
        <div class="results" id="resultsSection">
            <div class="results-header">
                <div class="results-title" id="resultsTitle">Training Results</div>
                <div class="amplitude-label" id="amplitudeLabel">Medium</div>
            </div>
            
            <div class="charts-container">
                <div class="chart-section">
                    <div class="chart-title">Acting Dimensions</div>
                    <canvas id="radarChart" class="chart" width="300" height="200"></canvas>
                </div>
                <div class="chart-section">
                    <div class="chart-title">Technical Metrics</div>
                    <canvas id="barChart" class="chart" width="300" height="200"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Training prompts config
        const TRAINING_COMMANDS = {
            smile_natural: {
                id: "smile_natural",
                text: "Make a natural smile and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "smile",
                duchenne: false,
                difficulty: "E"
            },
            smile_duchenne: {
                id: "smile_duchenne", 
                text: "Duchenne smile: engage the eyes and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "smile",
                duchenne: true,
                difficulty: "M"
            },
            neutral: {
                id: "neutral",
                text: "Hold a neutral face for 2 seconds",
                tts: true,
                duration: 2000,
                target: "neutral",
                duchenne: false,
                difficulty: "E"
            },
            focus: {
                id: "focus",
                text: "Make a focused expression and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "focus",
                duchenne: false,
                difficulty: "M"
            },
            surprised: {
                id: "surprised",
                text: "Make a surprised expression and hold for 1.5 seconds",
                tts: true,
                duration: 1500,
                target: "surprised",
                duchenne: false,
                difficulty: "M"
            },
            sad: {
                id: "sad",
                text: "Make a sad expression and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "sad",
                duchenne: false,
                difficulty: "H"
            },
            disgust: {
                id: "disgust",
                text: "Make a disgust expression and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "disgust",
                duchenne: false,
                difficulty: "H"
            },
            angry: {
                id: "angry",
                text: "Make an angry expression and hold for 2 seconds",
                tts: true,
                duration: 2000,
                target: "angry",
                duchenne: false,
                difficulty: "H"
            }
        };

        // MediaPipe landmarks Á¥¢Âºï (Âü∫‰∫é468ÁÇπÊ®°Âûã)
        const LANDMARKS = {
            // Âò¥ÈÉ®ÂÖ≥ÈîÆÁÇπ
            MOUTH: {
                LEFT_CORNER: 61,    // Â∑¶Âò¥Ëßí
                RIGHT_CORNER: 291,  // Âè≥Âò¥Ëßí
                TOP: 13,           // ‰∏äÂîá‰∏≠ÂøÉ
                BOTTOM: 14,        // ‰∏ãÂîá‰∏≠ÂøÉ
                UPPER_LIP: [12, 15, 16, 17, 18, 200], // ‰∏äÂîáËΩÆÂªì
                LOWER_LIP: [146, 91, 181, 84, 17, 314, 405, 320, 307, 375] // ‰∏ãÂîáËΩÆÂªì
            },
            // Â∑¶ÁúºÂÖ≥ÈîÆÁÇπ
            LEFT_EYE: {
                TOP: 159,
                BOTTOM: 145,
                LEFT: 33,
                RIGHT: 133,
                OUTLINE: [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246]
            },
            // Âè≥ÁúºÂÖ≥ÈîÆÁÇπ
            RIGHT_EYE: {
                TOP: 386,
                BOTTOM: 374,
                LEFT: 362,
                RIGHT: 263,
                OUTLINE: [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398]
            },
            // ÁúâÊØõÂÖ≥ÈîÆÁÇπ
            LEFT_EYEBROW: {
                INNER: 55,   // Â∑¶ÁúâÂÜÖ‰æß
                OUTER: 46,   // Â∑¶ÁúâÂ§ñ‰æß
                CENTER: 70   // Â∑¶Áúâ‰∏≠ÂøÉ
            },
            RIGHT_EYEBROW: {
                INNER: 285,  // Âè≥ÁúâÂÜÖ‰æß
                OUTER: 276,  // Âè≥ÁúâÂ§ñ‰æß
                CENTER: 300  // Âè≥Áúâ‰∏≠ÂøÉ
            },
            NOSE_TIP: 1,     // ÈºªÂ∞ñ
            FACE_OUTLINE: [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109]
        };

        // ÂÖ®Â±ÄÂèòÈáè
        let faceMesh;
        let camera;
        let currentMode = 'film';  // 'film' or 'stage'
        let isTraining = false;
        let isCalibrating = false;
        let baseline = null; // ‰∏™‰∫∫Âü∫Á∫ø
        let currentSession = null;
        let metricsBuffer = [];
        let lastFrameTime = 0;
        let frameCount = 0;
        let fps = 0;
        let scriptIndices = {}; // ÂâßÊú¨Á¥¢ÂºïÔºàÊåâtargetÂ≠òÂÇ®Ôºâ
        let settings = { autoTTS: true, mirror: true };

        // Á∫¢Ê•ºÊ¢¶¬∑ÂâßÊú¨ÂºïÂØºÁ¥†ÊùêÔºàÁ≤æÁÆÄ„ÄÅÂÖ¨ÁâàÔºâ
        const SCRIPT_GUIDES = {
            smile: [
                {
                    work: 'Dream of the Red Chamber', role: 'Jia Baoyu', scene: 'Garden chat',
                    excerpt: 'Seeing Daiyu smiling gently, he cannot help a soft smile.',
                    coaching: 'Natural: lift mouth corners lightly, let the eyes soften; easy breath.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Lin Daiyu', scene: 'With Baochai',
                    excerpt: 'Baochai‚Äôs warm words ease her heart; a knowing smile appears.',
                    coaching: 'Duchenne: let the smile rise from the eyes, then the mouth.'
                }
            ],
            neutral: [
                {
                    work: 'Dream of the Red Chamber', role: 'Xue Baochai', scene: 'Listening calmly',
                    excerpt: 'Composed and poised, neither pleased nor angry, serene as jade.',
                    coaching: 'Neutral: relax jaw and brow, steady gaze, even breath.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Grandmother Jia', scene: 'Seated at the hall',
                    excerpt: 'Sits with ease; kindness contained; features at rest as usual.',
                    coaching: 'On camera, keep stillness; minimize micro-expressions.'
                }
            ],
            focus: [
                {
                    work: 'Dream of the Red Chamber', role: 'Lin Daiyu', scene: 'Burying flowers, composing',
                    excerpt: 'She bends to pick petals, eyes intent, weighing each word.',
                    coaching: 'Focus: lower eyelids slightly, relax forehead, fix the gaze on one point.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Xue Baochai', scene: 'Copying sutras',
                    excerpt: 'Breath steady; hands firm and eyes set; no distraction.',
                    coaching: 'Reduce fidgets; lips lightly closed; fine nasal breath; hands-mind united.'
                }
            ],
            surprised: [
                {
                    work: 'Dream of the Red Chamber', role: 'Jia Baoyu', scene: 'First meeting Daiyu',
                    excerpt: 'At her arrival, his heart stirs; eyes open slightly; a brief start.',
                    coaching: 'Surprise: lift brows a touch, release jaw, let a natural inhale happen.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Wang Xifeng', scene: 'Hearing sudden news',
                    excerpt: 'On hearing strange news, she turns quickly, expression jolted.',
                    coaching: 'Pop the brows/eyes then settle quickly; avoid overdoing it.'
                }
            ],
            sad: [
                {
                    work: 'Dream of the Red Chamber', role: 'Lin Daiyu', scene: 'Ode to Fallen Flowers',
                    excerpt: 'Petals fall and scatter; fragrance fades‚Äîwho will pity?',
                    coaching: 'Sadness: slight brow knit, corners contained, gaze down, shallow breath.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Shi Xiangyun', scene: 'Weeping by the stone',
                    excerpt: 'Leaning alone by the rock, tears not yet dry, a smile hard to keep.',
                    coaching: 'Restrained sorrow: feeling inside, shape in small; avoid sobbing excess.'
                }
            ],
            disgust: [
                {
                    work: 'Dream of the Red Chamber', role: 'Lin Daiyu', scene: 'Aversion to vulgarity',
                    excerpt: 'Hearing coarse talk, she turns away; nose narrows; lips press lightly.',
                    coaching: 'Disgust: lift upper lip a little; wrinkle nose subtly; moderate amplitude.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Jia Baoyu', scene: 'Tiring of success-talk',
                    excerpt: 'At talk of fame and office, he grows impatient and changes the topic.',
                    coaching: 'More emotional disdain: avert gaze; draw corners in slightly.'
                }
            ],
            angry: [
                {
                    work: 'Dream of the Red Chamber', role: 'Wang Xifeng', scene: 'Household scolding',
                    excerpt: 'Brows pressed; eyes cold; her rebuke quiets the hall.',
                    coaching: 'Anger: lower brows, fix gaze; powered exhale, face stays organized.'
                },
                {
                    work: 'Dream of the Red Chamber', role: 'Tanchun', scene: 'Resolute management',
                    excerpt: 'Firm words within measure; expression determined.',
                    coaching: 'Restrained anger: set jaw; lower brows with steady eyes; keep force internal.'
                }
            ]
        };

        // ÂàùÂßãÂåñÂ∫îÁî®
        document.addEventListener('DOMContentLoaded', async () => {
            loadSettings();
            loadBaseline();
            await initializeCamera();
            setupEventListeners();
            applyMirror(settings.mirror);
            syncPreferenceUI();
            updateUI();
            updateScriptGuide();
        });

        // ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô®
        function setupEventListeners() {
            // Ê®°ÂºèÂàáÊç¢
            document.querySelectorAll('.mode-option').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.mode-option').forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    currentMode = option.dataset.mode;
                    updateUI();
                });
            });

            // ÊåâÈíÆ‰∫ã‰ª∂
            document.getElementById('startBtn').addEventListener('click', startTraining);
            document.getElementById('nextBtn').addEventListener('click', nextExpression);
            document.getElementById('calibrateBtn').addEventListener('click', quickCalibrate);
            const resetBtn = document.getElementById('resetCalibrateBtn');
            if (resetBtn) resetBtn.addEventListener('click', resetCalibration);

            // Âè£‰ª§ÈÄâÊã©
            document.getElementById('commandSelect').addEventListener('change', () => {
                updateUI();
                updateScriptGuide();
            });

            // ÂâßÊú¨ÂºïÂØºÊåâÈíÆ
            const nextBtn = document.getElementById('nextScriptBtn');
            const prevBtn = document.getElementById('prevScriptBtn');
            const ttsBtn = document.getElementById('ttsScriptBtn');
            if (nextBtn) nextBtn.addEventListener('click', () => cycleScript(1));
            if (prevBtn) prevBtn.addEventListener('click', () => cycleScript(-1));
            if (ttsBtn) ttsBtn.addEventListener('click', speakCurrentScript);

            // ÂÅèÂ•ΩËÆæÁΩÆ
            const autoTTSChk = document.getElementById('toggleAutoTTS');
            const mirrorChk = document.getElementById('toggleMirror');
            if (autoTTSChk) autoTTSChk.addEventListener('change', () => { settings.autoTTS = !!autoTTSChk.checked; saveSettings(); });
            if (mirrorChk) mirrorChk.addEventListener('change', () => { settings.mirror = !!mirrorChk.checked; applyMirror(settings.mirror); saveSettings(); });

            // Âø´Êç∑ÈîÆ
            window.addEventListener('keydown', (e) => {
                if (e.target && ['INPUT','SELECT','TEXTAREA'].includes(e.target.tagName)) return;
                if (e.key === 's' || e.key === 'S') startTraining();
                if (e.key === 'n' || e.key === 'N') nextExpression();
                if (e.key === 'c' || e.key === 'C') quickCalibrate();
                if (e.key === 't' || e.key === 'T') speakCurrentScript();
            });
        }

        // ÂàùÂßãÂåñÊëÑÂÉèÂ§¥ÂíåMediaPipe
        async function initializeCamera() {
            try {
                // Ëé∑ÂèñÊëÑÂÉèÂ§¥
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                
                const videoElement = document.getElementById('videoElement');
                videoElement.srcObject = stream;
                
                videoElement.onloadedmetadata = () => {
                    const canvas = document.getElementById('overlayCanvas');
                    canvas.width = videoElement.videoWidth;
                    canvas.height = videoElement.videoHeight;
                };

                await initializeFaceMesh();
                document.getElementById('videoStatus').textContent = 'Camera ready';
                
            } catch (error) {
                console.error('Camera init failed:', error);
                document.getElementById('videoStatus').textContent = 'Camera access failed';
            }
        }

        async function initializeFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onResults);

            camera = new Camera(document.getElementById('videoElement'), {
                onFrame: async () => {
                    await faceMesh.send({image: document.getElementById('videoElement')});
                },
                width: 640,
                height: 480
            });

            camera.start();
        }

        // MediaPipeÁªìÊûúÂ§ÑÁêÜ
        function onResults(results) {
            const now = performance.now();
            
            // ËÆ°ÁÆóFPS
            frameCount++;
            if (now - lastFrameTime >= 1000) {
                fps = frameCount;
                lastFrameTime = now;
                frameCount = 0;
            }

            const canvas = document.getElementById('overlayCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                
                // ÁªòÂà∂ËΩÆÂªì
                drawOverlay(ctx, landmarks);
                
                // ÊèêÂèñÁâπÂæÅ
                const metrics = extractMetrics(landmarks);
                
                // Êî∂ÈõÜËÆ≠ÁªÉÊï∞ÊçÆ
                if ((isTraining || isCalibrating) && metrics) {
                    metricsBuffer.push({
                        timestamp: now,
                        metrics: metrics
                    });
                }
                
                document.getElementById('videoStatus').textContent = `Face detected ¬∑ FPS: ${fps}`;
            } else {
                document.getElementById('videoStatus').textContent = 'No face detected';
            }
        }

        // ÁªòÂà∂Èù¢ÈÉ®ËΩÆÂªì - ÁÆÄÂåñÁâàÊú¨Ôºå‰∏ªË¶ÅÊòæÁ§∫Âò¥ÈÉ®ÂíåÁúºÈÉ®
        function drawOverlay(ctx, landmarks) {
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;

            // ÁªòÂà∂Âò¥ÈÉ®ËΩÆÂªì
            drawLandmarkContour(ctx, LANDMARKS.MOUTH.UPPER_LIP, landmarks, '#4ecdc4');
            drawLandmarkContour(ctx, LANDMARKS.MOUTH.LOWER_LIP, landmarks, '#4ecdc4');

            // ÁªòÂà∂ÁúºÈÉ®ËΩÆÂªì
            drawLandmarkContour(ctx, LANDMARKS.LEFT_EYE.OUTLINE, landmarks, '#45b7d1');
            drawLandmarkContour(ctx, LANDMARKS.RIGHT_EYE.OUTLINE, landmarks, '#45b7d1');
        }

        function drawLandmarkContour(ctx, indices, landmarks, color) {
            if (!indices || !landmarks) return;
            
            ctx.strokeStyle = color;
            ctx.beginPath();
            
            let started = false;
            indices.forEach(idx => {
                if (landmarks[idx]) {
                    const point = landmarks[idx];
                    const x = point.x * ctx.canvas.width;
                    const y = point.y * ctx.canvas.height;
                    
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            });
            
            ctx.closePath();
            ctx.stroke();
        }

        /**
         * ÁâπÂæÅÊèêÂèñÂáΩÊï∞
         * Âü∫‰∫éMediaPipe 468ÁÇπÊ®°ÂûãÊèêÂèñÂÖ≥ÈîÆË°®ÊÉÖÁâπÂæÅ
         */
        function extractMetrics(landmarks) {
            if (!landmarks || landmarks.length < 468) return null;

            try {
                // Âò¥ÈÉ®ÁâπÂæÅÁÇπ
                const mouth = {
                    leftCorner: landmarks[LANDMARKS.MOUTH.LEFT_CORNER],
                    rightCorner: landmarks[LANDMARKS.MOUTH.RIGHT_CORNER], 
                    top: landmarks[LANDMARKS.MOUTH.TOP],
                    bottom: landmarks[LANDMARKS.MOUTH.BOTTOM]
                };

                // ÁúºÈÉ®ÁâπÂæÅÁÇπ
                const eyes = {
                    leftTop: landmarks[LANDMARKS.LEFT_EYE.TOP],
                    leftBottom: landmarks[LANDMARKS.LEFT_EYE.BOTTOM],
                    leftLeft: landmarks[LANDMARKS.LEFT_EYE.LEFT],
                    leftRight: landmarks[LANDMARKS.LEFT_EYE.RIGHT],
                    rightTop: landmarks[LANDMARKS.RIGHT_EYE.TOP],
                    rightBottom: landmarks[LANDMARKS.RIGHT_EYE.BOTTOM],
                    rightLeft: landmarks[LANDMARKS.RIGHT_EYE.LEFT],
                    rightRight: landmarks[LANDMARKS.RIGHT_EYE.RIGHT]
                };

                // ÁúâÊØõÁâπÂæÅÁÇπ
                const brows = {
                    leftInner: landmarks[LANDMARKS.LEFT_EYEBROW.INNER],
                    leftOuter: landmarks[LANDMARKS.LEFT_EYEBROW.OUTER],
                    leftCenter: landmarks[LANDMARKS.LEFT_EYEBROW.CENTER],
                    rightInner: landmarks[LANDMARKS.RIGHT_EYEBROW.INNER],
                    rightOuter: landmarks[LANDMARKS.RIGHT_EYEBROW.OUTER],
                    rightCenter: landmarks[LANDMARKS.RIGHT_EYEBROW.CENTER]
                };

                const distance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                // 1. mouthRatio = mouthWidth / mouthHeight (ÂæÆÁ¨ëÊó∂Â¢ûÂ§ß)
                const mouthWidth = distance(mouth.leftCorner, mouth.rightCorner);
                const mouthHeight = distance(mouth.top, mouth.bottom);
                const mouthRatio = mouthWidth / (mouthHeight + 0.001);

                // 2. mouthOpen = mouthHeight / mouthWidth (ÊÉäËÆ∂/Âº†Âè£Êó∂Â¢ûÂ§ß)
                const mouthOpen = mouthHeight / (mouthWidth + 0.001);

                // 3. eyeEAR = Eye Aspect Ratio Âπ≥ÂùáÂÄº (DuchenneÁ¨ëÊó∂ÂáèÂ∞è)
                const leftEAR = distance(eyes.leftTop, eyes.leftBottom) / distance(eyes.leftLeft, eyes.leftRight);
                const rightEAR = distance(eyes.rightTop, eyes.rightBottom) / distance(eyes.rightLeft, eyes.rightRight);
                const eyeEAR = (leftEAR + rightEAR) / 2;

                // 4. browActivity - ÁúâÊØõÊ¥ªÂä®Â∫¶ (Âü∫‰∫éÁúâÂøÉ/ÁúâÂ∞æÂûÇÁõ¥‰ΩçÁßª)
                const leftBrowHeight = Math.abs(brows.leftCenter.y - eyes.leftTop.y);
                const rightBrowHeight = Math.abs(brows.rightCenter.y - eyes.rightTop.y);
                const browActivity = (leftBrowHeight + rightBrowHeight) / 2;

                // 5. symMouth - Âò¥ÈÉ®ÂØπÁß∞ÊÄß (0-1, Âü∫‰∫éÂ∑¶Âè≥Âò¥ËßíyÂùêÊ†áÂ∑Æ)
                const symMouth = 1 - Math.min(1, Math.abs(mouth.leftCorner.y - mouth.rightCorner.y) * 1000);

                // 6. poseYawProxy - ÁÆÄÂåñÂÅèËà™‰ª£ÁêÜ (Âü∫‰∫éÈºªÂ∞ñÁõ∏ÂØπÈù¢ÈÉ®‰∏≠ÂøÉÁöÑÊ∞¥Âπ≥ÂÅèÁßª)
                const noseTip = landmarks[LANDMARKS.NOSE_TIP];
                const poseYawProxy = 1 - Math.min(1, Math.abs(noseTip.x - 0.5) * 2);

                // 7. illumScore - ‰∫ÆÂ∫¶ÂùáÂåÄÂ∫¶Á≤óËØÑ (ÁÆÄÂåñÁâàÊú¨ÔºåÂü∫‰∫éÈù¢ÈÉ®Âå∫Âüü)
                const illumScore = 0.8; // ÁÆÄÂåñÂÆûÁé∞ÔºåÂÆûÈôÖÂ∫îÂü∫‰∫éÂÉèÁ¥†‰∫ÆÂ∫¶ÂàÜÊûê

                return {
                    mouthRatio,
                    mouthOpen,
                    eyeEAR,
                    browActivity,
                    symMouth,
                    poseYawProxy,
                    illumScore,
                    // È¢ùÂ§ñÁöÑËæÖÂä©Êï∞ÊçÆ
                    mouthWidth,
                    mouthHeight,
                    leftEAR,
                    rightEAR
                };

            } catch (error) {
                console.error('ÁâπÂæÅÊèêÂèñÂ§±Ë¥•:', error);
                return null;
            }
        }

        /**
         * ÊäÄÊúØÂ±ÇËØÑÂàÜÂáΩÊï∞
         * ËæìÂÖ•: ÁâπÂæÅÊï∞ÊçÆ, Ê®°Âºè, ÁõÆÊ†áË°®ÊÉÖ, ‰∏™‰∫∫Âü∫Á∫ø
         * ËæìÂá∫: Match/Symmetry/Stability/Aesthetics Âõõ‰∏™ÊäÄÊúØÊåáÊ†á (0-100)
         */
        function scoreFromMetrics(metrics, mode, target, baseline) {
            if (!metrics) return { match: 0, symmetry: 0, stability: 0, aesthetics: 0 };

            // 1. Match ÂåπÈÖçÂ∫¶ - Âü∫‰∫éÁõÆÊ†áË°®ÊÉÖÁöÑÁâπÂæÅÂåπÈÖç
            let match = calculateMatchScore(metrics, target, baseline);

            // 2. Symmetry ÂØπÁß∞ÊÄß - Áõ¥Êé•Êò†Â∞ÑsymMouth
            const symmetry = Math.round(metrics.symMouth * 100);

            // 3. Stability Á®≥ÂÆöÊÄß - Âü∫‰∫é2ÁßíÁ™óÂè£ÂÜÖÁöÑÊñπÂ∑Æ (ÁÆÄÂåñÂÆûÁé∞)
            const stability = calculateStability();

            // 4. Aesthetics ÁæéËßÇÂ∫¶ - Âü∫‰∫éÂßøÊÄÅÂíåÂÖâÁÖß
            const aesthetics = Math.round((metrics.poseYawProxy * 0.6 + metrics.illumScore * 0.4) * 100);

            // ÊúÄÁªàÊäÄÊúØÂàÜÂêàÊàê
            const finalTechScore = Math.round(
                0.5 * match + 
                0.2 * symmetry + 
                0.2 * stability + 
                0.1 * aesthetics
            );

            return {
                match: Math.max(0, Math.min(100, match)),
                symmetry: Math.max(0, Math.min(100, symmetry)),
                stability: Math.max(0, Math.min(100, stability)),
                aesthetics: Math.max(0, Math.min(100, aesthetics)),
                final: Math.max(0, Math.min(100, finalTechScore))
            };
        }

        // ËÆ°ÁÆóÂåπÈÖçÂ∫¶ÂàÜÊï∞
        function calculateMatchScore(metrics, target, baseline) {
            let score = 50; // Âü∫Á°ÄÂàÜ

            if (!baseline) {
                // Êó†Âü∫Á∫øÊó∂ÁöÑÁªùÂØπËØÑÂàÜ
                switch (target) {
                    case 'smile':
                        // ÂæÆÁ¨ë: Âò¥Ëßí‰∏äÊâ¨ (mouthRatioÂ¢ûÂ§ß)
                        score = Math.min(100, (metrics.mouthRatio - 2.0) * 40 + 60);
                        break;
                    case 'surprised':
                        // ÊÉäËÆ∂: Âº†Âè£ + ÁúºË£ÇÂ¢ûÂ§ß
                        score = Math.min(100, metrics.mouthOpen * 80 + 30);
                        break;
                    case 'sad':
                        // ÊÇ≤‰º§: ÁúâÂÜÖÊî∂ + Âò¥Ëßí‰∏ãÂûÇ
                        score = Math.max(30, 70 - metrics.mouthRatio * 10);
                        break;
                    case 'angry':
                        // ÊÑ§ÊÄí: ÁúâÂéã‰Ωé + ÁõÆÂÖâÈõÜ‰∏≠
                        score = 60 + (1 - metrics.browActivity) * 30;
                        break;
                    case 'disgust':
                        // ÂéåÊÅ∂: ‰∏äÂîáÊä¨Ëµ∑
                        score = 50 + metrics.mouthOpen * 30;
                        break;
                    case 'neutral':
                        // ‰∏≠ÊÄß: ÂêÑÊåáÊ†áÊé•ËøëÂπ≥ÂùáÂÄº
                        score = 80 - Math.abs(metrics.mouthRatio - 2.5) * 20;
                        break;
                    case 'focus':
                        // ‰∏ìÊ≥®: ËΩªÂæÆÁúØÁúº
                        score = 70 + (0.3 - metrics.eyeEAR) * 100;
                        break;
                }
            } else {
                // Âü∫‰∫é‰∏™‰∫∫Âü∫Á∫øÁöÑÁõ∏ÂØπËØÑÂàÜ
                const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
                const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR; // Ê≥®ÊÑèÊñπÂêë
                const dMouthOpen = metrics.mouthOpen - baseline.mouthOpen;
                const dBrowActivity = metrics.browActivity - baseline.browActivity;

                switch (target) {
                    case 'smile':
                        score = 60 + dMouthRatio * 50;
                        // DuchenneÁ¨ëÊ£ÄÊµã
                        if (TRAINING_COMMANDS[getCurrentCommandId()].duchenne && dEyeEAR > 0.02) {
                            score += 20; // ÁúºÈÉ®ÂèÇ‰∏éÁöÑÂä†ÂàÜ
                        }
                        break;
                    case 'surprised':
                        score = 60 + dMouthOpen * 100 + dEyeEAR * 50;
                        break;
                    case 'sad':
                        score = 60 + dBrowActivity * 40 - dMouthRatio * 30;
                        break;
                    case 'angry':
                        score = 60 - dBrowActivity * 50 + Math.min(0, -dEyeEAR * 30);
                        break;
                    case 'disgust':
                        score = 60 + dMouthOpen * 80;
                        break;
                    case 'neutral':
                        // ‰∏≠ÊÄßËÑ∏ÔºöÂêÑÈ°πÂèòÂåñÈÉΩÂ∫îËØ•ÂæàÂ∞è
                        const totalChange = Math.abs(dMouthRatio) + Math.abs(dEyeEAR) + Math.abs(dMouthOpen);
                        score = 80 - totalChange * 200;
                        break;
                    case 'focus':
                        score = 60 + dEyeEAR * 100; // ËΩªÂæÆÁúØÁúº
                        break;
                }
            }

            return Math.max(10, Math.min(100, Math.round(score)));
        }

        // ËÆ°ÁÆóÁ®≥ÂÆöÊÄß (ÁÆÄÂåñÂÆûÁé∞)
        function calculateStability() {
            if (metricsBuffer.length < 10) return 70; // ÈªòËÆ§ÂÄº
            
            // ËÆ°ÁÆóÊúÄËøë10Â∏ßÁöÑÂò¥ÈÉ®ÁâπÂæÅÊñπÂ∑Æ
            const recent = metricsBuffer.slice(-10).map(item => item.metrics.mouthRatio);
            const mean = recent.reduce((a, b) => a + b, 0) / recent.length;
            const variance = recent.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / recent.length;
            
            // ÊñπÂ∑ÆË∂äÂ∞èÔºåÁ®≥ÂÆöÊÄßË∂äÈ´ò
            return Math.max(0, Math.min(100, Math.round(100 - variance * 1000)));
        }

        /**
         * Ë°®ÊºîÂ≠¶ÁßëÂõõÁª¥Êò†Â∞Ñ
         * Â∞ÜÊäÄÊúØÊåáÊ†áÊò†Â∞Ñ‰∏∫Ë°®Êºî‰∏ì‰∏öÁöÑÂõõ‰∏™Áª¥Â∫¶
         */
        function mapToActingDimensions(techScores, metrics, mode) {
            const isFilm = mode === 'film';
            const isStage = mode === 'stage';

            // 1. Clarity Ê∏ÖÊô∞Â∫¶ - Ë°®ÊÉÖÊòØÂê¶Ê∏ÖÊô∞ÂèØËØª
            let clarity = techScores.match * 0.7 + techScores.aesthetics * 0.3;
            
            // ËàûÂè∞Ê®°ÂºèÈúÄË¶ÅÊõ¥Â§ßÁöÑÂπÖÂ∫¶ÊâçËÉΩËé∑ÂæóÈ´òÊ∏ÖÊô∞Â∫¶ÂàÜ
            if (isStage) {
                const amplitude = calculateAmplitude(metrics);
                if (amplitude < 0.3) clarity *= 0.7; // ÂπÖÂ∫¶‰∏çË∂≥Êâ£ÂàÜ
            }

            // 2. Consistency ‰∏ÄËá¥ÊÄß - Èù¢ÈÉ®ÂêÑÈÉ®ÂàÜÊòØÂê¶ÂçèË∞É
            let consistency = techScores.stability * 0.8;
            
            // ÁúºÂò¥ÂçèË∞ÉÊÄßÊ£ÄÊµã (ÁÆÄÂåñÁâà)
            const eyeMouthConsistency = calculateEyeMouthConsistency(metrics);
            consistency += eyeMouthConsistency * 0.2;

            // 3. Intensity Âº∫Â∫¶ - Ë°®ÊÉÖÂπÖÂ∫¶ÊòØÂê¶ÈÄÇÂêàÊ®°Âºè
            const amplitude = calculateAmplitude(metrics);
            let intensity = amplitude * 100;
            
            // Ê†πÊçÆÊ®°ÂºèË∞ÉÊï¥Âº∫Â∫¶ËØÑÂàÜ
            if (isStage) {
                // ËàûÂè∞Ê®°ÂºèÂÅèÂ•ΩÊõ¥È´òÂº∫Â∫¶
                intensity *= 1.2;
            } else if (isFilm) {
                // ÂΩ±ËßÜÊ®°ÂºèÂØπËøáÂ∫¶Âº∫Â∫¶Êâ£ÂàÜ
                if (amplitude > 0.8) intensity *= 0.7;
            }

            // 4. Truth ÁúüÂÆûÊÄß - Ê£ÄÊµãÂÅáË°®ÊÉÖ
            let truth = calculateTruthScore(metrics, getCurrentTarget());

            return {
                clarity: Math.max(0, Math.min(100, Math.round(clarity))),
                consistency: Math.max(0, Math.min(100, Math.round(consistency))),
                intensity: Math.max(0, Math.min(100, Math.round(intensity))),
                truth: Math.max(0, Math.min(100, Math.round(truth)))
            };
        }

        // ËÆ°ÁÆóË°®ÊÉÖÂπÖÂ∫¶
        function calculateAmplitude(metrics) {
            if (!baseline) return 0.5; // Êó†Âü∫Á∫øÊó∂ËøîÂõû‰∏≠Á≠âÂπÖÂ∫¶
            
            const dMouthRatio = Math.abs(metrics.mouthRatio - baseline.mouthRatio);
            const dEyeEAR = Math.abs(metrics.eyeEAR - baseline.eyeEAR);
            const dMouthOpen = Math.abs(metrics.mouthOpen - baseline.mouthOpen);
            
            // ÁªºÂêàÂêÑÈ°πÁâπÂæÅÁöÑÂèòÂåñÂπÖÂ∫¶
            return Math.min(1, (dMouthRatio + dEyeEAR * 2 + dMouthOpen) / 3);
        }

        // ËÆ°ÁÆóÁúºÂò¥ÂçèË∞ÉÊÄß
        function calculateEyeMouthConsistency(metrics) {
            if (!baseline) return 50;
            
            const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
            const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR; // Ê≥®ÊÑèÊñπÂêë
            
            // ÂæÆÁ¨ëÊó∂ÔºåÂò¥Ëßí‰∏äÊâ¨Â∫îËØ•‰º¥ÈöèÁúºÈÉ®ÂèòÂåñ
            if (dMouthRatio > 0.1) { // ÊòéÊòæÁöÑÂò¥Ëßí‰∏äÊâ¨
                return dEyeEAR > 0.01 ? 80 : 40; // ÊúâÁúºÈÉ®ÂèÇ‰∏éÂæóÈ´òÂàÜ
            }
            
            return 60; // ÈªòËÆ§‰∏≠Á≠âÂçèË∞ÉÊÄß
        }

        // ËÆ°ÁÆóÁúüÂÆûÊÄßÂàÜÊï∞
        function calculateTruthScore(metrics, target) {
            if (!baseline) return 70; // Êó†Âü∫Á∫øÊó∂ÁöÑÈªòËÆ§ÂÄº
            
            const dMouthRatio = metrics.mouthRatio - baseline.mouthRatio;
            const dEyeEAR = baseline.eyeEAR - metrics.eyeEAR;
            
            let truth = 75; // Âü∫Á°ÄÁúüÂÆûÊÄßÂàÜÊï∞
            
            switch (target) {
                case 'smile':
                    // Ê£ÄÊµãÂÅáÁ¨ë: Âò¥Ëßí‰∏äÊâ¨‰ΩÜÁúºÈÉ®Êó†ÂèòÂåñ
                    if (dMouthRatio > 0.1 && dEyeEAR < 0.005) {
                        truth -= 30; // ‰∏•ÈáçÂÅáÁ¨ë
                    } else if (dMouthRatio > 0.05 && dEyeEAR < 0.01) {
                        truth -= 15; // ËΩªÂæÆÂÅáÁ¨ë
                    }
                    break;
                    
                case 'sad':
                    // ÊÇ≤‰º§Êó∂ÁúâÁúºÂò¥ÁöÑÊñπÂêëÂ∫îËØ•‰∏ÄËá¥
                    const browDown = metrics.browActivity < baseline.browActivity;
                    const mouthDown = dMouthRatio < -0.02;
                    if (browDown !== mouthDown) {
                        truth -= 20; // Ë°®ÊÉÖ‰∏ç‰∏ÄËá¥
                    }
                    break;
                    
                case 'surprised':
                    // ÊÉäËÆ∂Êó∂ÁúâÊØõ‰∏äÊâ¨ÂíåÂº†Âò¥Â∫îËØ•ÂêåÊó∂ÂèëÁîü
                    const browUp = metrics.browActivity > baseline.browActivity;
                    const mouthOpen = metrics.mouthOpen > baseline.mouthOpen + 0.05;
                    if (browUp !== mouthOpen) {
                        truth -= 15;
                    }
                    break;
            }
            
            return Math.max(30, Math.min(100, truth));
        }

        /**
         * Ë°®ÊºîËØ≠Ë®ÄÂèçÈ¶àÁîüÊàê
         * Âü∫‰∫éËØÑÂàÜÁªìÊûúÁîüÊàêËá™ÁÑ∂ÁöÑ‰∏≠ÊñáË°®ÊºîÂª∫ËÆÆ
         */
        function generateActingTips(dimScores, metrics, target, mode) {
            const tips = [];
            const isFilm = mode === 'film';
            const isStage = mode === 'stage';
            const amplitude = calculateAmplitude(metrics);
            
            // Clarity Ê∏ÖÊô∞Â∫¶ÂèçÈ¶à
            if (dimScores.clarity < 60) {
                if (isStage) {
                    tips.push("Clarity is low for stage distance. Enlarge mouth spread or brow movement about 15%.");
                } else {
                    tips.push("Expression isn‚Äôt clear enough. Make the action a touch more defined while staying natural.");
                }
            }
            
            // Intensity Âº∫Â∫¶ÂèçÈ¶à
            if (dimScores.intensity > 85 && isFilm) {
                tips.push("Amplitude is exaggerated for camera. Reduce about 20% to preserve authenticity.");
            } else if (dimScores.intensity < 50 && isStage) {
                tips.push("For stage, increase amplitude so faces read from the back rows.");
            }
            
            // Truth ÁúüÂÆûÊÄßÂèçÈ¶à
            if (dimScores.truth < 60) {
                switch (target) {
                    case 'smile':
                        tips.push("Á¨ëÂÅúÂú®Âò¥ËßíÔºåÁúºÁ•ûÊ≤°ÊúâÂà∞‰Ωç„ÄÇËΩªÁúØÁúº10%ÔºåÊääÊ≥®ÊÑèÂäõÊîæÂú®'ÊÉ≥Á¨ëÁöÑÁêÜÁî±'‰∏ä„ÄÇ");
                        break;
                    case 'sad':
                        tips.push("ÊÇ≤‰º§Ë°®ÊÉÖÈúÄË¶ÅÁúâÁúºÂò¥ÁöÑÁªü‰∏Ä„ÄÇÂÖà‰ªéÂÜÖÂøÉÊÑüÂèóÂºÄÂßãÔºåËÆ©Ë°®ÊÉÖËá™ÁÑ∂ÊµÅÈú≤„ÄÇ");
                        break;
                    case 'angry':
                        tips.push("ÊÑ§ÊÄí‰∏çÂè™ÊòØÁúâÊØõÔºåÁúºÁ•ûÁöÑ‰∏ìÊ≥®ÂíåÂò¥ÈÉ®ÁöÑÁ¥ßÁª∑ÂêåÊ†∑ÈáçË¶Å„ÄÇ");
                        break;
                }
            }
            
            // Consistency ‰∏ÄËá¥ÊÄßÂèçÈ¶à
            if (dimScores.consistency < 60) {
                tips.push("Upper and lower face aren‚Äôt unified. Set the eyes first, then bring in the mouth gradually.");
            }
            
            // ÂÖâÁÖßÂíåÂßøÊÄÅÂèçÈ¶à
            if (metrics.illumScore < 0.6) {
                tips.push("Adjust light to a 30‚Äì45¬∞ frontal angle to improve readability.");
            }
            
            if (metrics.poseYawProxy < 0.7) {
                tips.push("Face the camera frontally; avoid profile which reduces recognition.");
            }
            
            // ÁâπÂÆöË°®ÊÉÖÁöÑ‰∏ìÈ°πÂª∫ËÆÆ
            addSpecificTips(tips, target, metrics, dimScores);
            
            // Â¶ÇÊûúÊ≤°ÊúâÈóÆÈ¢òÔºåÁªô‰∫àÈºìÂä±
            if (tips.length === 0) {
                const avgScore = (dimScores.clarity + dimScores.consistency + dimScores.intensity + dimScores.truth) / 4;
                if (avgScore > 80) {
                    tips.push("Great work ‚Äî natural and truthful, fitting " + (isFilm ? "film" : "stage") + " demands.");
                } else {
                    tips.push("Solid overall. Keep this state; practice will make it feel even more natural.");
                }
            }
            
            return tips.slice(0, 4); // ÈôêÂà∂‰∏∫ÊúÄÂ§ö4Êù°Âª∫ËÆÆ
        }

        // Ê∑ªÂä†ÁâπÂÆöË°®ÊÉÖÁöÑ‰∏ìÈ°πÂª∫ËÆÆ
        function addSpecificTips(tips, target, metrics, dimScores) {
            switch (target) {
                case 'smile':
                    if (TRAINING_COMMANDS[getCurrentCommandId()].duchenne) {
                        if (dimScores.truth < 70) {
                            tips.push("Duchenne needs eye involvement. Recall a truly happy moment so the eye corners engage.");
                        }
                    }
                    break;
                    
                case 'surprised':
                    if (metrics.mouthOpen < (baseline ? baseline.mouthOpen + 0.05 : 0.1)) {
                        tips.push("For surprise, release the jaw and separate the lips ‚Äî as if truly startled.");
                    }
                    break;
                    
                case 'sad':
                    if (dimScores.intensity < 50) {
                        tips.push("Sadness isn‚Äôt only drooping corners. A slight brow knit and distant gaze help.");
                    }
                    break;
                    
                case 'angry':
                    if (dimScores.clarity < 60) {
                        tips.push("Core of anger is the eyes. Lower the brows while keeping the gaze concentrated.");
                    }
                    break;
            }
        }

        // ÂºÄÂßãËÆ≠ÁªÉ
        async function startTraining() {
            if (isTraining) return;
            
            const commandId = document.getElementById('commandSelect').value;
            const command = TRAINING_COMMANDS[commandId];
            
            if (!command) return;
            
            isTraining = true;
            metricsBuffer = [];
            
            // Êõ¥Êñ∞UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('currentCommand').textContent = command.text;
            
            // Ëá™Âä®Êí≠Êä•ÔºöÂÖàÊí≠Êä•ÂâßÊú¨Âè∞ËØçÔºåÂÜçÊí≠Êä•ËÆ≠ÁªÉÂè£‰ª§
            try {
                if (settings.autoTTS) {
                    await speakCurrentScriptAsync();
                    if (command.tts) {
                        await ttsSpeak(command.text);
                    }
                    // 0.5ÁßíÂëºÂê∏ÂÅúÈ°ø
                    await new Promise(r => setTimeout(r, 500));
                }
            } catch (e) { /* ÂøΩÁï•TTSÈîôËØØ */ }
            
            // ÂÄíËÆ°Êó∂
            await countdown(3);
            
            // ÂºÄÂßãËÆ∞ÂΩï
            currentSession = {
                mode: currentMode,
                command: command,
                startTime: performance.now()
            };
            
            // ËÆ≠ÁªÉËÆ°Êó∂
            setTimeout(() => {
                finishTraining();
            }, command.duration);
            
            // ÊòæÁ§∫ÂÄíËÆ°Êó∂
            showTrainingCountdown(command.duration);
        }

        // Âü∫Á°ÄTTSÔºåËøîÂõûPromiseÁî®‰∫é‰∏≤ËÅî
        function ttsSpeak(text, opts = {}) {
            return new Promise((resolve) => {
                if (!('speechSynthesis' in window) || !text) return resolve();
                try { window.speechSynthesis.cancel(); } catch (e) {}
                const u = new SpeechSynthesisUtterance(text);
                u.lang = opts.lang || 'en-US';
                if (opts.rate) u.rate = opts.rate;
                if (opts.pitch) u.pitch = opts.pitch;
                if (opts.volume) u.volume = opts.volume;
                const done = () => resolve();
                u.onend = done; u.onerror = done; u.onpause = done; u.onboundary = null;
                window.speechSynthesis.speak(u);
                // ‰øùÈô©Ë∂ÖÊó∂ÔºöÊúÄÈïø6Áßí
                setTimeout(done, opts.timeoutMs || 6000);
            });
        }

        // ÊúóËØªÂΩìÂâçÂâßÊú¨Âè∞ËØçÔºàPromiseÁâàÔºâ
        function speakCurrentScriptAsync() {
            const excerpt = (document.getElementById('scriptExcerpt')?.textContent || '').trim();
            if (!excerpt) return Promise.resolve();
            const text = excerpt.replace(/^‚Äú|‚Äù$/g, '');
            return ttsSpeak(text, { lang: 'en-US', timeoutMs: 7000 });
        }

        // ÂÄíËÆ°Êó∂ÊòæÁ§∫
        async function countdown(seconds) {
            const countdownEl = document.getElementById('countdown');
            
            for (let i = seconds; i > 0; i--) {
                countdownEl.textContent = i;
                countdownEl.style.color = '#ff6b6b';
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            countdownEl.textContent = 'Go!';
            countdownEl.style.color = '#4ecdc4';
            await new Promise(resolve => setTimeout(resolve, 500));
            countdownEl.textContent = '';
        }

        // ÊòæÁ§∫ËÆ≠ÁªÉÂÄíËÆ°Êó∂
        function showTrainingCountdown(duration) {
            const countdownEl = document.getElementById('countdown');
            const startTime = Date.now();
            
            const updateCountdown = () => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, duration - elapsed);
                const seconds = (remaining / 1000).toFixed(1);
                
                countdownEl.textContent = `${seconds}s`;
                countdownEl.style.color = '#4ecdc4';
                
                if (remaining > 0) {
                    requestAnimationFrame(updateCountdown);
                } else {
                    countdownEl.textContent = '';
                }
            };
            
            requestAnimationFrame(updateCountdown);
        }

        // ÂÆåÊàêËÆ≠ÁªÉ
        function finishTraining() {
            isTraining = false;
            currentSession.endTime = performance.now();
            
            // ÂàÜÊûêÁªìÊûú
            if (metricsBuffer.length > 0) {
                analyzeSession();
            }
            
            document.getElementById('startBtn').disabled = false;
        }

        // ÂàÜÊûêËÆ≠ÁªÉ‰ºöËØù
        function analyzeSession() {
            // ËÆ°ÁÆóÂπ≥ÂùáÁâπÂæÅ
            const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
            if (validMetrics.length === 0) return;
            
            const avgMetrics = calculateAverageMetrics(validMetrics);
            
            // ÊäÄÊúØÂ±ÇËØÑÂàÜ
            const techScores = scoreFromMetrics(avgMetrics, currentMode, getCurrentTarget(), baseline);
            
            // Ë°®ÊºîÁª¥Â∫¶Êò†Â∞Ñ
            const dimScores = mapToActingDimensions(techScores, avgMetrics, currentMode);
            
            // ÁîüÊàêÂèçÈ¶à
            const tips = generateActingTips(dimScores, avgMetrics, getCurrentTarget(), currentMode);
            
            // Êõ¥Êñ∞UI
            updateScoreDisplay(techScores, dimScores);
            updateTips(tips);
            showResults(dimScores, avgMetrics);
        }

        // ËÆ°ÁÆóÂπ≥ÂùáÁâπÂæÅ
        function calculateAverageMetrics(metrics) {
            const avg = {};
            const keys = Object.keys(metrics[0]);
            
            keys.forEach(key => {
                avg[key] = metrics.reduce((sum, m) => sum + m[key], 0) / metrics.length;
            });
            
            return avg;
        }

        // Êõ¥Êñ∞ÂàÜÊï∞ÊòæÁ§∫
        function updateScoreDisplay(techScores, dimScores) {
            // Êõ¥Êñ∞ÂæΩÁ´†
            updateBadge('clarityBadge', 'clarityScore', dimScores.clarity);
            updateBadge('consistencyBadge', 'consistencyScore', dimScores.consistency);
            updateBadge('intensityBadge', 'intensityScore', dimScores.intensity);
            updateBadge('truthBadge', 'truthScore', dimScores.truth);
            
            // Êõ¥Êñ∞ÊäÄÊúØÊåáÊ†á
            document.getElementById('matchScore').textContent = techScores.match;
            document.getElementById('symmetryScore').textContent = techScores.symmetry;
            document.getElementById('stabilityScore').textContent = techScores.stability;
            document.getElementById('aestheticsScore').textContent = techScores.aesthetics;
            
            // Êõ¥Êñ∞ÊÄªÂàÜÂíåËøõÂ∫¶Êù°
            const totalScore = Math.round((dimScores.clarity + dimScores.consistency + dimScores.intensity + dimScores.truth) / 4);
            document.getElementById('totalScore').textContent = totalScore;
            document.getElementById('progressFill').style.width = `${totalScore}%`;
        }

        // Êõ¥Êñ∞Âçï‰∏™ÂæΩÁ´†
        function updateBadge(badgeId, scoreId, score) {
            const badge = document.getElementById(badgeId);
            const scoreEl = document.getElementById(scoreId);
            
            scoreEl.textContent = score;
            
            // ÁßªÈô§ÊâÄÊúâÊ†∑ÂºèÁ±ª
            badge.classList.remove('excellent', 'good', 'needs-work');
            
            // Ê†πÊçÆÂàÜÊï∞Ê∑ªÂä†Ê†∑Âºè
            if (score >= 80) {
                badge.classList.add('excellent');
            } else if (score >= 60) {
                badge.classList.add('good');
            } else {
                badge.classList.add('needs-work');
            }
        }

        // Êõ¥Êñ∞Âª∫ËÆÆÈù¢Êùø
        function updateTips(tips) {
            const container = document.getElementById('tipsContainer');
            container.innerHTML = '';
            
            tips.forEach(tip => {
                const tipEl = document.createElement('div');
                tipEl.className = 'tip-item';
                tipEl.textContent = tip;
                container.appendChild(tipEl);
            });
        }

        // ÊòæÁ§∫ÁªìÊûúÂå∫Âüü
        function showResults(dimScores, metrics) {
            const resultsSection = document.getElementById('resultsSection');
            resultsSection.classList.add('visible');
            
            // Êõ¥Êñ∞Ê†áÈ¢ò
            const commandText = TRAINING_COMMANDS[getCurrentCommandId()].text;
            document.getElementById('resultsTitle').textContent = `${currentMode === 'film' ? 'Film' : 'Stage'} mode - ${commandText}`;
            
            // Êõ¥Êñ∞ÂπÖÂ∫¶Ê†áÁ≠æ
            const amplitude = calculateAmplitude(metrics);
            const amplitudeLabel = document.getElementById('amplitudeLabel');
            
            if (amplitude < 0.3) {
                amplitudeLabel.textContent = 'Subtle';
                amplitudeLabel.className = 'amplitude-label amplitude-subtle';
            } else if (amplitude < 0.7) {
                amplitudeLabel.textContent = 'Medium';
                amplitudeLabel.className = 'amplitude-label amplitude-medium';
            } else {
                amplitudeLabel.textContent = 'Exaggerated';
                amplitudeLabel.className = 'amplitude-label amplitude-exaggerated';
            }
            
            // ÁªòÂà∂ÂõæË°®
            drawRadarChart(dimScores);
            drawBarChart(dimScores);
        }

        // ÁªòÂà∂Èõ∑ËææÂõæ
        function drawRadarChart(scores) {
            const canvas = document.getElementById('radarChart');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 40;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ÁªòÂà∂ÁΩëÊ†º
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            
            for (let i = 1; i <= 5; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * i / 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // ÁªòÂà∂ÂùêÊ†áËΩ¥ÂíåÊ†áÁ≠æ
            const labels = ['Clarity', 'Consistency', 'Intensity', 'Truth'];
            const values = [scores.clarity, scores.consistency, scores.intensity, scores.truth];
            
            ctx.font = '12px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 - Math.PI / 2;
                const x1 = centerX;
                const y1 = centerY;
                const x2 = centerX + Math.cos(angle) * radius;
                const y2 = centerY + Math.sin(angle) * radius;
                
                // ÁªòÂà∂ËΩ¥Á∫ø
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // ÁªòÂà∂Ê†áÁ≠æ
                const labelX = centerX + Math.cos(angle) * (radius + 20);
                const labelY = centerY + Math.sin(angle) * (radius + 20);
                ctx.fillText(labels[i], labelX, labelY);
            }
            
            // ÁªòÂà∂Êï∞ÊçÆÂ§öËæπÂΩ¢
            ctx.strokeStyle = '#4ecdc4';
            ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 - Math.PI / 2;
                const value = values[i] / 100;
                const x = centerX + Math.cos(angle) * radius * value;
                const y = centerY + Math.sin(angle) * radius * value;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                // ÁªòÂà∂Êï∞ÊçÆÁÇπ
                ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.closePath();
            ctx.fillStyle = 'rgba(78, 205, 196, 0.3)';
            ctx.fill();
            ctx.strokeStyle = '#4ecdc4';
            ctx.stroke();
        }

        // ÁªòÂà∂Êü±Áä∂Âõæ
        function drawBarChart(scores) {
            const canvas = document.getElementById('barChart');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            const barWidth = (width - padding * 2) / 4 - 10;
            
            ctx.clearRect(0, 0, width, height);
            
            const labels = ['Clarity', 'Consistency', 'Intensity', 'Truth'];
            const values = [scores.clarity, scores.consistency, scores.intensity, scores.truth];
            const colors = ['#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            
            // ÁªòÂà∂Êü±Áä∂Âõæ
            for (let i = 0; i < 4; i++) {
                const x = padding + i * (barWidth + 10);
                const barHeight = (values[i] / 100) * (height - padding * 2);
                const y = height - padding - barHeight;
                
                // ÁªòÂà∂Êü±Â≠ê
                ctx.fillStyle = colors[i];
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // ÁªòÂà∂Êï∞ÂÄº
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(values[i], x + barWidth / 2, y - 5);
                
                // ÁªòÂà∂Ê†áÁ≠æ
                ctx.font = '10px Arial';
                ctx.fillText(labels[i], x + barWidth / 2, height - padding + 15);
            }
        }

        // Quick Calibrate
        async function quickCalibrate() {
            if (isCalibrating) return;
            
            isCalibrating = true;
            metricsBuffer = [];
            
            document.getElementById('calibrateBtn').disabled = true;
            document.getElementById('currentCommand').textContent = 'Hold a neutral face for calibration...';
            
            // TTSÊèêÁ§∫
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance('Please hold a neutral face for one second to calibrate');
                utterance.lang = 'en-US';
                speechSynthesis.speak(utterance);
            }
            
            // 1.2ÁßíÊ†°ÂáÜÊó∂Èó¥ÔºàËàçÂºÉÂâç200msÔºâ
            const startTs = performance.now();
            await new Promise(resolve => setTimeout(resolve, 1200));
            
            // ËÆ°ÁÆóÂü∫Á∫ø
            if (metricsBuffer.length > 0) {
                const validMetrics = metricsBuffer.map(item => item.metrics).filter(m => m !== null);
                if (validMetrics.length > 0) {
                    // ËàçÂºÉÂâç200msÁöÑÊ†∑Êú¨
                    const filtered = metricsBuffer.filter(it => it.timestamp >= startTs + 200).map(it => it.metrics);
                    baseline = calculateAverageMetrics(filtered.length ? filtered : validMetrics);
                    try { localStorage.setItem('fec_baseline', JSON.stringify(baseline)); } catch (e) {}
                    document.getElementById('currentCommand').textContent = '‚úÖ Calibration complete! You can start training now';
                    
                    // Êõ¥Êñ∞Âª∫ËÆÆ
                    updateTips(['Calibration saved. Scoring will be based on your personal baseline for better accuracy.']);
                } else {
                    document.getElementById('currentCommand').textContent = '‚ùå Calibration failed. No face detected';
                }
            } else {
                document.getElementById('currentCommand').textContent = '‚ùå Calibration failed. Please ensure your face is clearly visible';
            }
            
            isCalibrating = false;
            document.getElementById('calibrateBtn').disabled = false;
        }

        function resetCalibration() {
            baseline = null;
            try { localStorage.removeItem('fec_baseline'); } catch (e) {}
            updateTips(['Calibration has been reset. Run Quick Calibrate before training for more accurate feedback.']);
            document.getElementById('currentCommand').textContent = 'Calibration cleared. You can run Quick Calibrate again.';
        }

        // ‰∏ã‰∏Ä‰∏™Ë°®ÊÉÖ
        function nextExpression() {
            const select = document.getElementById('commandSelect');
            const options = Array.from(select.options);
            const currentIndex = options.findIndex(opt => opt.selected);
            const nextIndex = (currentIndex + 1) % options.length;
            
            select.selectedIndex = nextIndex;
            updateUI();
            updateScriptGuide();
            
            // ÈöêËóèÁªìÊûúÂå∫Âüü
            document.getElementById('resultsSection').classList.remove('visible');
        }

        // Êõ¥Êñ∞UIÁä∂ÊÄÅ
        function updateUI() {
            const commandId = document.getElementById('commandSelect').value;
            const command = TRAINING_COMMANDS[commandId];
            
            if (command) {
                document.getElementById('currentCommand').textContent = `Ready: ${command.text}`;
            }
            
            // Update mode title
            const modeText = currentMode === 'film' ? 'Film mode' : 'Stage mode';
            document.title = `Expression Coach Pro - ${modeText}`;
        }

        // ËæÖÂä©ÂáΩÊï∞
        function getCurrentCommandId() {
            return document.getElementById('commandSelect').value;
        }

        function getCurrentTarget() {
            const commandId = getCurrentCommandId();
            return TRAINING_COMMANDS[commandId] ? TRAINING_COMMANDS[commandId].target : 'neutral';
        }

        // ÂÅèÂ•ΩËÆæÁΩÆ‰∏éÈïúÂÉè
        function loadSettings() {
            try {
                const s = JSON.parse(localStorage.getItem('fec_settings') || '{}');
                settings = { autoTTS: true, mirror: true, ...s };
            } catch (e) { settings = { autoTTS: true, mirror: true }; }
        }
        function saveSettings() {
            try { localStorage.setItem('fec_settings', JSON.stringify(settings)); } catch (e) {}
        }
        function syncPreferenceUI() {
            const autoTTSChk = document.getElementById('toggleAutoTTS');
            const mirrorChk = document.getElementById('toggleMirror');
            if (autoTTSChk) autoTTSChk.checked = !!settings.autoTTS;
            if (mirrorChk) mirrorChk.checked = !!settings.mirror;
        }
        function applyMirror(flag) {
            const v = document.getElementById('videoElement');
            const c = document.getElementById('overlayCanvas');
            if (v) v.style.transform = flag ? 'scaleX(-1)' : 'none';
            if (c) c.style.transform = flag ? 'scaleX(-1)' : 'none';
        }
        function loadBaseline() {
            try {
                const b = JSON.parse(localStorage.getItem('fec_baseline') || 'null');
                if (b && typeof b === 'object') {
                    baseline = b;
                    updateTips(['Loaded saved calibration. Your scores will use your personal baseline.']);
                }
            } catch (e) {}
        }

        // ÂâßÊú¨ÂºïÂØºÈÄªËæë
        function mapCommandTargetToScriptKey(target) {
            // ÁõÆÂâçËÆ≠ÁªÉtargetÂç≥ÂØπÂ∫îËÑöÊú¨key
            return target === 'smile' ? 'smile' : target;
        }

        function getScriptListForTarget(target) {
            const key = mapCommandTargetToScriptKey(target || 'neutral');
            return SCRIPT_GUIDES[key] || [];
        }

        function getScriptIndex(target) {
            const key = mapCommandTargetToScriptKey(target);
            if (!(key in scriptIndices)) scriptIndices[key] = 0;
            return scriptIndices[key];
        }

        function setScriptIndex(target, idx) {
            const key = mapCommandTargetToScriptKey(target);
            scriptIndices[key] = idx;
        }

        function updateScriptGuide() {
            const target = getCurrentTarget();
            const list = getScriptListForTarget(target);
            const metaEl = document.getElementById('scriptMeta');
            const excerptEl = document.getElementById('scriptExcerpt');
            const noteEl = document.getElementById('scriptNote');

            if (!metaEl || !excerptEl || !noteEl) return;

            if (!list.length) {
                metaEl.textContent = 'Dream of the Red Chamber ¬∑ No matching scene';
                excerptEl.textContent = 'No script guidance configured for this expression yet.';
                noteEl.textContent = 'Tip: You can still train using the Acting Tips above.';
                return;
            }

            const idx = Math.max(0, Math.min(getScriptIndex(target), list.length - 1));
            const item = list[idx];
            metaEl.textContent = `${item.work} ¬∑ ${item.scene} ¬∑ Role: ${item.role}`;
            excerptEl.textContent = `‚Äú${item.excerpt}‚Äù`;
            noteEl.textContent = item.coaching || '';
        }

        function cycleScript(step) {
            const target = getCurrentTarget();
            const list = getScriptListForTarget(target);
            if (!list.length) return;
            const cur = getScriptIndex(target);
            const next = (cur + step + list.length) % list.length;
            setScriptIndex(target, next);
            updateScriptGuide();
        }

        function speakCurrentScript() {
            if (!('speechSynthesis' in window)) return;
            const excerpt = (document.getElementById('scriptExcerpt')?.textContent || '').trim();
            if (!excerpt) return;
            const text = excerpt.replace(/^‚Äú|‚Äù$/g, '');
            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = 'zh-CN';
            try { window.speechSynthesis.cancel(); } catch (e) {}
            window.speechSynthesis.speak(utter);
        }
    </script>
</body>
</html>
